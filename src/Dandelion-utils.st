Object subclass: #DlAccessorMutatorCreator	instanceVariableNames: 'targetClassDescription variableNames isLazyInitializationSupport isDependencySupport extraAccessorBlock extraMutatorBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlAccessorMutatorCreator commentStamp: '<historical>' prior: 0!I build accessors and mutators for classes( or metaclasses).By using #extraAccessorBlock:, I provide a simple hook for custmizing code generation.#creator[:masashi | ^umezawa] #version 0.5!!DlAccessorMutatorCreator methodsFor: 'initialize-release' stamp: 'MU 11/27/1998 01:24'!initialize: aClassDescription 	self targetClassDescription: aClassDescription.	self variableNames: aClassDescription instVarNames! !!DlAccessorMutatorCreator methodsFor: 'actions' stamp: 'MU 11/27/1998 00:36'!addAccessorMutators	self addAccessors.	self addMutators		! !!DlAccessorMutatorCreator methodsFor: 'actions' stamp: 'M.U 6/5/1999 23:36'!addAccessors	self isLazyInitializationSupport		ifTrue: [self addLazyInitializeAccessors]		ifFalse: [self addNormalAccessors].! !!DlAccessorMutatorCreator methodsFor: 'actions' stamp: 'minami 4/17/2003 02:09'!addDependencyMutators	self		addMethodsUsing: 			[:aStream :eachName | 			aStream nextPutAll: eachName.			aStream nextPutAll: ': aValue'.			aStream cr; cr; tab.			aStream nextPutAll: eachName.			aStream nextPutAll: ' := aValue'.			aStream cr; tab.			self dependencyBlock value: aStream value: eachName.			self extraMutatorBlock value: aStream value: eachName.]! !!DlAccessorMutatorCreator methodsFor: 'actions' stamp: 'M.U 1/10/2000 00:36'!addLazyInitializeAccessors	self		addMethodsUsing: 			[:aStream :eachName | 			aStream nextPutAll: eachName.			aStream cr; cr; tab.			self lazyInitializationBlock value: aStream value: eachName.			self extraAccessorBlock value: aStream value: eachName.			aStream nextPut: $^.			aStream nextPutAll: eachName]! !!DlAccessorMutatorCreator methodsFor: 'actions' stamp: 'M.U 6/5/1999 23:37'!addMutators	self isDependencySupport		ifTrue: [self addDependencyMutators]		ifFalse: [self addNormalMutators].! !!DlAccessorMutatorCreator methodsFor: 'actions' stamp: 'M.U 1/10/2000 00:37'!addNormalAccessors	self		addMethodsUsing: 			[:aStream :eachName | 			aStream nextPutAll: eachName.			aStream cr; cr; tab.			self extraAccessorBlock value: aStream value: eachName.			aStream nextPut: $^.			aStream nextPutAll: eachName]! !!DlAccessorMutatorCreator methodsFor: 'actions' stamp: 'M.U 6/5/1999 23:33'!addNormalMutators	self		addMethodsUsing: 			[:aStream :eachName | 			aStream nextPutAll: eachName.			aStream nextPutAll: ': aValue'.			aStream cr; cr; tab.			aStream nextPutAll: eachName.			aStream nextPutAll: ' := aValue']! !!DlAccessorMutatorCreator methodsFor: 'actions-raw' stamp: 'M.U 1/10/2000 01:10'!addMethodsOf: aCollectionOfVariableNames using: aBlock category: aMethodCategory	| aStream |	Cursor execute showWhile:[	aCollectionOfVariableNames do: [:eachName | (self targetClassDescription includesSelector: (eachName , ':') asSymbol)			ifFalse: 				[aStream := WriteStream on: (String new: 40).				aBlock value: aStream value: eachName.				self targetClassDescription compile: aStream contents classified: aMethodCategory]].].	self changed: #addMethods! !!DlAccessorMutatorCreator methodsFor: 'actions-raw' stamp: 'M.U 1/10/2000 01:12'!addMethodsUsing: aBlock	self addMethodsOf: self variableNames using: aBlock category: #accessing! !!DlAccessorMutatorCreator methodsFor: 'actions-raw' stamp: 'M.U 1/10/2000 01:14'!addMethodsUsing: aBlock category: aCategorySymbol	self addMethodsOf: self variableNames using: aBlock category: aCategorySymbol! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 1/10/2000 00:38'!extraAccessorBlock	extraAccessorBlock isNil ifTrue:[extraAccessorBlock := self defaultExtraAccessorBlock].	^extraAccessorBlock! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 1/10/2000 00:24'!extraAccessorBlock: aBlock	extraAccessorBlock := aBlock! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 1/10/2000 00:39'!extraMutatorBlock	extraMutatorBlock isNil ifTrue:[extraMutatorBlock := self defaultExtraMutatorBlock].	^extraMutatorBlock! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 1/10/2000 00:25'!extraMutatorBlock: aBlock	extraMutatorBlock := aBlock! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 6/5/1999 23:32'!isDependencySupport	isDependencySupport isNil ifTrue:[ isDependencySupport := false. ].	^isDependencySupport! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 6/5/1999 23:31'!isDependencySupport: aBoolean	isDependencySupport := aBoolean! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 6/5/1999 23:35'!isLazyInitializationSupport	isLazyInitializationSupport isNil ifTrue:[ isLazyInitializationSupport := false. ].	^isLazyInitializationSupport! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'M.U 6/5/1999 23:35'!isLazyInitializationSupport: aBoolean	isLazyInitializationSupport := aBoolean! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'MU 11/27/1998 00:04'!targetClassDescription	^targetClassDescription! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'MU 11/27/1998 00:05'!targetClassDescription: aTargetClassDescription	targetClassDescription := aTargetClassDescription! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'MU 11/27/1998 00:11'!variableNames	^variableNames! !!DlAccessorMutatorCreator methodsFor: 'accessing' stamp: 'MU 11/27/1998 00:43'!variableNames: someVariableNames	variableNames := someVariableNames.! !!DlAccessorMutatorCreator methodsFor: 'factory' stamp: 'M.U 1/10/2000 00:40'!defaultExtraAccessorBlock	"default do nothing"	^[:aStream :eachName | ]! !!DlAccessorMutatorCreator methodsFor: 'factory' stamp: 'M.U 1/10/2000 00:40'!defaultExtraMutatorBlock	"default do nothing"	^[:aStream :eachName | ]! !!DlAccessorMutatorCreator methodsFor: 'factory' stamp: 'M.U 1/10/2000 00:34'!dependencyBlock	"dependency support"	^[:aStream :eachName | 			aStream cr; tab.			aStream nextPutAll: 'self changed: #'.			aStream nextPutAll: eachName]! !!DlAccessorMutatorCreator methodsFor: 'factory' stamp: 'M.U 1/10/2000 00:34'!lazyInitializationBlock	"lazy initialization support"	^[:aStream :eachName | 			aStream nextPutAll: eachName.			aStream nextPutAll: ' isNil ifTrue:[ '.			aStream nextPutAll: eachName.			aStream nextPutAll: ' := ''''. ].'.			aStream cr; cr; tab.]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAccessorMutatorCreator class	instanceVariableNames: ''!!DlAccessorMutatorCreator class methodsFor: 'instance creation' stamp: 'MU 11/27/1998 00:43'!on: aClassDescription	^self new initialize: aClassDescription! !!DlAccessorMutatorCreator class methodsFor: 'facade api' stamp: 'MU 2/20/2000 00:50'!createAllIn: aCategoryName 	"DlAccessorMutatorCreator createAllIn: 'some category name'"	| amc clsNames cls |	clsNames := SystemOrganization listAtCategoryNamed: aCategoryName asSymbol.	clsNames do: 		[:each | 		cls := Smalltalk at: each asSymbol.		amc := DlAccessorMutatorCreator on: cls.		amc addAccessorMutators].! !!DlAccessorMutatorCreator class methodsFor: 'facade api' stamp: 'MU 2/20/2000 00:49'!createFor: aClass	"DlAccessorMutatorCreator createFor: aClass"	| amc |	amc := DlAccessorMutatorCreator on: aClass.	"amc isLazyInitializationSupport: true."	amc addAccessorMutators	! !!DlAccessorMutatorCreator class methodsFor: 'examples' stamp: 'MU 2/20/2000 00:49'!example1: aClass	"DlAccessorMutatorCreator example1: yourClass"	| amc |	amc := DlAccessorMutatorCreator on: aClass.	amc extraAccessorBlock: [:str :nm |		str nextPut:$".		str nextPutAll: 'Author: (your name). Generated: ', Date dateAndTimeNow printString.		str nextPut:$".		str cr; tab.	].	amc addAccessorMutators! !!DlAccessorMutatorCreator class methodsFor: 'examples' stamp: 'MU 2/20/2000 00:52'!example2: aClass	"DlAccessorMutatorCreator example2: aDlAnalyzable"	| amc |	amc := DlAccessorMutatorCreator on: aClass.	amc extraAccessorBlock: [:str :nm |		str nextPutAll: nm.		str nextPutAll: ' isNil ifTrue:[ self privResolve'.		str nextPut: (nm copy at: 1 ) asUppercase.		str nextPutAll: (nm copyFrom: 2 to: nm size). 		str nextPutAll: '].'.		str cr; tab.	].	amc addAccessorMutators.	amc addMethodsUsing: [:str :nm |		str nextPutAll: 'privResolve'.		str nextPut: (nm copy at: 1 ) asUppercase.		str nextPutAll: (nm copyFrom: 2 to: nm size). 		str cr; tab.	] category: #'private-resolving'.	! !Object subclass: #DlBatchFileouter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlBatchFileouter commentStamp: '<historical>' prior: 0!I fileout matched categories in batch mode.#creator[:masashi | ^umezawa] #version 0.1!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlBatchFileouter class	instanceVariableNames: ''!!DlBatchFileouter class methodsFor: 'utility' stamp: 'mu 12/16/2000 21:01'!fileOutCategoryMatches: aMatchExpression 	(SystemOrganization categories select: [:each | aMatchExpression match: each])		do: 			[:each | 			| fStr | 			fStr := FileStream fileNamed: each , '.st'.			Smalltalk organization fileOutCategory: each on: fStr.			fStr close]! !Object subclass: #DlDefaultInstanceFactory	instanceVariableNames: 'singletonDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlDefaultInstanceFactory commentStamp: '<historical>' prior: 0!I will create a default instance. (Not a singleton. You can still use "new" operation freely)When you need to clean up all default instances, please use "DlDefaultInstanceFactory initialize".#creator[:masashi | ^umezawa] #version 0.2!!DlDefaultInstanceFactory methodsFor: 'initialize-release' stamp: 'M.U 4/24/1999 00:17'!initialize	singletonDict := self defaultSingletonDictionary! !!DlDefaultInstanceFactory methodsFor: 'accessing' stamp: 'M.U 4/24/1999 00:18'!singletonDict	^singletonDict! !!DlDefaultInstanceFactory methodsFor: 'accessing' stamp: 'M.U 4/24/1999 00:18'!singletonDict: aValue	singletonDict := aValue! !!DlDefaultInstanceFactory methodsFor: 'actions' stamp: 'MU 3/15/2000 01:25'!clearInstanceOf: aClass	^self singletonDict removeKey: aClass name ifAbsent:[]! !!DlDefaultInstanceFactory methodsFor: 'actions' stamp: 'M.U 4/24/1999 00:21'!createInstanceOf: aClass	^self singletonDict at: aClass name ifAbsentPut:[ aClass new]! !!DlDefaultInstanceFactory methodsFor: 'actions' stamp: 'M.U 1/16/2000 01:43'!createInstanceOf: aClass named: anIDSymbol	^self singletonDict at: anIDSymbol ifAbsentPut:[ aClass new]! !!DlDefaultInstanceFactory methodsFor: 'factory' stamp: 'M.U 4/24/1999 00:17'!defaultSingletonDictionary	^IdentityDictionary new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDefaultInstanceFactory class	instanceVariableNames: 'defaultInstance'!!DlDefaultInstanceFactory class methodsFor: 'instance creation' stamp: 'MU 3/15/1999 00:08'!default	self defaultInstance isNil ifTrue: [ self prepareDefault].	^self defaultInstance! !!DlDefaultInstanceFactory class methodsFor: 'instance creation' stamp: 'MU 3/14/1999 01:27'!new	^super new initialize! !!DlDefaultInstanceFactory class methodsFor: 'class initialization' stamp: 'M.U 4/24/1999 01:00'!initialize	"DlDefaultInstanceFactory initialize"	self prepareDefault! !!DlDefaultInstanceFactory class methodsFor: 'private' stamp: 'M.U 4/24/1999 00:15'!defaultInstance	^defaultInstance! !!DlDefaultInstanceFactory class methodsFor: 'private' stamp: 'M.U 4/24/1999 00:15'!defaultInstance: aDlDefaultInstanceFactory	defaultInstance := aDlDefaultInstanceFactory! !!DlDefaultInstanceFactory class methodsFor: 'private' stamp: 'MU 3/15/1999 00:08'!prepareDefault	self defaultInstance: self new! !!DlDefaultInstanceFactory class methodsFor: 'examples' stamp: 'M.U 4/24/1999 00:25'!example1	| factory ord |	factory := DlDefaultInstanceFactory default.	ord := factory createInstanceOf: OrderedCollection.	ord add: 'a'.	ord := factory createInstanceOf: OrderedCollection.	ord add: 'b'.	ord inspect.! !Object subclass: #DlKey	instanceVariableNames: 'majorKey minorKey'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlKey commentStamp: '<historical>' prior: 0!I represent a key which bundles major and minor keys.#creator[:masashi | ^umezawa] #version 0.1!!DlKey methodsFor: 'printing' stamp: 'M.U. 9/25/1999 00:25'!printOn: aStream 	self majorKey isNil		ifTrue: [super printOn: aStream]		ifFalse: 			[aStream nextPutAll: self majorKey printString.			self minorKey isNil				ifFalse: 					[aStream nextPut: $:.					aStream nextPutAll: self minorKey printString]].! !!DlKey methodsFor: 'copying' stamp: 'M.U 10/17/1999 16:12'!copyWithMinorKey: aMinorKey	^self class named: self majorKey minorKey: aMinorKey ! !!DlKey methodsFor: 'comparing' stamp: 'M.U. 9/25/1999 00:19'!<= aDlKey 	^ self majorKey <= aDlKey majorKey and: [self minorKey <= aDlKey minorKey].! !!DlKey methodsFor: 'comparing' stamp: 'M.U. 9/25/1999 00:20'!= aDlKey 	^ self majorKey = aDlKey majorKey and: [self minorKey = aDlKey minorKey].! !!DlKey methodsFor: 'comparing' stamp: 'M.U 12/5/1999 18:56'!hash	^self majorKey hash bitXor: self minorKey hash! !!DlKey methodsFor: 'comparing' stamp: 'M.U. 10/3/1999 02:22'!majorEquals: aDlKey 	^ self majorKey = aDlKey majorKey.! !!DlKey methodsFor: 'accessing' stamp: 'M.U. 9/25/1999 00:17'!majorKey	^majorKey! !!DlKey methodsFor: 'accessing' stamp: 'M.U. 10/4/1999 00:08'!majorKey: aValue 		self privMajorKey: aValue.	self privManageCache! !!DlKey methodsFor: 'accessing' stamp: 'M.U. 9/25/1999 00:17'!minorKey	^minorKey! !!DlKey methodsFor: 'accessing' stamp: 'M.U. 10/4/1999 00:08'!minorKey: aValue	self privMinorKey: aValue.	self privManageCache	! !!DlKey methodsFor: 'private' stamp: 'M.U. 10/4/1999 00:07'!privMajorKey: aValue 		majorKey := aValue.	! !!DlKey methodsFor: 'private' stamp: 'M.U 12/5/1999 18:57'!privManageCache	| cache |	cache := self class findCache: self.	cache isNil		ifTrue: [self class registerCache: self]		ifFalse: ["self become: cache" "<-Squeak2.5 crashes!! - why? bug??" ^cache].! !!DlKey methodsFor: 'private' stamp: 'M.U. 10/4/1999 00:08'!privMinorKey: aValue 		minorKey := aValue.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlKey class	instanceVariableNames: 'cachedKeyDic'!!DlKey class methodsFor: 'class initialization' stamp: 'M.U. 9/25/1999 01:32'!initialize	"DlKey initialize"	"Flyweight dictionary initialization"	cachedKeyDic := nil	! !!DlKey class methodsFor: 'instance creation' stamp: 'M.U 1/1/2000 01:53'!named: aMajorKey 	| cached |	cached := self cachedKeyDic at: aMajorKey.	^ cached isNil		ifTrue: [cachedKeyDic at: aMajorKey put: (self new privMajorKey: aMajorKey)]		ifFalse: [cached].! !!DlKey class methodsFor: 'instance creation' stamp: 'M.U. 10/4/1999 00:23'!named: aMajorKey minorKey: aMinorKey 	| cached |	cached := self cachedKeyDic at: aMajorKey at: aMinorKey.	^ cached isNil		ifTrue: [cachedKeyDic				at: aMajorKey				at: aMinorKey				put: (self new privMajorKey: aMajorKey;					privMinorKey: aMinorKey)]		ifFalse: [cached].	! !!DlKey class methodsFor: 'accessing' stamp: 'M.U. 9/25/1999 01:29'!cachedKeyDic	cachedKeyDic isNil ifTrue: [cachedKeyDic := DlTwoKeyDictionary new].	^ cachedKeyDic.! !!DlKey class methodsFor: 'private' stamp: 'M.U. 10/4/1999 00:05'!findCache: aChangedDlKey 	| miKey |	miKey := aChangedDlKey minorKey.	^ miKey isNil		ifTrue: [self cachedKeyDic at: aChangedDlKey majorKey at: miKey]		ifFalse: [self cachedKeyDic at: aChangedDlKey majorKey]! !!DlKey class methodsFor: 'private' stamp: 'M.U. 10/4/1999 00:05'!registerCache: aChangedDlKey 	| miKey |	miKey := aChangedDlKey minorKey.	miKey isNil		ifTrue: [self cachedKeyDic				at: aChangedDlKey majorKey				at: miKey				put: aChangedDlKey]		ifFalse: [self cachedKeyDic at: aChangedDlKey majorKey put: aChangedDlKey].! !Object subclass: #DlPortableFilePath	instanceVariableNames: 'currentDir pathComponents drive isRelative isDirectoryPath'	classVariableNames: 'BadChars'	poolDictionaries: ''	category: 'Dandelion-utils'!!DlPortableFilePath commentStamp: 'mu 5/21/2003 11:52' prior: 0!I represent highly portable pathname.Please use me instead of plain hard-coded pathname.#creator[:masashi | ^umezawa] #version 0.4!!DlPortableFilePath methodsFor: 'initialize-release' stamp: 'MU 1/3/1999 17:09'!initialize	isRelative := true.	isDirectoryPath := false.! !!DlPortableFilePath methodsFor: 'actions' stamp: 'MU 1/3/1999 18:02'!beDirectoryPath	self isDirectoryPath: true! !!DlPortableFilePath methodsFor: 'actions' stamp: 'MU 1/3/1999 18:56'!chain: aDlPortableFilePath 	"argument aDlPortableFilePath's currentDirectory is just ignored"	self chainComponents: aDlPortableFilePath pathComponents.	! !!DlPortableFilePath methodsFor: 'actions' stamp: 'MU 1/4/1999 18:15'!chainComponents: aCollectionOfPathComponent	self pathComponents: (self privMakeNewPathComponents: aCollectionOfPathComponent)! !!DlPortableFilePath methodsFor: 'actions' stamp: 'MU 1/4/1999 19:23'!copyChain: aDlPortableFilePath 	"argument aDlPortableFilePath's currentDirectory is just ignored"	^self copyChainComponents: aDlPortableFilePath pathComponents.	! !!DlPortableFilePath methodsFor: 'actions' stamp: 'MU 1/4/1999 19:32'!copyChainComponents: aCollectionOfPathComponent	| inst arr |	inst := self copy.		arr := (self privMakeNewPathComponents: aCollectionOfPathComponent).	inst pathComponents: arr.	^inst.! !!DlPortableFilePath methodsFor: 'actions' stamp: 'M.U 5/25/1999 00:06'!forceExist	"supposing that currentDir already exists"	| dir sz comp |	dir := self currentDir.	(self isInDrivePlatform and: [dir pathName = ''])		ifTrue: [dir := FileDirectory on: self drive].	sz := self pathComponents size.	1 to: sz do: 		[:idx | 		comp := self pathComponents at: idx.		idx == sz			ifTrue: [self isDirectoryPath					ifTrue: [(dir includesKey: comp asString)							ifFalse: [dir createDirectory: comp]]					ifFalse: [(dir includesKey: comp asString)							ifFalse: [(dir newFileNamed: comp) close]]]			ifFalse: 				[(dir includesKey: comp asString)					ifFalse: [dir createDirectory: comp].				dir := dir directoryNamed: comp]].! !!DlPortableFilePath methodsFor: 'actions' stamp: 'MU 2/25/2002 18:35'!forceRemove	"Squeak misteriously does not provide directory-removing... So 	this implementation is incomplete"	"You should also aware that the execution is somethimes 	dangerous.. (if I am in root dir..)"	| dir lastIndex comps |	dir := self currentDir.	(self isInDrivePlatform			and: [dir pathName = ''])		ifTrue: [dir := FileDirectory on: self drive].	comps := self pathComponents.	lastIndex := self isDirectoryPath				ifTrue: [comps size]				ifFalse: [comps size - 1].	1		to: lastIndex		do: [:idx | dir := dir						directoryNamed: (comps at: idx)].	[self isDirectoryPath		ifTrue: [self privRemoveAllFilesIn: dir]		ifFalse: [dir				deleteFileNamed: comps last				ifAbsent: []]]		on: InvalidDirectoryError		do: [:ex | ex]! !!DlPortableFilePath methodsFor: 'actions' stamp: 'M.U 5/25/1999 00:06'!isExisting	| dir sz comp |	self isDirectoryPath not ifTrue: [^ FileStream isAFileNamed: self pathName].	dir := self currentDir.	(self isInDrivePlatform and: [dir pathName = ''])		ifTrue: [dir := FileDirectory on: self drive].	sz := self pathComponents size.	1 to: sz do: 		[:idx | 		comp := self pathComponents at: idx.		(dir includesKey: comp)			ifFalse: [^ false].		dir := dir directoryNamed: comp].	^ true! !!DlPortableFilePath methodsFor: 'actions' stamp: 'M.U 5/24/1999 23:36'!pathName	| str |	str := WriteStream with: self currentDir pathName.	(self isAbsolute and: [self isInDrivePlatform]) ifTrue: [str nextPutAll: self drive].	self pathComponents do: 		[:each | 		str nextPut: self pathSeparator.		str nextPutAll: each].	^ str contents! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 1/2/1999 23:24'!currentDir	currentDir isNil ifTrue: [ currentDir :=  self defaultCurrentDir].	^currentDir! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 1/2/1999 23:16'!currentDir: aValue	currentDir := aValue! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 1/3/1999 00:12'!drive	drive isNil ifTrue: [ drive :=  self defaultCurrentDrive].	^drive! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 1/3/1999 00:04'!drive: aValue	drive := aValue! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 1/3/1999 17:09'!isDirectoryPath: aValue	isDirectoryPath := aValue! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 1/3/1999 00:12'!isRelative: aValue	isRelative := aValue! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 1/2/1999 23:31'!pathComponents	pathComponents isNil ifTrue: [ pathComponents :=  Array new].	^pathComponents! !!DlPortableFilePath methodsFor: 'accessing' stamp: 'MU 5/20/2003 00:18'!pathComponents: aCollectionOfString		pathComponents := aCollectionOfString collect: [:each | self privFixName: each].! !!DlPortableFilePath methodsFor: 'factory' stamp: 'MU 1/2/1999 23:26'!defaultCurrentDir	^FileDirectory default	! !!DlPortableFilePath methodsFor: 'factory' stamp: 'MU 3/19/2000 20:40'!defaultCurrentDrive	^ self isInDrivePlatform		ifTrue: [FileDirectory default pathParts at: 1]		ifFalse: [''].! !!DlPortableFilePath methodsFor: 'testing' stamp: 'MU 1/3/1999 00:28'!isAbsolute	^isRelative not! !!DlPortableFilePath methodsFor: 'testing' stamp: 'MU 1/3/1999 17:08'!isDirectoryPath	^isDirectoryPath! !!DlPortableFilePath methodsFor: 'testing' stamp: 'MU 1/3/1999 00:27'!isInDos	^ FileDirectory default class == DosFileDirectory! !!DlPortableFilePath methodsFor: 'testing' stamp: 'M.U 5/24/1999 23:35'!isInDrivePlatform	^ self isInDos or: [self isInMac].! !!DlPortableFilePath methodsFor: 'testing' stamp: 'M.U 5/24/1999 23:34'!isInMac	^ FileDirectory default class == MacFileDirectory! !!DlPortableFilePath methodsFor: 'testing' stamp: 'MU 1/3/1999 00:12'!isRelative	^isRelative! !!DlPortableFilePath methodsFor: 'constants' stamp: 'MU 1/2/1999 23:29'!pathSeparator	^FileDirectory pathNameDelimiter! !!DlPortableFilePath methodsFor: 'private' stamp: 'MU 5/20/2003 00:26'!privFixName: aFilename	^self class fixName: aFilename! !!DlPortableFilePath methodsFor: 'private' stamp: 'MU 5/20/2003 00:17'!privMakeNewPathComponents: aCollectionOfPathComponent	"just a utility method"	| oComp aComp orgSize argSize newArr |	oComp :=  self isDirectoryPath 		ifTrue: [self pathComponents]		ifFalse: [self pathComponents copyFrom: 1 to: self pathComponents size - 1].	aComp := aCollectionOfPathComponent collect: [:each | self privFixName: each].	orgSize := oComp size.	argSize := aComp size.	newArr := Array new: orgSize + argSize.	1 to: orgSize do: [:idx | newArr at: idx put: (oComp at: idx)].	1 to: argSize do: [:idx | newArr at: idx + orgSize put: (aComp at: idx)].	^newArr! !!DlPortableFilePath methodsFor: 'private' stamp: 'mu 11/25/2004 01:25'!privRemoveAllFilesIn: aFileDirectory 	aFileDirectory fileNames do: [:fn | aFileDirectory deleteFileNamed: fn].	aFileDirectory directoryNames do: 		[:dn | 		self privRemoveAllFilesIn: (aFileDirectory directoryNamed: dn).		[aFileDirectory deleteDirectory: dn] on: Error do: [:ex | ex resignalAs: (DlCannotDelete target: dn)] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPortableFilePath class	instanceVariableNames: ''!!DlPortableFilePath class methodsFor: 'instance creation' stamp: 'MU 1/3/1999 00:09'!new	^super new initialize! !!DlPortableFilePath class methodsFor: 'instance creation' stamp: 'MU 1/3/1999 00:18'!rootWith: anArrayOfString	^ self new pathComponents: anArrayOfString;	 currentDir: FileDirectory root;	 isRelative: false.! !!DlPortableFilePath class methodsFor: 'instance creation' stamp: 'MU 1/3/1999 00:22'!rootWith: anArrayOfString drive: aCurrentDrive 	^ self new pathComponents: anArrayOfString;	 currentDir: FileDirectory root;	 drive: aCurrentDrive;	 isRelative: false! !!DlPortableFilePath class methodsFor: 'instance creation' stamp: 'MU 1/2/1999 23:22'!with: anArrayOfString	^self new pathComponents: anArrayOfString! !!DlPortableFilePath class methodsFor: 'instance creation' stamp: 'MU 1/2/1999 23:43'!with: anArrayOfString dir: aCurrentDirectory 	^ self new pathComponents: anArrayOfString;	 currentDir: aCurrentDirectory! !!DlPortableFilePath class methodsFor: 'examples' stamp: 'MU 1/3/1999 00:30'!example1	"DlPortableFilePath example1"	"print it"	(DlPortableFilePath with: #('dl' 'test.html')) pathName.	(DlPortableFilePath with: #('dl' 'test.html') dir: FileDirectory root) pathName.	(DlPortableFilePath rootWith: #('dl' 'test.html')) pathName.	(DlPortableFilePath rootWith: #('dl' 'test.html') drive: 'E:') pathName! !!DlPortableFilePath class methodsFor: 'examples' stamp: 'MU 1/4/1999 19:31'!example2	"DlPortableFilePath example2"	| path fName fName2 cPath |	path := (DlPortableFilePath with: #('dl' 'sub')) beDirectoryPath.	fName := (DlPortableFilePath with: #('test.html')).	fName2 := (DlPortableFilePath with: #('test2.html')).	cPath := path copyChain: fName.	Transcript cr; show: path pathName.	path chain: fName2.	Transcript cr; show: path pathName.	Transcript cr; show: cPath pathName.! !!DlPortableFilePath class methodsFor: 'examples' stamp: 'MU 4/18/1999 23:02'!example3	"DlPortableFilePath example3"	| path |	path := (DlPortableFilePath with: #('dl' 'sub' 'subsub')).	path beDirectoryPath.	path forceExist. 	path isExisting.			! !!DlPortableFilePath class methodsFor: 'examples' stamp: 'M.U 4/24/1999 19:08'!example4	"DlPortableFilePath example4"	| path |	path := (DlPortableFilePath with: #('dl' 'sub' )).	path beDirectoryPath.	path forceRemove. 	path isExisting. 			! !!DlPortableFilePath class methodsFor: 'class initialization' stamp: 'MU 5/20/2003 00:15'!initialize	BadChars := #( $: $< $> $| $/ $\ $? $* $") asSet.! !!DlPortableFilePath class methodsFor: 'utilities' stamp: 'mu 5/21/2003 11:51'!fixName: aFilename	| hasBadChars |	hasBadChars := aFilename includesAnyOf: BadChars.	hasBadChars ifFalse:[^aFilename].	^ aFilename collect:		[:char | (BadChars includes: char) 				ifTrue:[$#] 				ifFalse:[char]]! !Object subclass: #DlProperties	instanceVariableNames: 'dictionary'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlProperties commentStamp: '<historical>' prior: 0!I represent an appication specific name/value properties.My subclasses will have many default value provider methods. Or just use #at: #at:put like a normal dictionary.#creator[:masashi | ^umezawa] #version 0.5 M.U. 11/21/1999 22:12!!DlProperties methodsFor: 'initialize-release' stamp: 'MU 3/15/2000 01:03'!initialize	"do nothing"! !!DlProperties methodsFor: 'actions' stamp: 'MU 4/5/1999 00:07'!at: aKey	^self dictionary at: aKey ifAbsent:[]! !!DlProperties methodsFor: 'actions' stamp: 'M.U 12/30/1999 19:19'!at: aKey ifAbsent: aBlock 	^self dictionary at: aKey ifAbsent: aBlock ! !!DlProperties methodsFor: 'actions' stamp: 'MU 4/5/1999 00:24'!at: aKey ifAbsentPut: aBlock 	^self dictionary at: aKey ifAbsentPut: aBlock ! !!DlProperties methodsFor: 'actions' stamp: 'MU 4/5/1999 00:26'!at: aKey ifAbsentPutValue: aValue	^self dictionary at: aKey ifAbsent:[self dictionary at: aKey put: aValue]! !!DlProperties methodsFor: 'actions' stamp: 'M.U 1/1/2000 01:44'!at: aKey put: aValue 	| val |	val := aValue.	"for self class >> newFrom: aKeyValueArray "	aValue == #true ifTrue: [val := true].	aValue == #false ifTrue: [val := false].	aValue == #nil ifTrue: [val := nil].	^ self dictionary at: aKey put: val.! !!DlProperties methodsFor: 'actions' stamp: 'M.U 12/23/1999 19:41'!disable: aKey	^self at: aKey put: false! !!DlProperties methodsFor: 'actions' stamp: 'M.U 12/23/1999 19:41'!enable: aKey	^self at: aKey put: true! !!DlProperties methodsFor: 'actions' stamp: 'MU 4/5/1999 00:12'!includesKey: aKey 	^self dictionary includesKey: aKey ! !!DlProperties methodsFor: 'actions' stamp: 'M.U. 9/18/1999 18:34'!inherit: aDlProperties	aDlProperties keysAndValuesDo: [:key :value | self at: key ifAbsentPutValue: value].! !!DlProperties methodsFor: 'actions' stamp: 'MU 4/5/1999 00:13'!keys	^self dictionary keys! !!DlProperties methodsFor: 'actions' stamp: 'M.U. 9/18/1999 18:44'!overridden: aDlProperties	aDlProperties keysAndValuesDo: [:key :value | self at: key put: value].! !!DlProperties methodsFor: 'actions' stamp: 'MU 3/15/2000 01:08'!size	^self dictionary size! !!DlProperties methodsFor: 'converting' stamp: 'MU 3/15/2000 01:15'!asArray	| idx outArr |	idx := 0.	outArr := Array new: self size.	self dictionary associationsDo: [:assoc | outArr at: (idx := idx + 1) put: (Array with: assoc key with: assoc value)].	^outArr! !!DlProperties methodsFor: 'converting' stamp: 'MU 3/16/2000 01:04'!fromArray: aKeyValueArray 	"brace expressions are no longer used for Squeak 2.7+: M.U. 11/21/1999 22:15"	"instead use: #(#(key1 value1) #(key2 value2))"	| dict |	dict := self defaultDictionaryClass new: aKeyValueArray size.	aKeyValueArray do: [:each | dict at: each first put: each last].	self dictionary: dict.! !!DlProperties methodsFor: 'enumerating' stamp: 'M.U 5/22/1999 19:11'!do: aBlock	^self dictionary do: aBlock! !!DlProperties methodsFor: 'enumerating' stamp: 'MU 4/7/2000 01:36'!keysAndValuesDo: aBlock	^self dictionary keysAndValuesDo: aBlock.! !!DlProperties methodsFor: 'enumerating' stamp: 'M.U 5/22/1999 19:11'!keysDo: aBlock	^self dictionary keysDo: aBlock! !!DlProperties methodsFor: 'enumerating' stamp: 'MU 3/15/2000 01:07'!valuesDo: aBlock	^self dictionary valuesDo: aBlock! !!DlProperties methodsFor: 'accessing' stamp: 'MU 4/5/1999 00:06'!dictionary	dictionary isNil ifTrue: [ dictionary := self defaultDictionaryClass new].	^dictionary! !!DlProperties methodsFor: 'accessing' stamp: 'MU 4/5/1999 00:05'!dictionary: aValue	dictionary := aValue! !!DlProperties methodsFor: 'factory' stamp: 'MU 3/16/2000 01:05'!defaultDictionaryClass	^IdentityDictionary		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlProperties class	instanceVariableNames: ''!!DlProperties class methodsFor: 'instance creation' stamp: 'M.U 4/24/1999 01:06'!new	^super new initialize! !!DlProperties class methodsFor: 'instance creation' stamp: 'MU 3/16/2000 01:06'!newFrom: aKeyValueArray 	"brace expressions are no longer used for Squeak 2.7+: M.U. 11/21/1999 22:15"	"instead use: #(#(key1 value1) #(key2 value2))"	^self new fromArray: aKeyValueArray! !!DlProperties class methodsFor: 'examples' stamp: 'MU 3/16/2000 01:12'!example1	"DlProperties example1"	| props |	props := DlProperties newFrom: #(#(SqIsCool true) #(defaultPassword fooBar) #(greeting 'Hi!!')).	^props! !!DlProperties class methodsFor: 'examples' stamp: 'MU 3/16/2000 01:15'!example2	"DlProperties example2"	| props |	props := self example1.	props disable: #SqIsCool.	^props overridden: (DlProperties newFrom:#(#(SqueakVersion 2.7) #(greeting 'Hello!!'))).! !Object subclass: #DlPropertyObject	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlPropertyObject commentStamp: '<historical>' prior: 0!I am an abstract class using DlProperties.#creator[:masashi | ^umezawa] #version 0.1!!DlPropertyObject methodsFor: 'initialize-release' stamp: 'MU 3/15/2000 01:02'!initialize	"do nothing"! !!DlPropertyObject methodsFor: 'setting properties' stamp: 'M.U 12/30/1999 23:04'!setProperties: aDlProperties	self properties overridden: aDlProperties ! !!DlPropertyObject methodsFor: 'setting properties' stamp: 'MU 3/25/2000 18:31'!setPropertyArray: aKeyValueArray	"use: #(#(key1 value1) #(key2 value2))"	self setProperties: (self defaultProperties fromArray:aKeyValueArray)! !!DlPropertyObject methodsFor: 'factory' stamp: 'MU 3/15/2000 01:00'!defaultProperties	^self class defaultProperties! !!DlPropertyObject methodsFor: 'accessing' stamp: 'M.U 12/25/1999 00:32'!properties	properties isNil ifTrue:[ properties := self defaultProperties].	^properties! !!DlPropertyObject methodsFor: 'accessing' stamp: 'M.U 12/25/1999 00:29'!properties: aValue	properties := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPropertyObject class	instanceVariableNames: ''!!DlPropertyObject class methodsFor: 'instance creation' stamp: 'M.U 12/25/1999 00:31'!new	^super new initialize! !!DlPropertyObject class methodsFor: 'instance creation' stamp: 'M.U 1/1/2000 22:41'!on: aDlProperties	^self new properties: aDlProperties! !!DlPropertyObject class methodsFor: 'instance creation' stamp: 'M.U 1/1/2000 22:41'!with: aDlProperties	^self new setProperties: aDlProperties! !!DlPropertyObject class methodsFor: 'property' stamp: 'MU 3/16/2000 01:19'!defaultProperties	"override to provide default properties"	^DlProperties newFrom: self defaultPropertyArray! !!DlPropertyObject class methodsFor: 'property' stamp: 'MU 3/16/2000 01:19'!defaultPropertyArray	"override to provide default properties"	^#()! !Set subclass: #DlSortedSet	instanceVariableNames: 'needSort sortedElements'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlSortedSet commentStamp: '<historical>' prior: 0!Mostly I behave like a normal Set.In enumeration, I sort internal elements implicitly.	#creator[:masashi | ^umezawa] #version 0.1!!DlSortedSet methodsFor: 'initialize-release' stamp: 'MU 1/31/2000 01:29'!initialize	needSort := sortedElements := nil.	self init: 4! !!DlSortedSet methodsFor: 'finding' stamp: 'M.U 1/4/2000 01:59'!find: anObject	| index | 	index := self scanFor: anObject.	index = 0 ifTrue: [^nil].	^array at: index! !!DlSortedSet methodsFor: 'accessing' stamp: 'M.U 5/5/1999 01:36'!needSort	needSort isNil ifTrue: [ needSort := false].	^needSort! !!DlSortedSet methodsFor: 'accessing' stamp: 'M.U 5/5/1999 01:04'!needSort: aValue	needSort := aValue! !!DlSortedSet methodsFor: 'accessing' stamp: 'M.U 5/5/1999 01:36'!sortedElements	sortedElements isNil ifTrue: [ sortedElements := SortedCollection new].	^sortedElements! !!DlSortedSet methodsFor: 'accessing' stamp: 'M.U 5/5/1999 01:04'!sortedElements: aValue	sortedElements := aValue! !!DlSortedSet methodsFor: 'sequenceable collection mocking' stamp: 'mu 1/2/2001 00:54'!, aDlSortedSet	self prepareSortedElements.	aDlSortedSet prepareSortedElements.	^ self class newFrom: (self sortedElements , aDlSortedSet sortedElements)! !!DlSortedSet methodsFor: 'sequenceable collection mocking' stamp: 'MU 6/18/2000 23:52'!at: anIndex	self prepareSortedElements.	^ self sortedElements at: anIndex! !!DlSortedSet methodsFor: 'sequenceable collection mocking' stamp: 'M.U 12/21/1999 00:24'!first	self prepareSortedElements.	^ self sortedElements first! !!DlSortedSet methodsFor: 'adding' stamp: 'M.U 1/2/2000 18:23'!add: newObject	newObject isNil ifTrue:[^newObject].	self needSort: true.	^super add: newObject.! !!DlSortedSet methodsFor: 'adding' stamp: 'M.U 1/3/2000 00:58'!addAll: aCollection	aCollection isNil ifTrue:[^aCollection].	^super addAll: aCollection! !!DlSortedSet methodsFor: 'removing' stamp: 'M.U 5/5/1999 01:06'!remove: oldObject ifAbsent: aBlock	self needSort: true.	^super remove: oldObject ifAbsent: aBlock! !!DlSortedSet methodsFor: 'enumerating' stamp: 'M.U 5/5/1999 01:41'!collect: aBlock 	"Return a Set containing the result of evaluating aBlock	for each element of this set"	| newSet |	tally = 0 ifTrue: [^ DlSortedSet new: 2].	newSet _ DlSortedSet new: self size.	array do:		[:element |		element == nil ifFalse: [newSet add: (aBlock value: element)]].	^ newSet! !!DlSortedSet methodsFor: 'enumerating' stamp: 'M.U. 11/22/1999 23:20'!detect: aBlock ifNone: exceptionBlock 	"using Set version of #do: for performance reasons"	super do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value! !!DlSortedSet methodsFor: 'enumerating' stamp: 'M.U 5/5/1999 18:04'!do: aBlock 	self prepareSortedElements.	^ self sortedElements do: aBlock.! !!DlSortedSet methodsFor: 'enumerating' stamp: 'M.U 5/5/1999 18:04'!doWithIndex: aBlock	self prepareSortedElements.	^ self sortedElements doWithIndex: aBlock! !!DlSortedSet methodsFor: 'copying' stamp: 'M.U 5/5/1999 18:05'!copyFrom: start to: stop 	self prepareSortedElements.	^ self sortedElements copyFrom: start to: stop.! !!DlSortedSet methodsFor: 'private' stamp: 'M.U 5/5/1999 18:05'!prepareSortedElements	self needSort		ifTrue: 			[self sortedElements: ((array reject: [:each | each isNil]) asSortedCollection).			self needSort: false].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlSortedSet class	instanceVariableNames: ''!!DlSortedSet class methodsFor: 'examples' stamp: 'M.U 5/5/1999 01:24'!example1	| ss |	ss := DlSortedSet new.	ss add: 'aaa'.	ss add: 'aaa'.	ss add: 'bbb'.	ss add: 'ccc'.	^ss! !!DlSortedSet class methodsFor: 'examples' stamp: 'M.U 1/4/2000 02:21'!example2	| ss found |	ss := DlSortedSet new.	ss add: 'aaa'.	ss add: 'aaa'.	ss add: 'bbb'.	ss add: 'ccc'.	found := ss find: 'ccc'.	^found! !Object subclass: #DlTwoKeyDictionary	instanceVariableNames: 'majorDict majorMinorDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlTwoKeyDictionary commentStamp: '<historical>' prior: 0!I support stupid #at:at: protocol.Used for implementing DlKey.#creator[:masashi | ^umezawa] #version 0.1!!DlTwoKeyDictionary methodsFor: 'actions' stamp: 'M.U. 9/25/1999 01:10'!at: majorKey  	^self majorDict at: majorKey ifAbsent: [nil].! !!DlTwoKeyDictionary methodsFor: 'actions' stamp: 'M.U. 9/25/1999 01:10'!at: majorKey at: minorKey	| minorDict |	minorDict := self majorMinorDict at: majorKey ifAbsent: [self createDictionary].	^minorDict at: minorKey ifAbsent:[nil]! !!DlTwoKeyDictionary methodsFor: 'actions' stamp: 'M.U. 9/25/1999 01:24'!at: majorKey at: minorKey put: value	| minorDict |	minorDict := self majorMinorDict at: majorKey ifAbsentPut:[ self createDictionary].	^minorDict at: minorKey put: value! !!DlTwoKeyDictionary methodsFor: 'actions' stamp: 'M.U. 9/25/1999 01:12'!at: majorKey put: value	^self majorDict at: majorKey put: value.! !!DlTwoKeyDictionary methodsFor: 'accessing' stamp: 'M.U. 9/25/1999 01:08'!majorDict	majorDict isNil ifTrue: [ majorDict := self createDictionary ].	^majorDict! !!DlTwoKeyDictionary methodsFor: 'accessing' stamp: 'M.U. 9/25/1999 01:07'!majorDict: aValue	majorDict := aValue! !!DlTwoKeyDictionary methodsFor: 'accessing' stamp: 'M.U. 9/25/1999 01:08'!majorMinorDict	majorMinorDict isNil ifTrue: [ majorMinorDict := self createDictionary ].	^majorMinorDict! !!DlTwoKeyDictionary methodsFor: 'accessing' stamp: 'M.U. 9/25/1999 01:07'!majorMinorDict: aValue	majorMinorDict := aValue! !!DlTwoKeyDictionary methodsFor: 'factory' stamp: 'M.U. 9/25/1999 00:49'!createDictionary	^Dictionary new! !Stream subclass: #DlWrapStream	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlWrapStream commentStamp: '<historical>' prior: 0!I wrap a specific stream implemenation and delegates all requests.My suclasses are usable for  nested, incremental formatting (like Java stream).#annotation	instanceVariables: stream <Stream> #creator[:masashi | ^umezawa] #version 0.1 MU 1/2/1999 19:45!!DlWrapStream methodsFor: 'stream extended api' stamp: 'MU 1/3/1999 23:26'!close	(self stream respondsTo: #close) ifTrue:[ ^self stream close].	(self stream respondsTo: #endEntry) ifTrue:[ ^self stream endEntry]! !!DlWrapStream methodsFor: 'stream extended api' stamp: 'MU 1/3/1999 23:25'!endEntry	(self stream respondsTo: #endEntry) ifTrue:[ ^self stream endEntry]! !!DlWrapStream methodsFor: 'stream extended api' stamp: 'MU 1/2/1999 19:35'!flush	(self stream respondsTo: #flush) ifTrue:[ ^self stream flush]! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:06'!contents	"Answer all of the contents of the receiver."	^self stream contents! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:06'!next	"Answer the next object accessible by the receiver."	^self stream next! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:07'!next: anInteger 	"Answer the next anInteger number of objects accessible by the receiver."	^self stream next: anInteger! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:09'!next: anInteger put: anObject 	^self stream next: anInteger put: anObject! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:08'!nextMatchAll: aColl   ^self stream nextMatchAll: aColl! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:09'!nextMatchFor: anObject 	^self stream nextMatchFor: anObject! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:09'!nextPut: anObject 	^self stream nextPut: anObject! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:09'!nextPutAll: aCollection 	^self stream nextPutAll: aCollection! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:05'!stream	^stream! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 19:50'!stream: aStream	stream := aStream	! !!DlWrapStream methodsFor: 'accessing' stamp: 'MU 1/1/1999 20:10'!upToEnd	^self stream upToEnd! !!DlWrapStream methodsFor: 'testing' stamp: 'MU 1/1/1999 20:10'!atEnd	"Answer whether the receiver can access any more objects."	^self stream atEnd! !!DlWrapStream methodsFor: 'testing' stamp: 'M.U 12/25/1999 01:15'!isWrapStream	^true! !!DlWrapStream methodsFor: 'enumerating' stamp: 'MU 1/1/1999 20:11'!do: aBlock 	"Evaluate aBlock for each of the objects accessible by receiver."	^self stream do: aBlock! !!DlWrapStream methodsFor: 'printing' stamp: 'MU 1/1/1999 20:11'!print: anObject	^self stream print: anObject! !!DlWrapStream methodsFor: 'printing' stamp: 'MU 1/1/1999 20:12'!printHtml: anObject	^self stream printHtml: anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlWrapStream class	instanceVariableNames: 'wrapClass'!!DlWrapStream class methodsFor: 'instance creation' stamp: 'M.U 12/25/1999 02:46'!new	"default implementation uselessly wraps ReadWriteStream"	^self wrap: (self defaultWrapClass on: (String new: 64))! !!DlWrapStream class methodsFor: 'instance creation' stamp: 'M.U 12/25/1999 02:45'!on: aCollection	^self wrap: (self defaultWrapClass on: aCollection)! !!DlWrapStream class methodsFor: 'instance creation' stamp: 'M.U 12/25/1999 02:45'!with: aCollection	^self wrap: (self defaultWrapClass with: aCollection)! !!DlWrapStream class methodsFor: 'instance creation' stamp: 'MU 1/1/1999 20:04'!wrap: aStream	^self basicNew stream: aStream ! !!DlWrapStream class methodsFor: 'accessing' stamp: 'MU 3/1/1999 00:09'!wrapClass	wrapClass isNil ifTrue: [ wrapClass := self defaultWrapClass].	^wrapClass! !!DlWrapStream class methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:35'!wrapClass: aStreamClass	wrapClass := aStreamClass! !!DlWrapStream class methodsFor: 'factory' stamp: 'M.U 12/25/1999 02:45'!defaultWrapClass	^ReadWriteStream! !!DlWrapStream class methodsFor: 'class initialization' stamp: 'M.U 12/25/1999 02:49'!initialize	wrapClass := nil! !DlWrapStream subclass: #DlPositionableStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlPositionableStream commentStamp: '<historical>' prior: 0!Mostly I behave like a normal PositionalStream.I also support	- copyFrom:to:	- skipToAll: for convenience.#creator[:masashi | ^umezawa] #version 0.1!!DlPositionableStream methodsFor: 'extended api' stamp: 'MU 2/1/1999 00:00'!copyFrom: start to: stop		"Answer with a copy of the receivers collection from start to stop."	^self stream contents  copyFrom: start to: stop! !!DlPositionableStream methodsFor: 'extended api' stamp: 'MU 1/31/1999 23:22'!skipToAll: aCollection	| first length nonMatch |	(length := aCollection size) = 0 ifTrue: [^nil].	first := aCollection at: 1.	[self atEnd] whileFalse:		[self next = first ifTrue:			[			nonMatch := 2.			[nonMatch > length ifTrue:				[" Success.  Back up over the occurrence. "				self skip: length negated.				^self].			self atEnd ifTrue: [^nil].  " Not found. "			self next = (aCollection at: nonMatch)]				whileTrue: [nonMatch := nonMatch + 1].			" Didn't match, back up. "			self skip: 1 - nonMatch]].	" Not found. "	^nil! !!DlPositionableStream methodsFor: 'accessing' stamp: 'M.U 5/8/1999 15:28'!contentsOfEntireFile	"For non file streams"	^self contents! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:05'!last	^self stream last! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:03'!nextDelimited: terminator	^self stream nextDelimited: terminator! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:04'!nextInto: buffer 	^self stream nextInto: buffer ! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:04'!originalContents	^self stream originalContents! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:06'!peek	^self stream peek! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:06'!peekFor: anObject 	^self stream peekFor: anObject ! !!DlPositionableStream methodsFor: 'accessing' stamp: 'M.U 5/6/1999 01:41'!size	^self stream size! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:05'!upTo: anObject 	^self stream upTo: anObject! !!DlPositionableStream methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:05'!upToEnd	^self stream upToEnd! !!DlPositionableStream methodsFor: 'testing' stamp: 'MU 1/31/1999 23:08'!isEmpty	^self stream isEmpty! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:10'!match: subCollection	^self stream match: subCollection! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:10'!padTo: nBytes put: aCharacter 	^self stream padTo: nBytes put: aCharacter ! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:11'!padToNextLongPut: char 	^self stream padToNextLongPut: char ! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:11'!position	^self stream position! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:11'!position: anInteger 	^self stream position: anInteger! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:12'!reset	^self stream reset! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:12'!resetContents	^self stream resetContents! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:12'!setToEnd	^self stream setToEnd! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:13'!skip: anInteger 	^self stream skip: anInteger ! !!DlPositionableStream methodsFor: 'positioning' stamp: 'MU 1/31/1999 23:13'!skipTo: anObject 	^self stream skipTo: anObject ! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:15'!command: aString	^self command: aString! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:15'!copyMethodChunkFrom: aStream	^self copyMethodChunkFrom: aStream! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:15'!copyMethodWithPreamble: preamble from: aStream	^self copyMethodWithPreamble: preamble from: aStream! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:16'!copyPreamble: preamble from: aStream	^self stream copyPreamble: preamble from: aStream! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:16'!decodeStyle: runsObjData version: styleVersion	^self stream decodeStyle: runsObjData version: styleVersion! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:16'!header	^self stream header! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:16'!nextChunk	^self stream nextChunk! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:17'!nextChunkText	^self stream nextChunkText! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:17'!skipSeparators	^self stream skipSeparators! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:17'!skipSeparatorsAndPeekNext	^self stream skipSeparatorsAndPeekNext! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:17'!skipStyleChunk	^self stream skipStyleChunk! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:18'!trailer	^self stream trailer! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:18'!unCommand	^self stream unCommand! !!DlPositionableStream methodsFor: 'fileIn/Out' stamp: 'MU 1/31/1999 23:18'!verbatim: aString	^self stream verbatim: aString! !!DlPositionableStream methodsFor: 'converting' stamp: 'MU 1/31/1999 23:09'!asZLibStream	^self stream asZLibStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPositionableStream class	instanceVariableNames: ''!!DlPositionableStream class methodsFor: 'instance creation' stamp: 'MU 1/31/1999 23:33'!on: aCollection 	"Answer an instance of me, streaming over the elements of aCollection."	^(self wrap: (self wrapClass on: aCollection))! !!DlPositionableStream class methodsFor: 'instance creation' stamp: 'MU 1/31/1999 23:37'!on: aCollection from: firstIndex to: lastIndex 	"Answer an instance of me, streaming over the elements of aCollection 	starting with the element at firstIndex and ending with the one at 	lastIndex."	^(self wrap: (self wrapClass on: aCollection from: firstIndex to: lastIndex ))! !DlPositionableStream subclass: #DlHtmlWriteStream	instanceVariableNames: 'startTagNotClosed startTagClosedWithCr'	classVariableNames: 'CrChar'	poolDictionaries: ''	category: 'Dandelion-utils'!!DlHtmlWriteStream commentStamp: '<historical>' prior: 0!I will be used for html text writing (both on internal and external stream).Many html tags are supported (by brute force...).Please subclass me if you want more tag writing operaitions (or use generic tag: operation).#creator[:masashi | ^umezawa] #version 0.2!!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:28'!body	self nextStartTagCr: 'BODY' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/24/2000 00:35'!bodyBg: background bgcolor: bgcolor text: text link: link vlink: vlink alink: alink	self htmlPutAllCr: '<BODY background="', background, '" bgcolor="', bgcolor, '" text="', text, '" link="', link, '" vlink="', vlink, '" alink="', alink, '" >' .	! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/24/2000 00:35'!bodyBgcolor: bgcolor	self htmlPutAllCr: '<BODY bgcolor="', bgcolor, '" >' .	! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:21'!bodyEnd	self nextEndTagCr: 'BODY' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:04'!comment	self htmlPutAll: '<!!--' .	self startTagNotClosed: false! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'MU 1/2/1999 16:53'!commentEnd	self htmlPutAllCr: '-->' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'MU 4/12/1999 23:47'!commentWith: aHtmlString	self comment.	self nextPutAll: aHtmlString.	self commentEnd! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:30'!head	self nextStartTagCr: 'HEAD' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:24'!headEnd	self nextEndTagCr: 'HEAD' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:38'!html	self nextStartTagCr: 'HTML' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 02:03'!htmlEnd	self nextEndTagCr: 'HTML' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:36'!htmlPut: anObject 	"ignore character entity references - assuming input is well formatted html"	self startTagClose.	^super nextPut: anObject! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:36'!htmlPutAll: aHtmlString 	"ignore character entity references -assuming input is well formatted html"	self startTagClose.	^super nextPutAll: aHtmlString! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/24/2000 00:38'!htmlPutAllCr: aHtmlString 	"ignore character entity references -assuming input is well formatted html"	self startTagClose.	super nextPutAll: aHtmlString.	super nextPut: CrChar.! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 02:09'!metaHttpEquiv: metaDescription content: content	self htmlPutAllCr: '<META http-equiv="', metaDescription, '" context="', content, '">' .	! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'MU 1/4/1999 00:55'!metaName: name content: content	self htmlPutAllCr: '<META name="', name, '" content="', content, '">' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'MU 1/2/1999 18:34'!metaWith: metaDescription content: content	self htmlPutAllCr: '<META ', metaDescription, 'context="', content, '">' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:40'!title	self nextStartTagCr: 'TITLE' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'M.U 1/23/2000 01:26'!titleEnd	self nextPut: CrChar.	self nextEndTagCr: 'TITLE' ! !!DlHtmlWriteStream methodsFor: 'html writing' stamp: 'MU 4/12/1999 23:48'!titleWith: aHtmlString	self title.	self nextPutAll: aHtmlString.	self titleEnd.! !!DlHtmlWriteStream methodsFor: 'doc type' stamp: 'MU 1/4/1999 01:04'!declareHtml2	self htmlPutAllCr: '<!!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">' ! !!DlHtmlWriteStream methodsFor: 'doc type' stamp: 'MU 1/4/1999 01:04'!declareHtml3point2	self htmlPutAllCr: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">' ! !!DlHtmlWriteStream methodsFor: 'doc type' stamp: 'MU 1/2/1999 00:20'!declareHtml4	"default is html 4.0 transitional"	self declareHtml4t! !!DlHtmlWriteStream methodsFor: 'doc type' stamp: 'MU 1/4/1999 01:04'!declareHtml4f	self htmlPutAllCr: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN">' ! !!DlHtmlWriteStream methodsFor: 'doc type' stamp: 'MU 1/4/1999 01:04'!declareHtml4s	self htmlPutAllCr: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">' ! !!DlHtmlWriteStream methodsFor: 'doc type' stamp: 'MU 1/4/1999 01:04'!declareHtml4t	self htmlPutAllCr: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:27'!address	self nextStartTagCr: 'ADDRESS' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:20'!addressEnd	self nextEndTagCr: 'ADDRESS' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:28'!blockquote	self nextStartTagCr: 'BLOCKQUOTE' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:21'!blockquoteEnd	self nextEndTagCr: 'BLOCKQUOTE' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:28'!center	self nextStartTagCr: 'CENTER' 	! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:21'!centerEnd	self nextEndTagCr: 'CENTER' 	! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 02:20'!div	self nextStartTagCr: 'DIV' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/20/2000 19:57'!divClass: cls	self htmlPutAll: '<DIV class="'.	self nextPutAll: cls.	self htmlPutAllCr: '">'. 	! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 02:05'!divEnd	self nextEndTagCr: 'DIV' 	! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 02:25'!divId: anId	self htmlPutAll: '<DIV id="'.	self nextPutAll: anId.	self htmlPutAllCr: '">'. 	! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:29'!dl	self nextStartTagCr: 'DL' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:29'!dlEnd	self nextEndTagCr: 'DL' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:29'!h1	self nextStartTagCr: 'H1' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:23'!h1End	self nextPut: CrChar.	self nextEndTagCr: 'H1' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 4/12/1999 23:48'!h1With: aHtmlString	self h1.	self nextPutAll: aHtmlString.	self h1End.! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:30'!h2	self nextStartTagCr: 'H2' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:23'!h2End	self nextPut: CrChar.	self nextEndTagCr: 'H2' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 4/12/1999 23:48'!h2With: aHtmlString	self h2.	self nextPutAll: aHtmlString.	self h2End.! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:30'!h3	self nextStartTagCr: 'H3' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:24'!h3End	self nextPut: CrChar.	self nextEndTagCr: 'H3' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 4/12/1999 23:48'!h3With: aHtmlString	self h3.	self nextPutAll: aHtmlString.	self h3End.! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:30'!h4	self nextStartTagCr: 'H4' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:24'!h4End	self nextPut: CrChar.	self nextEndTagCr: 'H4' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 4/12/1999 23:48'!h4With: aHtmlString	self h4.	self nextPutAll: aHtmlString.	self h4End.! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:30'!h5	self nextStartTagCr: 'H5' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:24'!h5End	self nextPut: CrChar.	self nextEndTagCr: 'H5' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 4/12/1999 23:48'!h5With: aHtmlString	self h5.	self nextPutAll: aHtmlString.	self h5End.! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:30'!hr	self nextStartTagCr: 'HR' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 1/2/1999 16:56'!hrSize: sz	self htmlPutAllCr: '<HR SIZE="', sz , '">' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 1/2/1999 16:56'!hrSize: sz percent: p	self htmlPutAllCr: '<HR SIZE="', sz , '" WIDTH="', p, '">' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:38'!noframes	self nextStartTagCr: 'NOFRAMES' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:25'!noframesEnd	self nextEndTagCr: 'NOFRAMES' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:39'!ol	self nextStartTagCr: 'OL' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:25'!olEnd	self nextEndTagCr: 'OL' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:39'!p	self htmlPut: CrChar.	self nextStartTagCr: 'P' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:25'!pEnd	self nextEndTagCr: 'P' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:40'!pre	self nextStartTagCr: 'PRE' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:26'!preEnd	self nextEndTagCr: 'PRE' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:40'!table	self nextStartTagCr: 'TABLE' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'MU 1/4/1999 20:33'!tableBorder: border width: width cellspacing: cellspacing cellpadding: cellpadding	self htmlPutAllCr: '<TABLE border="', border, '" width="', width, '" cellspacing="', cellspacing, '" cellpadding="', cellpadding, '">' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:26'!tableEnd	self nextEndTagCr: 'TABLE' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:40'!ul	self nextStartTagCr: 'UL' ! !!DlHtmlWriteStream methodsFor: 'html block level elements' stamp: 'M.U 1/23/2000 01:27'!ulEnd	self nextEndTagCr: 'UL' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/24/2000 00:03'!anchor	self nextStartTag: 'A' 	! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 01:21'!anchorEnd	self nextEndTagCr: 'A' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/25/2000 01:35'!anchorName: name class: aClassString with: aString	self htmlPutAll: '<A name="'.	self nextPutAll: name.	self htmlPutAll: '" class="'.	self nextPutAll: aClassString.	self htmlPutAll: '">'.	self nextPutAll: aString.	self anchorEnd! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 4/12/1999 23:53'!anchorName: name with: aString	self htmlPutAll: '<A name="'.	self nextPutAll: name.	self htmlPutAll: '">'.	self nextPutAll: aString.	self anchorEnd! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/24/2000 00:02'!anchorRef: name class: aClassString target: target with: aString	self htmlPutAll: '<A href="'.	self nextPutAll: name.	self htmlPutAll: '" class="'.	self nextPutAll: aClassString.	self htmlPutAll: '" target="'.	self nextPutAll: target.	self htmlPutAll: '">'.	self nextPutAll: aString.	self anchorEnd! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/25/2000 01:36'!anchorRef: name class: aClassString with: aString	self htmlPutAll: '<A href="'.	self nextPutAll: name.	self htmlPutAll: '" class="'.	self nextPutAll: aClassString.	self htmlPutAll: '">'.	self nextPutAll: aString.	self anchorEnd! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 4/12/1999 23:54'!anchorRef: name target: target with: aString	self htmlPutAll: '<A href="'.	self nextPutAll: name.	self htmlPutAll: '" target="'.	self nextPutAll: target.	self htmlPutAll: '">'.	self nextPutAll: aString.	self anchorEnd! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 4/12/1999 23:52'!anchorRef: name with: aString	self htmlPutAll: '<A href="'.	self nextPutAll: name.	self htmlPutAll: '">'.	self nextPutAll: aString.	self anchorEnd! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:16'!big	self nextStartTag: 'BIG' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:16'!bold	self nextStartTag: 'B' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:14'!boldEnd	self nextEndTag: 'B' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 4/12/1999 23:54'!boldWith: aString	self bold.	self nextPutAll: aString.	self boldEnd.! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 01:28'!br	self nextStartTagCr: 'BR' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 01:28'!code	self nextStartTagCr: 'CODE' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 01:22'!codeEnd	self nextEndTagCr: 'CODE' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:17'!em	self nextStartTag: 'EM' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:14'!emEnd	self nextEndTag: 'EM' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 4/12/1999 23:54'!emWith: aString	self em.	self nextPutAll: aString.	self emEnd.! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 1/2/1999 17:13'!img: src alt: altText width: width height: height	self htmlPutAll: '<IMG src="' , src, '" alt="', altText, '" width="', width, '" height="', height, '" >' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:17'!italic	self nextStartTag: 'I' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:14'!italicEnd	self nextEndTag: 'I' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 4/12/1999 23:54'!italicWith: aString	self italic.	self nextPutAll: aString.	self italicEnd.! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:15'!small	self nextEndTag: 'SMALL' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/20/2000 20:02'!spanClass: cls	self htmlPutAll: '<SPAN class="'.	self nextPutAll: cls.	self htmlPutAllCr: '">'. ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:15'!spanEnd	self nextEndTag: 'SPAN' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'MU 1/2/1999 18:45'!spanId: id	self htmlPutAll: '<SPAN id="', id, '">' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:17'!sup	self nextStartTag: 'SUP' ! !!DlHtmlWriteStream methodsFor: 'html inline elements' stamp: 'M.U 1/23/2000 02:15'!supEnd	self nextEndTag: 'SUP' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:18'!caption	self nextStartTag: 'CAPTION' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 01:21'!captionEnd	self nextEndTagCr: 'CAPTION' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 4/12/1999 23:54'!captionWith: aString	self caption.	self nextPutAll: aString.	self captionEnd.! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:18'!dd	self nextStartTag: 'DD' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:26'!ddEnd	self nextEndTag: 'DD' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:19'!dt	self nextStartTag: 'DT' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:26'!dtEnd	self nextEndTag: 'DT' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:24'!frame: src name: name	self htmlPutAllCr: '<FRAME src="', src, '" name="', name, '">'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:28'!frameSetCols: cols	self htmlPutAllCr: '<FRAMESET cols="', cols, '">'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 23:53'!frameSetEnd	self nextEndTagCr: 'FRAMESET'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:28'!frameSetRows: rows	self htmlPutAllCr: '<FRAMESET rows="', rows, '">'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:27'!frameSetRows: rows cols: cols	self htmlPutAllCr: '<FRAMESET rows="', rows, '" cols="', cols, '">'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:19'!li	self nextStartTag: 'LI' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:27'!liEnd	self nextEndTag: 'LI' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:17'!link: linkType href: href	self htmlPutAllCr: '<LINK rel="', linkType, '" href="', href, '" >'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/24/2000 01:28'!linkStylesheet: href	self htmlPutAllCr: '<LINK rel="stylesheet" href="', href, '" >'.! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 2/21/1999 23:26'!refSpace	self htmlPutAll: '&nbsp;' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:19'!td	self nextStartTag: 'TD' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 17:51'!tdAlign: align	self htmlPutAll: '<TD align="', align, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 17:59'!tdAlign: align colspan: colspan	self htmlPutAll: '<TD align="', align, '" colspan="', colspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 17:52'!tdAlign: align rowspan: rowspan	self htmlPutAll: '<TD align="', align, '" rowspan="', rowspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 17:53'!tdAlign: align valign: valign	self htmlPutAll: '<TD align="', align, '" valign="', valign, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 17:54'!tdAlign: align valign: valign rowspan: rowspan	self htmlPutAll: '<TD align="', align, '" valign="', valign, '" rowspan="', rowspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:01'!tdAlign: align valign: valign rowspan: rowspan colspan: colspan 	self htmlPutAll: '<TD align="', align, '" valign="', valign, '" rowspan="', rowspan, '" colspan="', colspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 01:26'!tdEnd	self nextEndTagCr: 'TD' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 02:19'!th	self nextStartTag: 'TH' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:04'!thAlign: align	self htmlPutAll: '<TH align="', align, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:04'!thAlign: align colspan: colspan	self htmlPutAll: '<TH align="', align, '" colspan="', colspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:04'!thAlign: align rowspan: rowspan	self htmlPutAll: '<TH align="', align, '" rowspan="', rowspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/2/1999 18:05'!thAlign: align valign: valign	self htmlPutAll: '<TH align="', align, '" valign="', valign, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/4/1999 22:53'!thAlign: align valign: valign rowspan: rowspan	self htmlPutAll: '<TH align="', align, '" valign="', valign, '" rowspan="', rowspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/4/1999 22:53'!thAlign: align valign: valign rowspan: rowspan colspan: colspan 	self htmlPutAll: '<TH align="', align, '" valign="', valign, '" rowspan="', rowspan, '" colspan="', colspan, '">' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 01:26'!thEnd	self nextEndTagCr: 'TH' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 01:40'!tr	self nextStartTagCr: 'TR' ! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/4/1999 22:52'!trAlign: align	self htmlPutAllCr: '<TR align="', align, '">'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/4/1999 22:52'!trAlign: align valign: valign	self htmlPutAllCr: '<TR align="', align, '" valign="', valign, '">'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'MU 1/4/1999 22:52'!trBgcolor: bgcolor	self htmlPutAllCr: '<TR bgcolor="', bgcolor, '">'! !!DlHtmlWriteStream methodsFor: 'html other elements' stamp: 'M.U 1/23/2000 01:27'!trEnd	self nextEndTagCr: 'TR' ! !!DlHtmlWriteStream methodsFor: 'html attributes' stamp: 'MU 3/19/2000 01:56'!tagAlignCenter	self tagAttribName: 'align' value: 'center'. ! !!DlHtmlWriteStream methodsFor: 'html attributes' stamp: 'MU 3/19/2000 01:56'!tagAlignLeft	self tagAttribName: 'align' value: 'left'. ! !!DlHtmlWriteStream methodsFor: 'html attributes' stamp: 'MU 3/19/2000 01:56'!tagAlignRight 	self tagAttribName: 'align' value: 'right'. ! !!DlHtmlWriteStream methodsFor: 'html attributes' stamp: 'M.U 1/23/2000 01:59'!tagAttribName: nameString value: valueString 	self startTagNotClosed		ifTrue: 			[super nextPut: Character space.			super nextPutAll: nameString.		    super nextPutAll: '="'.			self startTagNotClosed: false.			self nextPutAll: valueString.			self startTagNotClosed: true.			super nextPutAll: '" '].! !!DlHtmlWriteStream methodsFor: 'html attributes' stamp: 'M.U 1/23/2000 02:07'!tagAttributes: anNameValueArray	anNameValueArray do:[ :each |		self tagAttribName: each first value: each last.	]! !!DlHtmlWriteStream methodsFor: 'html attributes' stamp: 'M.U 1/23/2000 01:59'!tagClass: aClassString 	self tagAttribName: 'class' value: aClassString ! !!DlHtmlWriteStream methodsFor: 'html attributes' stamp: 'M.U 1/23/2000 02:00'!tagId: anIdString 	self tagAttribName: 'id' value: anIdString ! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 00:27'!next: anInteger put: anObject 	anInteger timesRepeat: [self nextPut: anObject].	^anObject! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 01:37'!nextEndTag: aString	self startTagClose.	super nextPut: $<.	super nextPut: $/.	super nextPutAll: aString.	super nextPut: $>.	^aString! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 01:10'!nextEndTagCr: aString	self nextEndTag: aString.	super nextPut: CrChar.	^aString! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'MU 1/6/2001 17:13'!nextPut: anObject 	anObject isNil ifTrue: [^self].	self startTagClose.	anObject == $< ifTrue: [ super nextPutAll: '&lt;'. ^anObject ].	anObject == $> ifTrue: [ super nextPutAll: '&gt;'. ^anObject ].	anObject == $& ifTrue: [ super nextPutAll: '&amp;'. ^anObject ].	anObject == $" ifTrue: [ super nextPutAll: '&quot;'. ^anObject ].	^super nextPut: anObject! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 00:28'!nextPutAll: aCollection 	aCollection isNil ifTrue:[^self].	aCollection do: [:v | self nextPut: v].	^aCollection! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 01:37'!nextStartTag: aString	"for generic tag elements - notice: tag not closed"	self startTagClose.	super nextPut: $<.	super nextPutAll: aString.	self startTagOpen.	^aString! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 01:13'!nextStartTagCr: aString	"for generic tag elements - notice: tag not closed"	self nextStartTag: aString.	self startTagClosedWithCr: true.	^aString! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 00:28'!stStringPutAll: aCollection	| str | 	str := (aCollection isKindOf: String) ifTrue: [ aCollection ] ifFalse: [ aCollection printString ].	str class == Symbol ifTrue:[ self nextPut: $#].	str = '' ifTrue:[ self nextPut: $'; nextPut: $'].	str do: [:v | self nextPut: v].	^aCollection! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 01:37'!startTagClose	self startTagNotClosed		ifTrue: 			[super nextPut: $>.			self startTagNotClosed: false.			self startTagClosedWithCr				ifTrue: 					[super nextPut: CrChar.					self startTagClosedWithCr: false]].! !!DlHtmlWriteStream methodsFor: 'actions' stamp: 'M.U 1/23/2000 00:53'!startTagOpen	self startTagNotClosed: true.! !!DlHtmlWriteStream methodsFor: 'extended api' stamp: 'M.U 1/24/2000 01:01'!close	self startTagClose.	super close! !!DlHtmlWriteStream methodsFor: 'extended api' stamp: 'M.U 1/24/2000 01:29'!endEntry	self startTagClose.	super endEntry! !!DlHtmlWriteStream methodsFor: 'accessing' stamp: 'M.U 1/23/2000 01:12'!startTagClosedWithCr	startTagClosedWithCr isNil ifTrue:[startTagClosedWithCr := false].	^startTagClosedWithCr! !!DlHtmlWriteStream methodsFor: 'accessing' stamp: 'M.U 1/23/2000 01:12'!startTagClosedWithCr: aValue	startTagClosedWithCr := aValue! !!DlHtmlWriteStream methodsFor: 'accessing' stamp: 'M.U 1/23/2000 00:36'!startTagNotClosed	startTagNotClosed isNil ifTrue:[startTagNotClosed := false].	^startTagNotClosed! !!DlHtmlWriteStream methodsFor: 'accessing' stamp: 'M.U 1/23/2000 00:32'!startTagNotClosed: aValue	startTagNotClosed := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlHtmlWriteStream class	instanceVariableNames: ''!!DlHtmlWriteStream class methodsFor: 'class initialization' stamp: 'M.U 12/25/1999 02:50'!initialize	"DlHtmlWriteStream initialize"	super initialize.	CrChar := Character cr.! !!DlHtmlWriteStream class methodsFor: 'examples' stamp: 'M.U 1/24/2000 01:21'!example1	"DlHtmlWriteStream example1"	| stream |	Transcript cr; show: 'test start'; cr.	stream := DlHtmlWriteStream wrap: Transcript.	"stream := DlHtmlWriteStream wrap: (FileStream fileNamed: 	'dlTestHtml.html'). "	stream html.	stream head.	stream titleWith: 'DlHtmlWriteStream  test'.	stream headEnd.	stream body.	stream p.	stream center.	stream h1With: 'DlHtmlWriteStream example'.	stream centerEnd.	stream hr.	stream nextPutAll: 'This example shows <DLHtmlWriteStream>''s all instance methods'.	stream br.	stream ul.	DlHtmlWriteStream selectors asSortedCollection do: 		[:each | 		stream li.		stream htmlPutAllCr: each].	stream ulEnd.	stream hr.	stream bodyEnd.	stream htmlEnd.	stream close.	Transcript cr; show: 'test end'; cr! !!DlHtmlWriteStream class methodsFor: 'examples' stamp: 'MU 2/28/2000 00:23'!example2	"DlHtmlWriteStream example2"	| stream |	Transcript cr; show: 'test start'; cr.	stream := DlHtmlWriteStream wrap: Transcript.	"stream := DlHtmlWriteStream wrap: (FileStream fileNamed: 	'dlTestHtml.html'). "	stream nextStartTagCr: 'Foo'.	stream tagClass: 'add'.	stream tagId: 'id'.	stream nextPutAll: 'hogehoge'.	stream nextEndTagCr: 'Foo'.	stream title.	stream tagClass: 'myClass'.	stream nextPutAll: 'my title'.	stream titleEnd.	stream hr.	stream body.	stream p.	stream center.	stream hr.	stream h2With: #aaa.	stream tr.	stream tagClass: 'myClass'.	stream td.	stream nextPutAll: 'tr conts'.	stream tdEnd.	stream trEnd.	stream close.	Transcript cr; show: 'test end'; cr! !Object subclass: #DlXmlElement	instanceVariableNames: 'name value attribDict children parent isEmptyBody isPrintCData'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!!DlXmlElement commentStamp: '<historical>' prior: 0!I provide easy-to-use interfaces for XML writing.Currently, I am used for SMIX output.#creator[:masashi | ^umezawa] #version 0.1!!DlXmlElement methodsFor: 'initialize-release' stamp: 'MU 2/13/2000 01:43'!initialize	isEmptyBody := false! !!DlXmlElement methodsFor: 'actions' stamp: 'mu 11/17/2004 00:39'!addChild: aDlXMLElement	aDlXMLElement isNil ifTrue:[^nil].	aDlXMLElement parent: self.	^self children add: aDlXMLElement.	! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 6/10/2000 20:18'!beEmpty	self isEmptyBody: true	! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 3/7/2002 17:33'!createChildNamed: anElemName	| child |	child := self class named: anElemName.	self addChild: child.	^child! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 4/9/2000 23:59'!createParentNamed: anElemName	| pa |	pa := DlXmlElement named: anElemName.	pa addChild: self.	^pa! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 2/13/2000 02:18'!findChildNamed: anElemName	^self children detect: [:each | each name = anElemName] ifNone:[]! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 2/13/2000 02:21'!findChildrenNamed: anElemName	^self children select: [:each | each name = anElemName]! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 6/10/2000 20:14'!getAttributeNamed: aNameString	^self attribDict at: aNameString ifAbsent:[]! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 3/7/2002 14:34'!getAttributeNamed: aNameString ifAbsent: aBlock	^self attribDict at: aNameString ifAbsent:aBlock! !!DlXmlElement methodsFor: 'actions' stamp: 'mu 11/13/2004 00:06'!getAttributeNamed: aNameString ifAbsentPut: aBlock 	^ self attribDict		at: aNameString		ifAbsent: [self attribDict at: aNameString put: aBlock value asString]! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 6/10/2000 19:50'!putAttribute: aNameValueArray		self putAttributeNamed: aNameValueArray first asString value: aNameValueArray last asString! !!DlXmlElement methodsFor: 'actions' stamp: 'mu 11/13/2004 00:05'!putAttributeNamed: aNameString value: aValueString	self attribDict at: aNameString put: aValueString asString! !!DlXmlElement methodsFor: 'actions' stamp: 'MU 2/13/2000 02:26'!removeAttributeNamed: aNameString	self attribDict removeKey: aNameString! !!DlXmlElement methodsFor: 'actions' stamp: 'minami 4/17/2003 02:12'!removeChild: aDlXMLElement	^self children remove: aDlXMLElement ifAbsent:[nil].	! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 6/11/2000 01:06'!printOn: aStream	"super printOn: aStream" "for Debug"	self printXmlOn: aStream! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 3/7/2002 16:02'!printXmlContentsOn: aStream indent: level 	self isEmptyBody		ifFalse: 			[self value isNil ifFalse: [self privPrintXmlContentOn: aStream ].			children isNil ifFalse:["ugly - but for performance"			aStream cr.			self privPrintChildrenOn: aStream indent: level + 1.			level timesRepeat: [aStream space]]].! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 6/24/2000 23:45'!printXmlFooterOn: aStream 	self isXmlPrintable ifFalse: [^ self].	self isEmptyBody		ifFalse: 			[aStream nextPut: $<.			aStream nextPut: $/.			self writeName: self name on: aStream.			aStream nextPut: $>].! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 6/24/2000 23:45'!printXmlHeaderOn: aStream 	self isXmlPrintable ifFalse: [^ self].	self isEmptyBody		ifTrue: 			[aStream nextPut: $<.			self writeName: self name on: aStream.			self privPrintAttribsOn: aStream.			aStream nextPut: $/.			aStream nextPut: $>]		ifFalse: 			[aStream nextPut: $<.			self writeName: self name on: aStream.			self privPrintAttribsOn: aStream.			aStream nextPut: $>.].! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 4/7/2000 18:28'!printXmlOn: aStream 	self printXmlOn: aStream indent: 0! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 6/11/2000 01:59'!printXmlOn: aStream indent: level	self isXmlPrintable ifFalse: [^ self].	level timesRepeat:[aStream space.].	self printXmlHeaderOn: aStream.	self printXmlContentsOn: aStream indent: level.	self printXmlFooterOn: aStream.	aStream cr.	! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 3/7/2002 14:20'!privPrintAttribsOn: aStream	attribDict isNil ifTrue:[^self]. "ugly - but for performance"	self attribDict keysAndValuesDo:[ :k :v |		aStream nextPut: Character space.		self writeName: k on: aStream.		aStream nextPutAll: '="'.		self writeValue: v asString on: aStream.		aStream nextPut: $".	]! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 4/8/2000 19:55'!privPrintChildrenOn: aStream indent: level	children isNil ifTrue:[^self]. "ugly - but for performance"	(self privSortChildren: children) do:[ :each |		each printXmlOn: aStream indent: level.	]! !!DlXmlElement methodsFor: 'printing' stamp: 'mu 11/25/2004 00:56'!privPrintXmlContentOn: aStream 	self isPrintCData		ifTrue: [self writeValueAsCData: self value on: aStream]		ifFalse: [self writeValue: self value on: aStream]! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 4/8/2000 20:21'!privSortAttribs: aCollection	^aCollection! !!DlXmlElement methodsFor: 'printing' stamp: 'MU 4/8/2000 19:53'!privSortChildren: aCollectionOfDlXmlElement	"default do nothing"	^aCollectionOfDlXmlElement! !!DlXmlElement methodsFor: 'private' stamp: 'MU 6/11/2000 01:53'!isXmlPrintable	^self name notNil! !!DlXmlElement methodsFor: 'private' stamp: 'MU 3/6/2002 12:21'!writeName: aCharacterArray on: aStream 	"TODO: check illegal characters"	^ aStream nextPutAll: aCharacterArray! !!DlXmlElement methodsFor: 'private' stamp: 'MU 3/7/2002 14:19'!writeValue: aCharacterArray on: aStream 	^DlXmlUtil writeXmlText: aCharacterArray on: aStream! !!DlXmlElement methodsFor: 'private' stamp: 'mu 11/25/2004 00:50'!writeValueAsCData: aCharacterArray on: aStream 	^DlXmlUtil writeXmlCData: aCharacterArray on: aStream! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 02:00'!attribDict	attribDict isNil ifTrue:[ attribDict := Dictionary new].	^attribDict! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:29'!attribDict: aValue	attribDict := aValue! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 02:30'!children	children isNil ifTrue:[ children := OrderedCollection new].	^children! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 02:30'!children: aValue		children := aValue! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:56'!isEmptyBody	^isEmptyBody! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:56'!isEmptyBody: aValue	isEmptyBody := aValue! !!DlXmlElement methodsFor: 'accessing' stamp: 'mu 11/25/2004 01:16'!isPrintCData	isPrintCData isNil		ifTrue: [isPrintCData := parent isNil						ifTrue: [self class isPrintCData]						ifFalse: [parent isPrintCData]].	^ isPrintCData! !!DlXmlElement methodsFor: 'accessing' stamp: 'mu 11/25/2004 00:55'!isPrintCData: aValue	isPrintCData := aValue! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:29'!name	^name! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:29'!name: aValue	name := aValue! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:29'!parent	^parent! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:29'!parent: aValue	parent := aValue! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 2/13/2000 01:29'!value	^value! !!DlXmlElement methodsFor: 'accessing' stamp: 'MU 6/11/2000 02:10'!value: aValue	value := aValue asString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlXmlElement class	instanceVariableNames: 'isPrintCData'!!DlXmlElement class methodsFor: 'instance creation' stamp: 'MU 6/10/2000 20:19'!emptyNamed: anElemName	^(self named: anElemName) beEmpty! !!DlXmlElement class methodsFor: 'instance creation' stamp: 'MU 2/13/2000 02:14'!named: anElemName	^self new name: anElemName! !!DlXmlElement class methodsFor: 'instance creation' stamp: 'MU 2/13/2000 01:20'!new	^super new initialize! !!DlXmlElement class methodsFor: 'examples' stamp: 'MU 4/7/2000 18:27'!example1	| xmlElem |	xmlElem := DlXmlElement new.	xmlElem name: 'Foo'.	xmlElem value: 'bar'.	xmlElem printXmlOn: Transcript.	Transcript endEntry.! !!DlXmlElement class methodsFor: 'examples' stamp: 'mu 1/4/2001 00:24'!example2	| xmlElem child |	xmlElem := DlXmlElement new.	xmlElem name: 'Foo'.	child := xmlElem createChildNamed: 'Bar'.	child putAttribute: #(id 1).	child := xmlElem createChildNamed: 'Bar'.	child putAttribute: #(id 2).	xmlElem printXmlOn: Transcript.	Transcript endEntry.	child getAttributeNamed: 'id' ! !!DlXmlElement class methodsFor: 'examples' stamp: 'MU 6/10/2000 19:57'!example3	| xmlElem child |	xmlElem := DlXmlElement new.	xmlElem name: 'SMIX'.	child := xmlElem createChildNamed: 'interchangeUnit'.	child := child createChildNamed: 'classDefinition'.	child putAttribute: #(className Customer).	child := child createChildNamed: 'instVarNames'.	child value: 'name address tel'.	xmlElem printXmlOn: Transcript.	Transcript endEntry.! !!DlXmlElement class methodsFor: 'accessing' stamp: 'mu 11/25/2004 00:58'!isPrintCData	isPrintCData isNil ifTrue:[ isPrintCData := true ].	^isPrintCData! !!DlXmlElement class methodsFor: 'accessing' stamp: 'mu 11/25/2004 00:59'!isPrintCData: aBoolean	isPrintCData := aBoolean! !Object subclass: #DlXmlUtil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-utils'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlXmlUtil class	instanceVariableNames: 'convertCharDict'!!DlXmlUtil class methodsFor: 'class initialization' stamp: 'MU 3/7/2002 14:15'!initialize	"DlXmlUtil initialize"	self initConvertCharDict.		! !!DlXmlUtil class methodsFor: 'private-initialize' stamp: 'mu 11/25/2004 22:59'!initConvertCharDict	convertCharDict := Dictionary new.	0 to: 31 do: [:each | convertCharDict at: each put: '(', each asString, ' asCharacter)'].	32 to: 47 do: [:each | convertCharDict at: each put: '&#', each asString, ';'].	65534 to: 65535 do: [:each | convertCharDict at: each put: '(', each asString, ' asCharacter)'].	convertCharDict 		at: $& asciiValue put: '&amp;';		at: $< asciiValue put: '&lt;';		at: $> asciiValue put: '&gt;';		at: $' asciiValue put: '&apos;';		at: $" asciiValue put: '&quot;'.	convertCharDict 		removeKey: Character space asciiValue;		removeKey: Character tab asciiValue;		removeKey: Character cr asciiValue;		removeKey: Character lf asciiValue.	convertCharDict 		removeKey: $/ asciiValue;		removeKey: $- asciiValue;		removeKey: $. asciiValue.! !!DlXmlUtil class methodsFor: 'accessing' stamp: 'MU 3/7/2002 14:14'!convertCharDict	^convertCharDict! !!DlXmlUtil class methodsFor: 'accessing' stamp: 'MU 4/12/2002 11:14'!xmlDeclaration	^'<?xml version="1.0" encoding="utf-8"?>'.! !!DlXmlUtil class methodsFor: 'actions' stamp: 'MU 3/7/2002 14:14'!asXmlText: aString 	|  wStr |	wStr := WriteStream				on: (String new: aString size).	^(self writeXmlText: aString on: wStr) contents! !!DlXmlUtil class methodsFor: 'actions' stamp: 'MU 4/12/2002 11:14'!contentsWithXmlDeclaration: aString 	| wStr |	wStr := WriteStream				on: (String new: 1024).	wStr nextPutAll: self xmlDeclaration.	2		timesRepeat: [wStr nextPut: Character cr.			wStr nextPut: Character lf].	wStr nextPutAll: aString.	^ wStr contents! !!DlXmlUtil class methodsFor: 'actions' stamp: 'mu 11/25/2004 00:33'!writeXmlCData: aString on: aWriteStream 	aWriteStream nextPutAll: '<!![CDATA['.	aWriteStream nextPutAll: aString.	aWriteStream nextPutAll: ']]>'.	^ aWriteStream! !!DlXmlUtil class methodsFor: 'actions' stamp: 'MU 3/7/2002 14:14'!writeXmlText: aString on: aWriteStream	| cDict wStr |	cDict := self convertCharDict.	wStr := aWriteStream.	aString		do: [:eachChar | 			| val | 			val := eachChar asciiValue.			val >= 127				ifTrue: [wStr nextPutAll: '&#';						 nextPutAll: val asString;						 nextPut: $;]				ifFalse: [| conv | 					conv := cDict								at: val								ifAbsent: [].					conv isNil						ifTrue: [wStr nextPut: eachChar]						ifFalse: [wStr nextPutAll: conv]]].	^wStr! !DlDefaultInstanceFactory initialize!DlKey initialize!DlPortableFilePath initialize!DlWrapStream initialize!DlHtmlWriteStream initialize!DlXmlUtil initialize!