Object subclass: #DlAbstractProgressIndicator	instanceVariableNames: 'progressCounter'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-event'!!DlAbstractProgressIndicator commentStamp: '<historical>' prior: 0!I am an abstract progress indicator. I am an "event sink" and usable to display a progress on DlEvent framework.I receive DlEvents by #update: callback method, and just increment my counter.#creator[:masashi | ^umezawa] #version 0.3!!DlAbstractProgressIndicator methodsFor: 'initialize-release' stamp: 'MU 4/18/1999 19:29'!initialize	progressCounter := 0! !!DlAbstractProgressIndicator methodsFor: 'updating' stamp: 'MU 4/18/1999 19:29'!update: aDlEvent	progressCounter := progressCounter + 1.! !!DlAbstractProgressIndicator methodsFor: 'accessing' stamp: 'MU 4/18/1999 19:28'!progressCounter	^progressCounter! !!DlAbstractProgressIndicator methodsFor: 'accessing' stamp: 'MU 4/18/1999 19:28'!progressCounter: aValue	progressCounter := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAbstractProgressIndicator class	instanceVariableNames: ''!!DlAbstractProgressIndicator class methodsFor: 'instance creation' stamp: 'MU 4/18/1999 19:27'!new	^super new initialize! !Object subclass: #DlEvent	instanceVariableNames: 'name source description listeners transientInfo callbackDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-event'!!DlEvent commentStamp: '<historical>' prior: 0!I support both untyped(generic) and typed event.Generic event: A generic (#update: aDlEvent) callback message will be sent to listeners.  Listers can dispatch by checking visitted event name.Typed event: You can use specific callback message if you override #privHandledBy: anObject method.#creator[:masashi | ^umezawa] #version 0.3!!DlEvent methodsFor: 'initialize-release' stamp: 'MU 3/14/2000 03:00'!initialize	listeners := nil. 	! !!DlEvent methodsFor: 'initialize-release' stamp: 'M.U 5/3/1999 19:04'!release	self initialize! !!DlEvent methodsFor: 'actions' stamp: 'M.U 1/15/2000 01:19'!addListener: anObject 	^anObject isNil ifFalse: [self listeners add: anObject].! !!DlEvent methodsFor: 'actions' stamp: 'MU 2/20/2000 22:24'!addListener: anObject withSelector: selectorSymbol	self addListener: anObject.	self callbackDict at: anObject put: selectorSymbol.	^anObject! !!DlEvent methodsFor: 'actions' stamp: 'MU 3/12/2000 03:05'!fire: anEventSource	self fire: anEventSource withArgs: nil.	! !!DlEvent methodsFor: 'actions' stamp: 'MU 2/20/2000 22:32'!fire: anEventSource info: aTransientInfo	self transientInfo: aTransientInfo.	self fire: anEventSource.	self transientInfo: nil.! !!DlEvent methodsFor: 'actions' stamp: 'MU 2/20/2000 22:37'!fire: anEventSource withArgs: anArguments	self source: anEventSource.	self notifyAllListenersWithArgs: anArguments.		! !!DlEvent methodsFor: 'actions' stamp: 'MU 2/20/2000 22:40'!fire: anEventSource withArgs: anArguments info: aTransientInfo	self transientInfo: aTransientInfo.	self fire: anEventSource withArgs: anArguments.	self transientInfo: nil.		! !!DlEvent methodsFor: 'actions' stamp: 'MU 3/12/2000 03:10'!removeListener: anObject		^self listeners remove: anObject ifAbsent:[]! !!DlEvent methodsFor: 'private' stamp: 'MU 3/11/2000 18:34'!handledBy: anObject withArgs: anArguments 	| sele argArr |	sele := self callbackDict at: anObject ifAbsent: [^self privHandledBy: anObject].	argArr := anArguments isNil ifTrue:[Array new] ifFalse:[anArguments].	anObject perform: sele withArguments: argArr! !!DlEvent methodsFor: 'private' stamp: 'MU 2/20/2000 22:35'!notifyAllListeners	self notifyAllListenersWithArgs: nil! !!DlEvent methodsFor: 'private' stamp: 'MU 3/15/2000 00:50'!notifyAllListenersWithArgs: anArguments 	self class isDebugMode		ifTrue: [self listeners do: [:each | self handledBy: each withArgs: anArguments]]		ifFalse: [self listeners copy do: [:each | [self handledBy: each withArgs: anArguments. ]					on: MessageNotUnderstood do: [:ex | DlEventHandlingFailed new 					 orginalException: ex;					 failedListener: each;					 signal]]]! !!DlEvent methodsFor: 'private' stamp: 'MU 3/11/2000 23:03'!privHandledBy: anObject	"overrive if some event-type-specific-callback-message is preferred "	^anObject update: self.	! !!DlEvent methodsFor: 'accessing' stamp: 'MU 2/20/2000 22:20'!callbackDict	callbackDict isNil ifTrue: [callbackDict := self defaultCallbackDictionary].	^ callbackDict ! !!DlEvent methodsFor: 'accessing' stamp: 'MU 2/20/2000 22:20'!callbackDict: aValue	callbackDict := aValue! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 00:38'!description	^description! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 00:38'!description: aValue	description := aValue! !!DlEvent methodsFor: 'accessing' stamp: 'M.U 5/3/1999 19:09'!listeners	listeners isNil ifTrue: [listeners := self defaultListenersCollection].	^ listeners ! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 01:02'!listeners: aValue	listeners := aValue! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 01:57'!name	name isNil ifTrue: [ name := self class name].	^name! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 00:14'!name: aValue	name := aValue! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 00:14'!source	^source! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 00:14'!source: aValue	source := aValue! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 01:14'!transientInfo	^transientInfo! !!DlEvent methodsFor: 'accessing' stamp: 'MU 3/14/1999 01:14'!transientInfo: aValue	transientInfo := aValue! !!DlEvent methodsFor: 'factory' stamp: 'MU 2/20/2000 22:19'!defaultCallbackDictionary	^IdentityDictionary new! !!DlEvent methodsFor: 'factory' stamp: 'M.U 5/3/1999 19:08'!defaultListenersCollection	^Set new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlEvent class	instanceVariableNames: 'isDebugMode'!!DlEvent class methodsFor: 'class initialization' stamp: 'MU 2/20/2000 17:01'!initialize	"DlEvent initialize"	isDebugMode := false! !!DlEvent class methodsFor: 'accessing' stamp: 'MU 2/20/2000 17:00'!isDebugMode	^isDebugMode! !!DlEvent class methodsFor: 'accessing' stamp: 'MU 2/20/2000 17:00'!isDebugMode: aBoolean	isDebugMode := aBoolean! !!DlEvent class methodsFor: 'instance creation' stamp: 'MU 3/14/1999 23:51'!name: aSymbol	^self name: aSymbol description: ''! !!DlEvent class methodsFor: 'instance creation' stamp: 'MU 3/14/1999 23:50'!name: aSymbol description: aString	^self new name: aSymbol; description: aString! !!DlEvent class methodsFor: 'instance creation' stamp: 'MU 3/14/1999 00:13'!new	^super new initialize! !Object subclass: #DlEventServer	instanceVariableNames: 'eventDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-event'!!DlEventServer commentStamp: '<historical>' prior: 0!I am a mediator of DlEvents.You can register events by #at:put:.If an object listens to me, the object will receives these events.I also support #when:send:to: - VSE like event registration protocol.#creator[:masashi | ^umezawa] #version 0.3!!DlEventServer methodsFor: 'initialize-release' stamp: 'MU 3/14/2000 03:05'!initialize	eventDict := IdentityDictionary new. ! !!DlEventServer methodsFor: 'initialize-release' stamp: 'M.U 1/16/2000 01:06'!release	self eventDict valuesDo: [:ev | ev release].	eventDict := nil.! !!DlEventServer methodsFor: 'actions' stamp: 'M.U 1/16/2000 01:01'!addListener: anEventSink 	self eventDict valuesDo: [:ev | ev addListener: anEventSink].! !!DlEventServer methodsFor: 'actions' stamp: 'M.U 1/16/2000 00:51'!at: anEventSymbol	^self eventDict at: anEventSymbol ifAbsentPut:[ DlEvent name: anEventSymbol].	! !!DlEventServer methodsFor: 'actions' stamp: 'M.U 1/16/2000 01:08'!at: anEventSymbol fire: anEventSource	^(self at: anEventSymbol ) fire: anEventSource	! !!DlEventServer methodsFor: 'actions' stamp: 'M.U 1/16/2000 01:25'!at: anEventSymbol put: aDlEvent	^self eventDict at: anEventSymbol put: aDlEvent	! !!DlEventServer methodsFor: 'actions' stamp: 'M.U 1/16/2000 02:06'!registerEvents: aCollectionOfEventSymbol	aCollectionOfEventSymbol do: [:each | self at: each ].! !!DlEventServer methodsFor: 'actions' stamp: 'M.U 1/16/2000 02:08'!removeEvents: aCollectionOfEventSymbol	aCollectionOfEventSymbol do: [:each | self eventDict removeKey: each ifAbsent:[DlNoSuchEvent new eventSymbol: each]].! !!DlEventServer methodsFor: 'actions' stamp: 'MU 3/13/2000 02:55'!removeListener: anEventSink 	self eventDict valuesDo: [:ev | ev removeListener: anEventSink].! !!DlEventServer methodsFor: 'actions' stamp: 'M.U 1/16/2000 01:38'!strictAt: anEventSymbol 	^ self eventDict at: anEventSymbol ifAbsent: [DlNoSuchEvent new eventSymbol: anEventSymbol;		 signal].! !!DlEventServer methodsFor: 'actions-like vse' stamp: 'M.U 1/16/2000 01:23'!triggerEvent: anEventSymbol 	^self at: anEventSymbol fire: self	! !!DlEventServer methodsFor: 'actions-like vse' stamp: 'M.U 1/16/2000 01:23'!triggerEvent: anEventSymbol from: anEventSource	^self at: anEventSymbol fire: anEventSource	! !!DlEventServer methodsFor: 'actions-like vse' stamp: 'MU 2/20/2000 22:50'!triggerEvent: anEventSymbol withArgs: anArguments	^(self at: anEventSymbol ) fire: self withArgs: anArguments	! !!DlEventServer methodsFor: 'actions-like vse' stamp: 'MU 2/20/2000 22:47'!when: anEventSymbol send: callbackSelector to: aListener	^(self at: anEventSymbol) addListener: aListener withSelector: callbackSelector	! !!DlEventServer methodsFor: 'actions-like vse' stamp: 'M.U 1/16/2000 01:38'!when: anEventSymbol to: aListener	^(self at: anEventSymbol) addListener: aListener	! !!DlEventServer methodsFor: 'accessing' stamp: 'M.U 1/15/2000 02:20'!eventDict	eventDict isNil ifTrue:[ eventDict := self defaultEventDict].	^eventDict! !!DlEventServer methodsFor: 'factory' stamp: 'M.U 1/15/2000 02:20'!defaultEventDict	 ^IdentityDictionary new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlEventServer class	instanceVariableNames: 'defaultInstance'!!DlEventServer class methodsFor: 'instance creation' stamp: 'M.U 4/24/1999 00:36'!default	^ DlDefaultInstanceFactory default createInstanceOf: self! !!DlEventServer class methodsFor: 'instance creation' stamp: 'M.U 1/15/2000 02:03'!named: anIDString	^ DlDefaultInstanceFactory default createInstanceOf: self named: anIDString! !DlEventServer subclass: #DlDandelionEventServer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-event'!!DlDandelionEventServer commentStamp: '<historical>' prior: 0!I am an event server for Dandelion.I can generate Dandelion application specific event.generates:#(#analyzedEvent #resolvedEvent #outputEvent)#creator[:masashi | ^umezawa] #version 0.1!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDandelionEventServer class	instanceVariableNames: ''!!DlDandelionEventServer class methodsFor: 'instance creation' stamp: 'MU 3/14/2000 03:06'!default		^(super named: self name) registerEvents: #(#analyzedEvent #resolvedEvent #outputEvent).! !DlAbstractProgressIndicator subclass: #DlProgressBarIndicator	instanceVariableNames: 'progressBlock captionString barFrame savedArea savedPoint min max isRepeatMode'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-event'!!DlProgressBarIndicator commentStamp: '<historical>' prior: 0!I am a progress indicator showing plain progress bar. I am an "event sink" and usable to display a progress.Please see examples for details.	#creator[:masashi | ^umezawa] #version 0.5!!DlProgressBarIndicator methodsFor: 'initialize-release' stamp: 'MU 2/21/2000 00:09'!initialize	super initialize.	progressBlock := nil.	captionString := 'progress'.	min := 0.	max := 10.	isRepeatMode := true! !!DlProgressBarIndicator methodsFor: 'actions' stamp: 'MU 2/20/2000 23:50'!show: aCaption while: aBlock max: maxValue	self captionString: aCaption.	self max: maxValue.	self showWhile: aBlock	! !!DlProgressBarIndicator methodsFor: 'actions' stamp: 'MU 3/14/2000 02:05'!showWhile: aBlock 	| eventServer |	eventServer := DlEventServer new.	eventServer when: #end send: #forceClose to: self.	eventServer when: #progress to: self.	"[aBlock value: eventServer] on: Notification do:[:ex | Transcript cr; show: ex printString. eventServer triggerEvent: #progress]."	aBlock value: eventServer.	self displaySavedArea.	eventServer removeListener: self.	! !!DlProgressBarIndicator methodsFor: 'updating' stamp: 'MU 3/12/2000 03:19'!update: aDlEvent 	super update: aDlEvent.	self progressCounter <= 1 ifTrue: [self displayInitialProgressBar].	self displayProgress.	self progressCounter >= self max		ifTrue: 			[self displaySavedArea.			self isRepeatMode ifTrue: [self progressCounter: 0]].! !!DlProgressBarIndicator methodsFor: 'displaying' stamp: 'MU 3/13/2000 03:02'!displayInitialProgressBar	| curPoint captionText textFrame outerFrame delta |	curPoint := Sensor cursorPoint.	self barFrame: (curPoint - (75 @ 10) corner: curPoint + (75 @ 10)).	captionText := DisplayText text: self captionString asText allBold.	captionText foregroundColor: Color black backgroundColor: Color white.	textFrame := captionText boundingBox insetBy: -4.	textFrame := textFrame align: textFrame bottomCenter with: barFrame topCenter + (0 @ 2).	outerFrame := barFrame merge: textFrame.	delta := outerFrame amountToTranslateWithin: Display boundingBox.	textFrame := textFrame translateBy: delta.	outerFrame := outerFrame translateBy: delta.	self barFrame: (self barFrame translateBy: delta).	self savedArea: (Form fromDisplay: outerFrame).	self savedPoint: outerFrame topLeft.	Display fillBlack: barFrame;	 fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame;	 fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4 @ 4).! !!DlProgressBarIndicator methodsFor: 'displaying' stamp: 'MU 2/20/2000 16:21'!displayProgress	| range w |	range := max - min.	w := ((barFrame width - 4) asFloat * ((self progressCounter - min) asFloat / range min: 1.0)) asInteger.	Display fillGray: (barFrame topLeft + (2 @ 2) extent: w @ 16).! !!DlProgressBarIndicator methodsFor: 'displaying' stamp: 'MU 2/21/2000 00:08'!displaySavedArea	self savedArea isNil ifFalse: [self savedArea displayOn: Display at: self savedPoint].! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!barFrame	^barFrame! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!barFrame: aValue	barFrame := aValue! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 15:35'!captionString	^captionString! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 15:35'!captionString: aValue	captionString := aValue! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 22:53'!isRepeatMode	^isRepeatMode! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 22:53'!isRepeatMode: aValue	isRepeatMode := aValue! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!max	^max! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!max: aValue	max := aValue! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!min	^min! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!min: aValue	min := aValue! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!savedArea	^savedArea! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!savedArea: aValue	savedArea := aValue! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!savedPoint	^savedPoint! !!DlProgressBarIndicator methodsFor: 'accessing' stamp: 'MU 2/20/2000 16:23'!savedPoint: aValue	savedPoint := aValue! !!DlProgressBarIndicator methodsFor: 'private' stamp: 'MU 2/20/2000 23:05'!forceClose	self isRepeatMode: false.	self progressCounter: self max.	self displaySavedArea.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlProgressBarIndicator class	instanceVariableNames: ''!!DlProgressBarIndicator class methodsFor: 'inscance creation' stamp: 'MU 4/18/1999 19:08'!new	^super new initialize! !!DlProgressBarIndicator class methodsFor: 'facade' stamp: 'MU 2/20/2000 23:32'!show: aCaption while: aBlock 	^self new captionString: aCaption; showWhile: aBlock! !!DlProgressBarIndicator class methodsFor: 'facade' stamp: 'MU 2/20/2000 23:50'!show: aCaption while: aBlock max: maxValue	^self new show: aCaption while: aBlock max: maxValue! !!DlProgressBarIndicator class methodsFor: 'examples' stamp: 'MU 2/20/2000 23:33'!example1	"DlProgressBarIndicator example1"	DlProgressBarIndicator show: 'example1' while: [:esv | 		10 timesRepeat: 				[(Delay forMilliseconds: 500) wait.				esv triggerEvent: #progress]].! !!DlProgressBarIndicator class methodsFor: 'examples' stamp: 'MU 2/20/2000 23:34'!example2	"DlProgressBarIndicator example2"	DlProgressBarIndicator show: 'example2' while: [:esv | 		5 timesRepeat: 				[(Delay forMilliseconds: 500) wait.				esv triggerEvent: #progress].		esv triggerEvent: #end].! !DlAbstractProgressIndicator subclass: #DlTranscriptProgressIndicator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-event'!!DlTranscriptProgressIndicator commentStamp: '<historical>' prior: 0!I simply show progress on Transcritpt.#creator[:masashi | ^umezawa] #version 0.3!!DlTranscriptProgressIndicator methodsFor: 'updating' stamp: 'MU 2/20/2000 14:44'!update: aDlEvent	super update: aDlEvent.	Transcript cr; show: aDlEvent source printString.! !DlEvent initialize!