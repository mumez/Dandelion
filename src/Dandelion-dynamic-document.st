DlPropertyObject subclass: #DlDocument	instanceVariableNames: 'name title generator kind stream'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-dynamic-document'!!DlDocument commentStamp: '<historical>' prior: 0!I represent a generic document-like object.I can be written to a stream.#creator[:masashi | ^umezawa] #version 0.1 M.U 2/10/2000 20:51!!DlDocument methodsFor: 'initialize-release' stamp: 'M.U 12/25/1999 02:34'!initialize	super initialize.	name := ''.	title := ''.	generator := ''.! !!DlDocument methodsFor: 'actions' stamp: 'M.U 12/25/1999 00:53'!write	self writeOn: self stream! !!DlDocument methodsFor: 'actions' stamp: 'M.U 12/25/1999 00:54'!writeOn: aStream 	"default do nothing"! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 02:19'!generator	^generator! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 02:19'!generator: aValue	generator := aValue! !!DlDocument methodsFor: 'accessing' stamp: 'MU 2/20/2000 01:42'!kind	^kind! !!DlDocument methodsFor: 'accessing' stamp: 'MU 2/20/2000 01:42'!kind: aValue	kind := aValue! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 00:52'!name	^name! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 00:52'!name: aValue	name := aValue! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 02:27'!stream	stream isNil ifTrue:[ stream := self defaultStream].	^stream! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 00:52'!stream: aValue	stream := aValue! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 02:19'!title	^title! !!DlDocument methodsFor: 'accessing' stamp: 'M.U 12/25/1999 02:19'!title: aValue	title := aValue! !!DlDocument methodsFor: 'factory' stamp: 'M.U 12/25/1999 02:57'!defaultStream	^ReadWriteStream on: (String new: 1024)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDocument class	instanceVariableNames: ''!!DlDocument class methodsFor: 'instance creation' stamp: 'M.U 12/25/1999 00:53'!named: aDynamicDocumentName	^self new name: aDynamicDocumentName! !DlDocument subclass: #DlDynamicDocument	instanceVariableNames: 'contentsDict contentsNames isBuilt buildStream'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-dynamic-document'!!DlDynamicDocument commentStamp: 'mu 5/21/2003 11:53' prior: 0!I represent a document whose content will be updated dynamically.See 'actions' method category for details.#creator[:masashi | ^umezawa] #version 0.2!!DlDynamicDocument methodsFor: 'initialize-release' stamp: 'M.U 12/26/1999 00:26'!initForBuild	"default do nothing"! !!DlDynamicDocument methodsFor: 'initialize-release' stamp: 'M.U 12/26/1999 01:31'!initialize	super initialize.	name := self printString, self hash printString.	contentsNames := OrderedCollection new.	contentsDict := IdentityDictionary new.	isBuilt := false.	buildStream := nil.! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/24/1999 02:04'!add: aDynamicContent 	| key |	key := self keyOf: aDynamicContent.	self add: aDynamicContent named: key! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/24/1999 02:01'!add: aDynamicContent named: aString	| key | 	key := aString asSymbol.	self contentsNames add: key.	self contentsDict at: key put: aDynamicContent.	^aDynamicContent		! !!DlDynamicDocument methodsFor: 'actions' stamp: 'MU 2/6/2000 17:01'!at: aString	| key cont | 	key := aString asSymbol.	cont := self contentsDict at: key ifAbsent:[].	^cont		! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/26/1999 00:29'!buildAll	self isBuilt		ifFalse: 			[self initForBuild.			self buildContents.			self isBuilt: true].! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/26/1999 00:28'!buildContents	"default do nothing"! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/24/1999 02:04'!remove: aDynamicContent 	| key |	key := self keyOf: aDynamicContent.	self remove: aDynamicContent named: key! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/24/1999 02:01'!remove: aDynamicContent named: aString	| key | 	key := aString asSymbol.	self contentsNames remove: key ifAbsent:[].	self contentsDict removeKey: key ifAbsent:[].	^aDynamicContent		! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/25/1999 00:06'!update: aDynamicContent	| key |	key := self keyOf: aDynamicContent.	self update: aDynamicContent named: key		! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/25/1999 00:06'!update: aDynamicContent named: aString	| key | 	key := aString asSymbol.	self contentsDict at: key put: aDynamicContent.	^aDynamicContent		! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 12/24/1999 01:32'!value: aStream	self writeOn: aStream	! !!DlDynamicDocument methodsFor: 'actions' stamp: 'M.U 1/24/2000 01:25'!writeOn: aStream 	self isBuilt ifFalse:[ self buildAll].	self contentsNames do: 		[:eachName | | dynCont |		dynCont := self contentsDict at: eachName ifAbsent: [].		dynCont isNil			ifFalse: 				[(dynCont isKindOf: Stream) "Actually ReadStream or ReadWriteStream - We need interface IReadable"				ifTrue: [						dynCont reset.						[dynCont atEnd]							whileFalse:[aStream nextPut: dynCont next.].						] 					ifFalse: [(dynCont isKindOf: String)								ifTrue: ["Hey... Why isString is not defined in SQ 2.6!!"									aStream nextPutAll: dynCont] 								ifFalse:[(dynCont respondsTo: #value:) ifTrue: [dynCont value: aStream] "Also we need interface IValue"] 					]				] 		]! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/26/1999 01:31'!buildStream	^buildStream! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/26/1999 01:31'!buildStream: aValue	buildStream := aValue! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/24/1999 01:40'!contentsDict	^contentsDict! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/24/1999 01:40'!contentsDict: aValue	contentsDict := aValue! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/24/1999 01:40'!contentsNames	^contentsNames! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/24/1999 01:40'!contentsNames: aValue	contentsNames := aValue! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/26/1999 00:26'!isBuilt	^isBuilt! !!DlDynamicDocument methodsFor: 'accessing' stamp: 'M.U 12/26/1999 00:26'!isBuilt: aValue	isBuilt := aValue! !!DlDynamicDocument methodsFor: 'private' stamp: 'MU 5/20/2003 00:29'!fixName: aString	^DlPortableFilePath fixName: aString! !!DlDynamicDocument methodsFor: 'private' stamp: 'M.U 12/24/1999 02:03'!keyOf: aDynamicContent	^(aDynamicContent isKindOf: String)				ifTrue: [aDynamicContent truncateTo: 64]				ifFalse: [(aDynamicContent isKindOf: BlockContext)						ifTrue: [aDynamicContent printString , aDynamicContent hash printString]						ifFalse:[aDynamicContent name]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDynamicDocument class	instanceVariableNames: ''!!DlDynamicDocument class methodsFor: 'examples' stamp: 'M.U 12/24/1999 02:13'!example1	"DlDynamicDocument example2"	| doc |	Transcript cr.	doc := DlDynamicDocument new.	doc add: '<HEAD> This is a static header </HEAD>'.	doc add: [:stream | stream cr; nextPutAll: Date today printString; cr].	doc add:  '<FOOT> This is a static header </FOOT>'.	doc writeOn: Transcript.	Transcript endEntry.	^doc! !!DlDynamicDocument class methodsFor: 'examples' stamp: 'M.U 12/25/1999 02:16'!example2	"DlDynamicDocument example2"	| rootDoc dateDoc timeDoc |	Transcript cr.	rootDoc := DlDynamicDocument named: 'root'.	dateDoc := DlDynamicDocument named: 'date'.	dateDoc add: '<Date>'.	dateDoc add: [:str | str cr; nextPutAll: Date today printString; cr].	dateDoc add: '</Date>'.		timeDoc := DlDynamicDocument named: 'time'.	timeDoc add: '<Time>'.	timeDoc add: ((ReadWriteStream on: '') nextPutAll: Time now printString; cr).	timeDoc add: '</Time>'.	rootDoc add: '<HTML>'.	rootDoc add: dateDoc.	rootDoc add: timeDoc.	rootDoc add:  '</HTML>'.	rootDoc writeOn: Transcript.	Transcript endEntry.	^rootDoc	! !