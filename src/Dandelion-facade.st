Object subclass: #DlDandelionExample	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-facade'!!DlDandelionExample commentStamp: 'mu 11/24/2004 01:20' prior: 0!*-*- Dandelion -*-*version 0.5 beta3I am an example class for Dandelion.See class side for typical Dandelion usages.#creator[:masashi | ^umezawa] #version 0.5 11/24/2004 01:19!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDandelionExample class	instanceVariableNames: ''!!DlDandelionExample class methodsFor: 'examples-html' stamp: 'mu 1/3/2001 00:47'!example1	"DlDandelionExample example1"		DlDandelionSystem analyzeOutputMatches: 'Dandelion-o*'	! !!DlDandelionExample class methodsFor: 'examples-html' stamp: 'mu 1/2/2001 23:19'!example2	"DlDandelionExample example2"		DlDandelionSystem dialogAnalyzeOutput	! !!DlDandelionExample class methodsFor: 'examples-html' stamp: 'mu 1/3/2001 01:13'!example3	"DlDandelionExample example3"		| dandelion |	dandelion := DlDandelionSystem new.	dandelion setPropertyArray: #(#(outputWholeIndex false)).	dandelion analysisStrategy: DlSimpleAnalysisStrategy new.	dandelion analyze: #('Dandelion-utils').	dandelion output.! !!DlDandelionExample class methodsFor: 'examples-html' stamp: 'mu 1/2/2001 23:19'!example4	"DlDandelionExample example4"	"Analyze and output all elements in Morphic Kernel Library"	"using simple analyzer"	"without whole-index files"		| dandelion |	dandelion := DlDandelionSystem new.	dandelion setPropertyArray: 			#(#(#outputWholeIndex #false) #(#systemTitle 'Morphic') #(#outputRootDirectoryArray #('morphic')) ).	dandelion analysisStrategy: DlSimpleAnalysisStrategy new.	dandelion analyzeMatches: 'Morphic-K*'.	dandelion output! !!DlDandelionExample class methodsFor: 'examples-html' stamp: 'mu 1/2/2001 22:22'!example5	"DlDandelionExample example5"	"Analyze and output all elements in Baloon Library (without source body)"	"Please wait... This method is time & memory consuming ;->"	| dandelion |	dandelion := DlDandelionSystem new.	dandelion setPropertyArray: 		#(#(useDynamicVariableIntrospector false) #(analyzeMethodSource false) 		  #(systemTitle 'Balloon') #(outputRootDirectoryArray #('balloon'))).	dandelion analyzeMatches: 'Balloon-*'.	dandelion output.! !!DlDandelionExample class methodsFor: 'examples-html' stamp: 'mu 11/18/2004 00:27'!example6	"DlDandelionExample example6"	"Output current changeSet"	| dandelion |	dandelion := DlDandelionSystem new.	dandelion analyzeChangeSet: (ChangeSet current).	dandelion output.! !!DlDandelionExample class methodsFor: 'examples-html' stamp: 'mu 1/5/2001 00:13'!example7	"DlDandelionExample example7"	"using type inference work for variable type introspection"	"need to install TI for the correct result"	"see author's web site: http://typeinference.swiki.net"		| dandelion |	dandelion := DlDandelionSystem new.	dandelion setPropertyArray: #(#(outputWholeIndex false)).	dandelion setPropertyArray: #(#(#dynamicVariableIntrospectorClass #DlTiVariableIntrospector)).	dandelion analyze: #('Dandelion-analyzable').	dandelion output.! !!DlDandelionExample class methodsFor: 'examples-SMIX' stamp: 'mu 11/18/2004 00:27'!example8	"DlDandelionExample example8"	"Output current changeSet in SMIX"		| dandelion |	dandelion := DlDandelionSystem new.	dandelion analyzeChangeSet: (ChangeSet current).	dandelion outputSmix! !!DlDandelionExample class methodsFor: 'examples-SMIX' stamp: 'mu 11/25/2004 01:20'!example9	"DlDandelionExample example9"	"Output 'Collections-Text' category in SMIX (including Globals)"	"Doen not use CDATA section for source codes"		| dandelion |	dandelion := DlDandelionSystem new.	dandelion analyze: #('Collections-Text').	dandelion setPropertyArray: #(#(#printCData #false)).	dandelion outputSmix.! !!DlDandelionExample class methodsFor: 'examples-petal' stamp: 'MU 1/6/2001 18:11'!example10	"DlDandelionExample example10"	"Output 'Collections-' categories in Petal"		| dandelion |	dandelion := DlDandelionSystem new.	dandelion setPropertyArray: #(#(petalFilename 'Collections')).	dandelion analyzeMatches: 'Collections-*'.	dandelion outputPetal.! !!DlDandelionExample class methodsFor: 'examples-petal' stamp: 'mu 1/5/2001 02:42'!example11	"DlDandelionExample example11"	"Analyze 'Balloon3D-Alice*' and 'Baloon3D-Wonderland*' categories incrementally (divided by two phases)"	"useful if analysis target is huge"	"to be continued... see example12"	| dandelion |	dandelion := DlDandelionSystem current clearAnalysisStorage.	dandelion useCachedAnalysisStorage.	dandelion analyzeMatches: 'Balloon3D-Alice*' ! !!DlDandelionExample class methodsFor: 'examples-petal' stamp: 'MU 1/6/2001 20:29'!example12	"DlDandelionExample example12"	"Analyze 'Balloon3D-Alice*' and 'Baloon3D-Wonderland*' categories 	incrementally (divided by two phases)"	"useful if analysis target is huge"	"the latter part - see example11"	| dandelion |	dandelion := DlDandelionSystem current.	dandelion analyzeMatches: 'Balloon3D-Wonderland*'.		dandelion setPropertyArray: #(#(petalFilename 'Baloon')).	dandelion outputPetal.	"release on-memory analysis info"	dandelion clearAnalysisStorage.		"release this example specific garbage objects"	#(#WonderlandCameraMorph #WonderlandEditor #AliceTextOutputWindow ) 		do: [:eachClsName | (World submorphsSatisfying: [:each | each isKindOf: (Smalltalk at: eachClsName)])																do: [:each | each delete]].	Utilities emptyScrapsBook! !!DlDandelionExample class methodsFor: 'examples-petal' stamp: 'mu 11/18/2004 00:27'!example13	"DlDandelionExample example13"	"Analyze current changeSet and output as Petal"	| dandelion |	dandelion := DlDandelionSystem new.	dandelion analyzeChangeSet: (ChangeSet current) .	dandelion outputPetal.	! !!DlDandelionExample class methodsFor: 'examples-petal' stamp: 'MU 11/21/2001 11:56'!example14	"DlDandelionExample example14"	"Analyze kernel class categories and save them to the different files"	| categoryStrings |	categoryStrings := SystemOrganization categories select: [:each | 'Kernel-*' match: each].	categoryStrings do: 		[:eachCategory | 		| dandelion target props | 		dandelion := DlDandelionSystem new.		target := eachCategory.		props := DlProperties new.		props at: #outputWholeIndex put: false.		props at: #outputRootDirectoryArray put: (Array with: 'dandelionPetals' with: target).		props at: #systemTitle put: target.		props at: #petalFilename put: target.		props at: #unresolvedClassCategoryName put: 'unresolved ' , target.		dandelion setProperties: props.		"dandelion analysisStrategy: DlSimpleAnalysisStrategy new."		dandelion analyzeMatches: target.		dandelion outputPetal.		dandelion clearAnalysisStorage].	self inform: 'done!!'! !!DlDandelionExample class methodsFor: 'examples-XMI-UML' stamp: 'MU 4/12/2002 11:11'!example15	"DlDandelionExample example15"	"Output 'Kernel-Numbers' category in XMI UML"	| dandelion |	dandelion := DlDandelionSystem new.	dandelion analyze: #('Kernel-Numbers').	dandelion outputXmiUml.! !!DlDandelionExample class methodsFor: 'examples-XMI-UML' stamp: 'mu 11/18/2004 00:26'!example16	"DlDandelionExample example16"	"Analyze current changeSet and output as XMI UML"	"Output comment as documentation (for Argo derived UML case)"	| dandelion |	dandelion := DlDandelionSystem new.	dandelion analyzeChangeSet: (ChangeSet current).	dandelion setPropertyArray: #(#(commentAsDocument true)).	dandelion outputXmiUml.! !DlPropertyObject subclass: #DlDandelionSystem	instanceVariableNames: 'analysisStorage analysisStrategy indicator outputter'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-facade'!!DlDandelionSystem commentStamp: 'mu 11/24/2004 01:20' prior: 0!*-*- Dandelion -*-*version 0.5 beta3I represent a facade of Dandelion system.You can easily use Dandelion by calling my three basic methods.	-setPropertyArray: 	-analyze:	-outputAlso see DlDandelionExample which shows typical usages.#annotationinstance variables: analysisStrategy <DlAbstractAnalysisStrategy>	strategy for what/how elements are analyzed analysisStorage <DlAnalysisStorage>	a storage that can store analysis information outputter <DlAbstractOutputter>	 outputs analysis information in a specific format indicator <DlProgressBarIndicator>	handles analysis and output events and shows progress#creator[:masashi | ^umezawa] #version 0.5 11/24/2004 01:19#copyrightCopyright (C) 1999-2004  Masashi Umezawa	mail: umejava@mars.dti.ne.jp	www: http://www.mars.dti.ne.jp/~umejava/!!DlDandelionSystem methodsFor: 'initialize-release' stamp: 'MU 3/15/2000 00:01'!initialize	analysisStorage := analysisStrategy := indicator := outputter := nil.	! !!DlDandelionSystem methodsFor: 'analyzing' stamp: 'M.U 1/15/2000 00:30'!analyze: aCollectionOfClassCategoryString 	"obsolete"	self analyzeCategories: aCollectionOfClassCategoryString.! !!DlDandelionSystem methodsFor: 'analyzing' stamp: 'MU 1/6/2001 20:01'!analyzeCategories: aCollectionOfClassCategoryString 	| cats sz globalRoot |	aCollectionOfClassCategoryString isEmpty ifTrue:[self inform: 'no matched categories'. ^self].	self analysisStrategy setProperties: self properties.	[self shouldUseCachedAnalysisStorage ifFalse: [self analysisStorage initialize].	cats := OrderedCollection new.	aCollectionOfClassCategoryString do: [:each | cats add: (DlAnalyzableClassCategory named: each)].	cats do: [:each | self applySettingsTo: each].	self		progressIndicate: 			[:esv | 			cats do: [:each | each resolve].			esv triggerEvent: #end]		header: 'Now Resolving...'		totalNumber: 500.	sz := cats first analyzableSize.	self		progressIndicate: [:esv | cats do: [:each | each analyze]]		header: 'Now Analyzing...'		totalNumber: sz.	self shouldAnalyzeGlobals		ifTrue: 			[globalRoot := DlAnalyzableGlobalRoot named: #Smalltalk.			self applySettingsTo: globalRoot.			sz := globalRoot analyzableSize.			self				progressIndicate: [:esv | globalRoot analyze]				header: 'Analyzing Global...'				totalNumber: sz]]		on: Error do: 		[:ex | 		self class release.		ex pass]! !!DlDandelionSystem methodsFor: 'analyzing' stamp: 'MU 1/6/2001 20:01'!analyzeChangeSet: aChangeSet 	| cSet sz |	self analysisStrategy setProperties: self properties.	[self shouldUseCachedAnalysisStorage ifFalse: [self analysisStorage initialize].	cSet := DlAnalyzableChangeSet fromChangeSet: aChangeSet.	self applySettingsTo: cSet.	self		progressIndicate: 			[:esv | 			cSet resolve.			esv triggerEvent: #end]		header: 'Now Resolving...'		totalNumber: 500.	sz := cSet analyzableSize.	self		progressIndicate: [:esv | cSet analyze]		header: 'Now Analyzing...'		totalNumber: sz]		on: Error do: 		[:ex | 		self class release.		ex pass]! !!DlDandelionSystem methodsFor: 'analyzing' stamp: 'mu 12/31/2000 00:17'!analyzeMatches: classCategoryMatchExpression	| categoryStrings |	categoryStrings := SystemOrganization categories select: [:each | classCategoryMatchExpression match: each].	self analyzeCategories: categoryStrings.	! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'MU 6/17/2000 23:19'!output	self outputBy: self outputter from: self analysisStorage! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'MU 6/17/2000 23:18'!outputBy: aDlAbstractOutputter	self outputBy: aDlAbstractOutputter from: self analysisStorage! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'mu 11/20/2001 22:59'!outputBy: aDlAbstractOutputter from: aDlAnalysisStorage 	| sz |	aDlAbstractOutputter isNil ifTrue:[^self.].	[[self outputter: aDlAbstractOutputter.	self outputter setProperties: self properties.	self outputter analysisStorage: aDlAnalysisStorage.	self shouldOutputWholeIndex ifFalse: [self outputter actionSequence remove: #outputWholeIndex ifAbsent:[]].	sz := self outputter actionSequence size * 2 + 1.	self		progressIndicate: [:esv | self outputter output]		header: 'Now Outputting...'		totalNumber: sz]		ifCurtailed: 			[self outputter closeStream.			self class release] ] on: Error do: 		[:ex | 		self class release.		ex pass]! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'MU 6/17/2000 23:19'!outputFrom: aDlAnalysisStorage	self outputBy: self outputter from: aDlAnalysisStorage! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'MU 7/9/2000 00:52'!outputHtml	self outputter: nil.	self setPropertyArray: #(#(outputterClassName #DlHtmlOutputter)).	self output! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'mu 12/31/2000 23:36'!outputPetal	self outputter: nil.	self setPropertyArray: #(#(outputterClassName #DlPetalOutputter)).	self output! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'MU 7/9/2000 00:52'!outputSmix	self outputter: nil.	self setPropertyArray: #(#(outputterClassName #DlSmixClassCategoryOutputter)).	self output! !!DlDandelionSystem methodsFor: 'outputting' stamp: 'MU 3/19/2002 17:33'!outputXmiUml	self outputter: nil.	self setPropertyArray: #(#(outputterClassName #DlXmiUmlOutputter)).	self output! !!DlDandelionSystem methodsFor: 'actions' stamp: 'mu 12/16/2000 19:33'!analyzeOutputChangeSet: aChangeSet with: propertyArray		self setPropertyArray: propertyArray.	self analyzeChangeSet: aChangeSet.	self output.! !!DlDandelionSystem methodsFor: 'actions' stamp: 'mu 12/16/2000 19:32'!analyzeOutputMatches: classCategoryMatchExpression	self analyzeOutputMatches: classCategoryMatchExpression with: self defaultProperties asArray! !!DlDandelionSystem methodsFor: 'actions' stamp: 'mu 12/31/2000 00:18'!analyzeOutputMatches: classCategoryMatchExpression with: propertyArray	self setPropertyArray: propertyArray.	self analyzeMatches: classCategoryMatchExpression.	self output.! !!DlDandelionSystem methodsFor: 'actions' stamp: 'mu 1/5/2001 02:42'!clearAnalysisStorage	self analysisStorage initialize.! !!DlDandelionSystem methodsFor: 'actions' stamp: 'MU 3/15/2000 00:46'!clearCachedAnalysisStorage	self shouldUseCachedAnalysisStorage ifTrue:[ self analysisStorage initialize].! !!DlDandelionSystem methodsFor: 'actions' stamp: 'mu 1/2/2001 22:13'!useCachedAnalysisStorage	^self properties at: #useCachedAnalysisStorage put: true! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 5/6/1999 01:20'!analysisStorage	analysisStorage isNil ifTrue:[ analysisStorage := self defaultAnalysisStorage].	^analysisStorage! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 5/6/1999 01:20'!analysisStorage: aValue	analysisStorage := aValue! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 12/31/1999 23:54'!analysisStrategy	analysisStrategy isNil ifTrue: [self analysisStrategy: self defaultAnalysisStrategy].	^ analysisStrategy.! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 5/6/1999 01:19'!analysisStrategy: aValue	analysisStrategy := aValue! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'MU 3/15/2000 00:00'!eventServer		^self class eventServer! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 5/4/1999 23:08'!indicator	indicator isNil ifTrue:[ indicator := self defaultIndicator].	^indicator! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 5/4/1999 22:57'!indicator: aValue	indicator := aValue! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 5/4/1999 23:09'!outputter	outputter isNil ifTrue:[ outputter := self defaultOutputter].	^outputter! !!DlDandelionSystem methodsFor: 'accessing' stamp: 'M.U 5/4/1999 22:57'!outputter: aValue	outputter := aValue! !!DlDandelionSystem methodsFor: 'testing' stamp: 'M.U 1/1/2000 01:39'!shouldAnalyzeGlobals	^self properties at: #analyzeGlobals! !!DlDandelionSystem methodsFor: 'testing' stamp: 'M.U 1/1/2000 00:34'!shouldOutputWholeIndex	^self properties at: #outputWholeIndex! !!DlDandelionSystem methodsFor: 'testing' stamp: 'MU 3/15/2000 00:43'!shouldUseCachedAnalysisStorage	^self properties at: #useCachedAnalysisStorage! !!DlDandelionSystem methodsFor: 'private' stamp: 'MU 3/11/2000 19:05'!applySettingsTo: aDlAnalyzable	aDlAnalyzable analysisStrategy: self analysisStrategy.	aDlAnalyzable analysisStorage: self analysisStorage.! !!DlDandelionSystem methodsFor: 'private' stamp: 'MU 3/15/2000 00:47'!progressIndicate: aBlock header: headerString totalNumber: totalNumber 	Cursor execute		showWhile: [			[self resetIndicator.			self indicator captionString: headerString.			self indicator max: totalNumber.			self indicator showWhile: aBlock]				ensure: [self releaseIndicator]].! !!DlDandelionSystem methodsFor: 'private' stamp: 'MU 3/15/2000 00:03'!releaseIndicator	self eventServer removeListener: self indicator.! !!DlDandelionSystem methodsFor: 'private' stamp: 'MU 3/15/2000 00:24'!resetIndicator	self indicator initialize.	self eventServer addListener: self indicator.		! !!DlDandelionSystem methodsFor: 'private' stamp: 'MU 2/20/2000 15:04'!resetOutputter	self outputter: nil! !!DlDandelionSystem methodsFor: 'factory' stamp: 'MU 1/6/2001 20:16'!createOutputterFromProperty	| nm cls |	nm := self properties at: #outputterClassName.	cls := Smalltalk at: nm ifAbsent:[].	^cls notNil ifTrue:[ cls new] ifFalse:[nil]	! !!DlDandelionSystem methodsFor: 'factory' stamp: 'MU 2/20/2000 14:01'!defaultAnalysisStorage	^self class defaultAnalysisStorage! !!DlDandelionSystem methodsFor: 'factory' stamp: 'M.U 12/11/1999 16:10'!defaultAnalysisStrategy	^DlElaborateAnalysisStrategy new! !!DlDandelionSystem methodsFor: 'factory' stamp: 'M.U 5/5/1999 00:07'!defaultIndicator	^DlProgressBarIndicator new.! !!DlDandelionSystem methodsFor: 'factory' stamp: 'MU 1/6/2001 20:17'!defaultOutputter	| out |	out := self createOutputterFromProperty.	out isNil ifTrue:[^nil].	^self analysisStorage getAllChangeSets isEmpty		ifTrue:[out]		ifFalse: [out asChangeSetOutputter]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDandelionSystem class	instanceVariableNames: 'eventServer defaultAnalysisStorage current'!!DlDandelionSystem class methodsFor: 'class initialization' stamp: 'mu 1/2/2001 22:35'!initialize	"DlDandelionSystem initialize"	current := nil.	defaultAnalysisStorage := DlAnalysisStorage new.	eventServer := DlDandelionEventServer default.! !!DlDandelionSystem class methodsFor: 'class initialization' stamp: 'mu 1/3/2001 22:37'!obsolete	self purge! !!DlDandelionSystem class methodsFor: 'class initialization' stamp: 'mu 1/2/2001 22:35'!release	"DlDandelionSystem release"	self defaultAnalysisStorage: nil.	self eventServer isNil ifFalse: [self eventServer release].	self eventServer: nil.	self current initialize.	self initialize.! !!DlDandelionSystem class methodsFor: 'facade api' stamp: 'mu 12/16/2000 19:34'!analyzeOutputChangeSet: aChangeSet with: propertyArray		^self new analyzeOutputChangeSet: aChangeSet with: propertyArray! !!DlDandelionSystem class methodsFor: 'facade api' stamp: 'mu 12/16/2000 19:34'!analyzeOutputMatches: classCategoryMatchExpression	^self new analyzeOutputMatches: classCategoryMatchExpression! !!DlDandelionSystem class methodsFor: 'facade api' stamp: 'mu 12/16/2000 19:34'!analyzeOutputMatches: classCategoryMatchExpression with: propertyArray	^self new analyzeOutputMatches: classCategoryMatchExpression with: propertyArray! !!DlDandelionSystem class methodsFor: 'facade api' stamp: 'M.U 5/5/1999 19:00'!dialogAnalyzeOutput	| matchString |	matchString := FillInTheBlank request: 'enter the category name (wildcard is ok)' initialAnswer: 'Dandelion-*' .	self analyzeOutputMatches: matchString.	! !!DlDandelionSystem class methodsFor: 'facade api' stamp: 'MU 3/15/2000 01:58'!purge	"DlDandelionSystem purge"	Transcript clear.	self defaultAnalysisStorage initialize.	DlAbstractAnalyzable allSubInstances do: [:each | each initialize].	DlSortedSet allInstances do: [:each | each initialize].	self release.	Smalltalk garbageCollect! !!DlDandelionSystem class methodsFor: 'accessing' stamp: 'mu 1/2/2001 22:33'!current	current isNil ifTrue:[ current := self new].	^current! !!DlDandelionSystem class methodsFor: 'accessing' stamp: 'MU 3/15/2000 00:14'!defaultAnalysisStorage		^defaultAnalysisStorage! !!DlDandelionSystem class methodsFor: 'accessing' stamp: 'MU 2/20/2000 14:04'!defaultAnalysisStorage: aValue	defaultAnalysisStorage := aValue! !!DlDandelionSystem class methodsFor: 'accessing' stamp: 'MU 3/15/2000 00:20'!eventServer	^eventServer! !!DlDandelionSystem class methodsFor: 'accessing' stamp: 'MU 3/14/2000 23:56'!eventServer: aValue	eventServer := aValue! !!DlDandelionSystem class methodsFor: 'factory' stamp: 'MU 2/20/2000 14:52'!default	"DlDandelionSystem default"	^ DlDefaultInstanceFactory default createInstanceOf: self! !!DlDandelionSystem class methodsFor: 'version' stamp: 'mu 5/22/2003 11:42'!version	^'0.5 beta3'! !!DlDandelionSystem class methodsFor: 'property' stamp: 'MU 7/16/2000 23:21'!defaultProperties	"	* outputWholeIndex (true) - if true, outputter generates whole index files	* analyzeGlobals (true) - if true, global analyzables are analyzed	* useCachedAnalysisStorage (false) - if true, use cached analysisStorage - fast but infomation may be old 	* outputterClassName (#DlHtmlOutputter) - specify outputter class name	"	^super defaultProperties		at: #outputWholeIndex put: true;		at: #analyzeGlobals put: true;		at: #useCachedAnalysisStorage put: false;		at: #outputterClassName put: #DlHtmlOutputter;		yourself.! !DlDandelionSystem initialize!