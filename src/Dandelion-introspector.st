Object subclass: #DlAbstractIntrospector	instanceVariableNames: 'isIntrospected target'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlAbstractIntrospector commentStamp: '<historical>' prior: 0!I represent an abstract DlIntrospector. I can introspect useful information on Smalltalk objects. (usually by using reflection or some annotation parsing).By sending #introspect, an explicit introspection starts. Some introspectors may introspect implicitly.#creator[:masashi | ^umezawa] #version 0.3!!DlAbstractIntrospector methodsFor: 'initialize-release' stamp: 'MU 2/5/1999 23:23'!initialize	"default do nothing"	isIntrospected := false! !!DlAbstractIntrospector methodsFor: 'introspection' stamp: 'MU 2/5/1999 23:25'!introspect	self isIntrospected		ifFalse: 			[self privIntrospect.			self isIntrospected: true]! !!DlAbstractIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:23'!isIntrospected	^isIntrospected! !!DlAbstractIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:23'!isIntrospected: aValue	isIntrospected := aValue! !!DlAbstractIntrospector methodsFor: 'accessing' stamp: 'MU 12/4/2000 01:21'!target	^target! !!DlAbstractIntrospector methodsFor: 'accessing' stamp: 'M.U 5/1/1999 23:00'!target: aValue	target := aValue! !!DlAbstractIntrospector methodsFor: 'private' stamp: 'MU 2/5/1999 23:26'!privIntrospect	"default do nothing"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAbstractIntrospector class	instanceVariableNames: ''!!DlAbstractIntrospector class methodsFor: 'instance creation' stamp: 'MU 1/15/1999 23:04'!new	^super new initialize! !!DlAbstractIntrospector class methodsFor: 'instance creation' stamp: 'mu 1/2/2001 00:09'!on: aTarget	aTarget isNil ifTrue:[ DlInstanceCreationFailed new signal].	^self new target: aTarget ! !DlAbstractIntrospector subclass: #DlCategoryIntrospector	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlCategoryIntrospector commentStamp: '<historical>' prior: 0!I am abstract class for category introspector (class and method category).#creator[:masashi | ^umezawa] #version 0.1!!DlCategoryIntrospector methodsFor: 'accessing' stamp: 'M.U 10/30/1999 17:59'!name	^name! !!DlCategoryIntrospector methodsFor: 'accessing' stamp: 'M.U 10/30/1999 18:00'!name: aValue	name := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlCategoryIntrospector class	instanceVariableNames: ''!!DlCategoryIntrospector class methodsFor: 'instance creation' stamp: 'M.U 10/30/1999 18:00'!named: aCategoryNameSymbol	^self new name: aCategoryNameSymbol! !DlAbstractIntrospector subclass: #DlChangeSetIntrospector	instanceVariableNames: 'changedClassesDict changedMetaclassesDict renamedClassesDict removedClasses changedInstMethodDict changedClassMethodDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlChangeSetIntrospector commentStamp: '<historical>' prior: 0!I will introspect change set.See (actions-*) method categories for details.#creator[:masashi | ^umezawa] #version 0.1!!DlChangeSetIntrospector methodsFor: 'introspection' stamp: 'MU 7/1/2000 19:50'!privIntrospect	"Why the content of changeSet is *soooo* ugly? MU 6/6/2000 00:31 "	self getChangeRecords		keysAndValuesDo: 			[:clsName :clsRecord |			self privRegisterClassNamed: clsName record: clsRecord  ].	self getClassRemoves do: 		[:rmClsName | | cls |		cls := Smalltalk at: rmClsName asSymbol ifAbsent: [].		cls isNil ifTrue: [self privRegisterRemovedClassNamed: rmClsName]].	self getMethodChanges		keysAndValuesDo: 			[:mclsName :methodChangedDict |			self privIntrospectMethodChangedDict: methodChangedDict inClassNamed: mclsName].! !!DlChangeSetIntrospector methodsFor: 'introspection' stamp: 'MU 6/26/2000 00:16'!privIntrospectMethodChangedDict: methodChangedDict inClassNamed: clsName 	methodChangedDict		keysAndValuesDo: 			[:mName :mChanges | 			self privRegisterMethodNamed: mName changes: mChanges inClassNamed: clsName].! !!DlChangeSetIntrospector methodsFor: 'actions-raw' stamp: 'MU 6/6/2000 00:25'!getChangeRecords	"ChangeSet should supply method for accessing changeRecords"	"^self target changeRecords"	"This is brute force"	| idx | 	idx := self target class allInstVarNames indexOf: 'changeRecords'.	idx = 0 ifTrue:[^self defaultChangesDictionary].	^self target instVarAt: idx	! !!DlChangeSetIntrospector methodsFor: 'actions-raw' stamp: 'MU 3/12/2000 01:33'!getClassRemoves	^self target classRemoves.! !!DlChangeSetIntrospector methodsFor: 'actions-raw' stamp: 'M.U. 7/15/1999 23:45'!getMethodChanges		^self target methodChanges! !!DlChangeSetIntrospector methodsFor: 'actions-trimmed' stamp: 'M.U 12/5/1999 22:54'!getTrimmedClassChangesDict	self isIntrospected ifFalse: [ self introspect ].	^self changedClassesDict! !!DlChangeSetIntrospector methodsFor: 'actions-trimmed' stamp: 'M.U 12/5/1999 22:54'!getTrimmedClassMethodChangesDict	self isIntrospected ifFalse: [ self introspect ].	^self changedClassMethodDict! !!DlChangeSetIntrospector methodsFor: 'actions-trimmed' stamp: 'M.U 12/5/1999 22:54'!getTrimmedInstMethodChangesDict	self isIntrospected ifFalse: [ self introspect ].	^self changedInstMethodDict! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'MU 7/1/2000 19:18'!getAddedClassNames	self isIntrospected ifFalse: [ self introspect ].	^(self changedClassesDict select: [:v | (v includes: #add)] ) keys! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'MU 7/2/2000 23:36'!getAddedThenRemovedClassNames	self isIntrospected ifFalse: [ self introspect ].	^(self changedClassesDict select: [:v | (v includes: #addedThenRemoved)] ) keys! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'MU 7/2/2000 23:31'!getChangedClassNames	| chgInstSide addInstSide chgClsSide |	"I am rather dissapointed by the SQ2.8 still-dirty changeSet implementation... MU 7/2/2000 23:18"	self isIntrospected ifFalse: [ self introspect ].	chgInstSide := (self changedClassesDict select: [:v | (v includes: #change)] ) keys asSet.		addInstSide := (self changedClassesDict select: [:v | (v includes: #add)] ) keys asSet.	chgClsSide := ((self changedMetaclassesDict select: [:v | (v includes: #change)] ) keys collect:[:each | self privTrimClassName: each ] ) asSet.	chgClsSide removeAllFoundIn: addInstSide.		^chgInstSide addAll: chgClsSide; yourself	! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'M.U. 8/2/1999 23:53'!getCommentedClassNames	self isIntrospected ifFalse: [ self introspect ].	^(self changedClassesDict select: [:v | (v includes: #comment)] ) keys! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'MU 7/1/2000 19:28'!getOnlyChangedClassNames	self isIntrospected ifFalse: [ self introspect ].	"same as changedClassNames from SQ2.8"	"^(self changedClassesDict select: [:v | (v includes: #change) and: [(v includes: #add) not] ] ) keys"	^self getChangedClassNames! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'M.U. 8/2/1999 23:54'!getOrganizedClassNames	self isIntrospected ifFalse: [ self introspect ].	^(self changedClassesDict select: [:v | (v includes: #reorganize)] ) keys! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'M.U. 7/25/1999 22:45'!getRemovedClassNames	self isIntrospected ifFalse: [ self introspect ].	^self removedClasses! !!DlChangeSetIntrospector methodsFor: 'actions-classes' stamp: 'MU 7/1/2000 19:44'!getRenamedClassNames	self isIntrospected ifFalse: [ self introspect ].	^(self changedClassesDict select: [:v | (v includes: #rename)] ) keys! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:22'!getAddedClassMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetClassMethodNamesOf: aClassNameSymbol tagged: #add! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:24'!getAddedInstMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetInstMethodNamesOf: aClassNameSymbol tagged: #add! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:22'!getAddedThenRemovedClassMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetClassMethodNamesOf: aClassNameSymbol tagged: #addedThenRemoved! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:24'!getAddedThenRemovedInstMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetInstMethodNamesOf: aClassNameSymbol tagged: #addedThenRemoved! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:22'!getChangedClassMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetClassMethodNamesOf: aClassNameSymbol tagged: #change! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:23'!getChangedInstMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetInstMethodNamesOf: aClassNameSymbol tagged: #change! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U 12/11/1999 19:58'!getClassMethodNamesOf: aClassNameSymbol tagged: aMethodChangeTypeSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetClassMethodNamesOf: aClassNameSymbol tagged: aMethodChangeTypeSymbol! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U 12/11/1999 19:58'!getInstMethodNamesOf: aClassNameSymbol tagged: aMethodChangeTypeSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetInstMethodNamesOf: aClassNameSymbol tagged: aMethodChangeTypeSymbol! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:23'!getRemovedClassMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetClassMethodNamesOf: aClassNameSymbol tagged: #remove! !!DlChangeSetIntrospector methodsFor: 'actions-methods' stamp: 'M.U. 8/3/1999 00:23'!getRemovedInstMethodNamesOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self privGetInstMethodNamesOf: aClassNameSymbol tagged: #remove! !!DlChangeSetIntrospector methodsFor: 'actions-specific' stamp: 'MU 6/6/2000 00:59'!getClassMethodBodysOf: aSelectorSymbol inClassNamed: aClassNameSymbol	| ret cls recs |	self isIntrospected ifFalse: [ self introspect ].	ret := nil.	(self changedClassMethodDict includesKey: aClassNameSymbol)		ifFalse: [^ ret].	cls := Smalltalk at: aClassNameSymbol ifAbsent: [^ ret].	cls := cls class.	recs := cls changeRecordsAt: aSelectorSymbol.	recs isNil ifFalse: [ret := recs collect: [:each | each string]].	^ ret	! !!DlChangeSetIntrospector methodsFor: 'actions-specific' stamp: 'MU 6/6/2000 00:59'!getInstMethodBodysOf: aSelectorSymbol inClassNamed: aClassNameSymbol 	| ret cls recs |	self isIntrospected ifFalse: [self introspect].	ret := nil.	(self changedInstMethodDict includesKey: aClassNameSymbol)		ifFalse: [^ ret].	cls := Smalltalk at: aClassNameSymbol ifAbsent: [^ ret].	recs := cls changeRecordsAt: aSelectorSymbol.	recs isNil ifFalse: [ret := recs collect: [:each | each string]].	^ ret! !!DlChangeSetIntrospector methodsFor: 'actions-specific' stamp: 'M.U. 7/25/1999 22:58'!getOldClassNameOf: aClassNameSymbol	self isIntrospected ifFalse: [ self introspect ].	^self renamedClassesDict at: aClassNameSymbol ifAbsent:[nil]! !!DlChangeSetIntrospector methodsFor: 'actions-comments' stamp: 'M.U. 7/13/1999 00:15'!getPostscript	^self target postscriptString! !!DlChangeSetIntrospector methodsFor: 'actions-comments' stamp: 'M.U. 7/13/1999 00:14'!getPreamble	^self target preambleString! !!DlChangeSetIntrospector methodsFor: 'factory' stamp: 'M.U. 7/25/1999 00:04'!defaultChangesCollection	^SortedCollection new! !!DlChangeSetIntrospector methodsFor: 'factory' stamp: 'M.U. 7/24/1999 22:03'!defaultChangesDictionary	^IdentityDictionary new! !!DlChangeSetIntrospector methodsFor: 'private' stamp: 'M.U 1/13/2000 00:44'!privGetClassMethodNamesOf: aClassNameSymbol tagged: aSymbol	| opsDic |	opsDic := self changedClassMethodDict at: aClassNameSymbol ifAbsent:[^self defaultChangesCollection].	^(opsDic at: aSymbol ifAbsent:[self defaultChangesCollection]) ! !!DlChangeSetIntrospector methodsFor: 'private' stamp: 'M.U 1/13/2000 00:44'!privGetInstMethodNamesOf: aClassNameSymbol tagged: aSymbol	| opsDic |	opsDic := self changedInstMethodDict at: aClassNameSymbol ifAbsent:[^self defaultChangesCollection].	^(opsDic at: aSymbol ifAbsent:[self defaultChangesCollection]) ! !!DlChangeSetIntrospector methodsFor: 'private' stamp: 'MU 7/1/2000 20:04'!privTrimClassOldNameFrom: clsChanges 	| ret  match idx |	ret := ''.	match := 'oldName: '.	clsChanges do: [:each | idx := each findString: match startingAt: 0.				idx > 0 ifTrue: [^ ret := each copyFrom: match size + 1 to: each size]].	^ ret asSymbol! !!DlChangeSetIntrospector methodsFor: 'private-name processing' stamp: 'M.U. 7/21/1999 23:52'!privIsMetaClassName: aString	^ (aString findString: ' class' startingAt: 0) > 0! !!DlChangeSetIntrospector methodsFor: 'private-name processing' stamp: 'M.U. 7/24/1999 23:51'!privTrimClassName: aString 	"remove ' class'"	| idx |	idx := aString findString: ' class' startingAt: 0.	^ (idx > 0		ifTrue: [aString copyFrom: 1 to: idx - 1]		ifFalse: [aString]) asSymbol.! !!DlChangeSetIntrospector methodsFor: 'private-register' stamp: 'MU 7/2/2000 23:09'!privRegisterClassNamed: clsName changes: clsChanges 	(self privIsMetaClassName: clsName)		ifTrue: [self changedMetaclassesDict at: clsName ifAbsentPut: [clsChanges]]		ifFalse: 			[(clsChanges includes: #rename)				ifTrue: [self privRegisterRenamedClassNamed: clsName with: clsChanges].			self changedClassesDict at: clsName ifAbsentPut: [clsChanges]].! !!DlChangeSetIntrospector methodsFor: 'private-register' stamp: 'MU 7/2/2000 22:35'!privRegisterClassNamed: clsName record: clsRecord	self privRegisterClassNamed: clsName changes: clsRecord allChangeTypes copy! !!DlChangeSetIntrospector methodsFor: 'private-register' stamp: 'M.U 12/11/1999 18:51'!privRegisterMethodNamed: mName changes: mChangeType inClassNamed: clsName	| dic col |	dic := (self privIsMetaClassName: clsName)				ifTrue: [self changedClassMethodDict at: (self privTrimClassName: clsName)						ifAbsentPut: [self defaultChangesDictionary]]				ifFalse: [self changedInstMethodDict at: clsName ifAbsentPut: [self defaultChangesDictionary]].	col := dic at: mChangeType ifAbsentPut: [self defaultChangesCollection].	col add: mName! !!DlChangeSetIntrospector methodsFor: 'private-register' stamp: 'M.U. 8/2/1999 23:27'!privRegisterRemovedClassNamed: clsName	self removedClasses add: (self privTrimClassName: clsName)! !!DlChangeSetIntrospector methodsFor: 'private-register' stamp: 'MU 7/1/2000 20:03'!privRegisterRenamedClassNamed: clsName with: clsChanges	self renamedClassesDict at: clsName put: (self privTrimClassOldNameFrom: clsChanges).! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 7/24/1999 22:48'!changedClassMethodDict	changedClassMethodDict isNil ifTrue:[ changedClassMethodDict := self defaultChangesDictionary ].	^changedClassMethodDict! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 7/24/1999 22:50'!changedClassMethodDict: aValue	changedClassMethodDict := aValue! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 8/2/1999 22:46'!changedClassesDict	changedClassesDict isNil ifTrue:[ changedClassesDict := self defaultChangesDictionary ].	^changedClassesDict! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 8/2/1999 22:47'!changedClassesDict: aValue	changedClassesDict := aValue! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 7/24/1999 22:51'!changedInstMethodDict	changedInstMethodDict isNil ifTrue:[ changedInstMethodDict := self defaultChangesDictionary ].	^changedInstMethodDict! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 7/24/1999 22:52'!changedInstMethodDict: aValue	changedInstMethodDict := aValue! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'MU 7/2/2000 23:05'!changedMetaclassesDict	changedMetaclassesDict isNil ifTrue:[ changedMetaclassesDict := self defaultChangesDictionary ].	^changedMetaclassesDict! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'MU 7/2/2000 23:06'!changedMetaclassesDict: aValue	changedMetaclassesDict := aValue! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 7/24/1999 21:50'!removedClasses	removedClasses isNil ifTrue:[ removedClasses := self defaultChangesCollection ].	^removedClasses! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 7/24/1999 21:50'!removedClasses: aValue	removedClasses := aValue! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 8/2/1999 23:30'!renamedClassesDict	renamedClassesDict isNil ifTrue:[ renamedClassesDict := self defaultChangesDictionary ].	^renamedClassesDict! !!DlChangeSetIntrospector methodsFor: 'accessing' stamp: 'M.U. 8/2/1999 23:31'!renamedClassesDict: aValue	renamedClassesDict := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlChangeSetIntrospector class	instanceVariableNames: ''!!DlChangeSetIntrospector class methodsFor: 'instance creation' stamp: 'mu 1/2/2001 00:09'!on: aChangeSet	(aChangeSet isNil or: [(aChangeSet isKindOf: ChangeSet) not]) ifTrue:[DlInstanceCreationFailed new signal].	^self new target: aChangeSet ! !DlCategoryIntrospector subclass: #DlClassCategoryIntrospector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlClassCategoryIntrospector commentStamp: '<historical>' prior: 0!I will introspect class category.#creator[:masashi | ^umezawa] #version 0.1!!DlClassCategoryIntrospector methodsFor: 'actions' stamp: 'M.U 10/20/1999 00:27'!getClassNames	^self class systemOrganization listAtCategoryNamed: self name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlClassCategoryIntrospector class	instanceVariableNames: ''!!DlClassCategoryIntrospector class methodsFor: 'instance creation' stamp: 'MU 6/18/2000 00:20'!named: aClassCategoryName	| inst  |	inst := super new.	inst name: aClassCategoryName.	^inst! !!DlClassCategoryIntrospector class methodsFor: 'instance creation' stamp: 'M.U 10/30/1999 18:09'!on: aClass	| inst nm |	inst := super on: aClass.	nm := (DlClassIntrospector on: aClass) getClassCategoryName.	inst name: nm.	^inst! !!DlClassCategoryIntrospector class methodsFor: 'factory' stamp: 'M.U 10/20/1999 00:27'!systemOrganization	^SystemOrganization! !DlAbstractIntrospector subclass: #DlClassIntrospector	instanceVariableNames: 'selectorCache classSelectorCache methodIntrospector classMethodIntrospector'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlClassIntrospector commentStamp: '<historical>' prior: 0!I can introspect Smalltalk classes.Attributes, operations, hierarchy, category, and pools can be introspected.#creator[:masashi | ^umezawa] #version 0.3 M.U 5/5/1999 21:36!!DlClassIntrospector methodsFor: 'actions-attributes' stamp: 'mu 1/1/2001 01:17'!getClassInstVarNames	^ self target isNil		ifTrue: [#()]		ifFalse: [self target class instVarNames]! !!DlClassIntrospector methodsFor: 'actions-attributes' stamp: 'mu 1/1/2001 01:17'!getClassVarNames	^ self target isNil		ifTrue: [#()]		ifFalse: [(self target classVarNames collect: [:each | each asString]) asArray]! !!DlClassIntrospector methodsFor: 'actions-attributes' stamp: 'mu 1/1/2001 01:03'!getIndexableInstVarType	self target isNil ifTrue: [^ nil].	^ self target isVariable		ifTrue: [self target isBytes				ifTrue: [#byte]				ifFalse: [#object]]		ifFalse: [#none]! !!DlClassIntrospector methodsFor: 'actions-attributes' stamp: 'mu 1/1/2001 01:18'!getInstVarNames	^ self target isNil		ifTrue: [#()]		ifFalse: [self target instVarNames]! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'mu 1/1/2001 01:05'!getAllClassMethodNames	^ self target isNil		ifTrue: [#()]		ifFalse: [self target class allSelectors]! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'mu 1/1/2001 01:06'!getAllInstMethodNames	^ self target isNil		ifTrue: [#()]		ifFalse: [self target allSelectors]! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:44'!getClassMethodAllCommentsOf: aSelectorSymbol	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodAllComments! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:45'!getClassMethodBodyOf: aSelectorSymbol 	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodBody! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:45'!getClassMethodConcatCommentOf: aSelectorSymbol	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodConcatComment! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:46'!getClassMethodFirstCommentOf: aSelectorSymbol	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodFirstComment! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:46'!getClassMethodHeadOf: aSelectorSymbol 	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodHead! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:46'!getClassMethodNameArgsOf: aSelectorSymbol 	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodNameArgs! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'mu 1/1/2001 01:07'!getClassMethodNames	^ self target isNil		ifTrue: [#()]		ifFalse: [self target class selectors]! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'minami 7/26/2003 01:57'!getClassMethodNamesOf: aSelectorSymbol 	^ self target isNil		ifTrue: [#()]		ifFalse: [self target class organization listAtCategoryNamed: aSelectorSymbol asSymbol]! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:47'!getClassMethodNumArgsOf: aSelectorSymbol	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodNumArgs! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 01:48'!getClassMethodSourceOf: aSelectorSymbol 	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getMethodSource! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodAllCommentsOf: aSelectorSymbol	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodAllComments! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodBodyOf: aSelectorSymbol 	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodBody! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodConcatCommentOf: aSelectorSymbol	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodConcatComment! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodFirstCommentOf: aSelectorSymbol	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodFirstComment! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodHeadOf: aSelectorSymbol 	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodHead! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodNameArgsOf: aSelectorSymbol 	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodNameArgs! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'mu 1/1/2001 01:08'!getInstMethodNames	^ self target isNil		ifTrue: [#()]		ifFalse: [self target selectors]! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'mu 1/1/2001 01:08'!getInstMethodNamesOf: aMethodCategoryName 	^ self target isNil		ifTrue: [#()]		ifFalse: [self target organization listAtCategoryNamed: aMethodCategoryName asSymbol]! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodNumArgsOf: aSelectorSymbol	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodNumArgs! !!DlClassIntrospector methodsFor: 'actions-methods' stamp: 'MU 6/18/2000 02:02'!getInstMethodOf: aSelectorSymbol 	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodSource! !!DlClassIntrospector methodsFor: 'actions-methods'!getInstMethodSourceOf: aSelectorSymbol 	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getMethodSource! !!DlClassIntrospector methodsFor: 'actions-categories' stamp: 'M.U 10/25/1999 00:48'!getAllClassMethodCategoryNames	| cats |	cats := Set new.	cats addAll: self getClassMethodCategoryNames.	self getAllSuperclasses do:[ :each | cats addAll: ( self class on: each ) getClassMethodCategoryNames].	^cats		! !!DlClassIntrospector methodsFor: 'actions-categories' stamp: 'M.U 10/25/1999 00:49'!getAllInstMethodCategoryNames	| cats |	cats := Set new.	cats addAll: self getInstMethodCategories.	self getAllSuperclasses do:[ :each | cats addAll: ( self class on: each ) getInstMethodCategoryNames].	^cats		! !!DlClassIntrospector methodsFor: 'actions-categories' stamp: 'M.U 10/24/1999 23:31'!getClassCategoryName	^SystemOrganization categoryOfElement: self target name asSymbol! !!DlClassIntrospector methodsFor: 'actions-categories' stamp: 'MU 6/18/2000 02:19'!getClassMethodCategoryNameOf: aSelectorSymbol	| mits |	mits := self classMethodIntrospectorOf: aSelectorSymbol.	^mits getCategoryName	! !!DlClassIntrospector methodsFor: 'actions-categories' stamp: 'mu 1/1/2001 01:20'!getClassMethodCategoryNames	^ self target isNil		ifTrue: [#( )]		ifFalse: [self target class organization categories]! !!DlClassIntrospector methodsFor: 'actions-categories' stamp: 'MU 6/18/2000 02:19'!getInstMethodCategoryNameOf: aSelectorSymbol	| mits |	mits := self methodIntrospectorOf: aSelectorSymbol.	^mits getCategoryName	! !!DlClassIntrospector methodsFor: 'actions-categories' stamp: 'mu 1/1/2001 01:20'!getInstMethodCategoryNames	^ self target isNil		ifTrue: [#( )]		ifFalse: [self target organization categories]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'mu 1/1/2001 01:20'!getAllSubclassNames	^ self target isNil		ifTrue: [#( )]		ifFalse: [self target allSubclasses collect: [:each | each name]]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'mu 1/1/2001 01:20'!getAllSubclasses	^ self target isNil		ifTrue: [#( )]		ifFalse: [self target allSubclasses]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'mu 1/1/2001 01:21'!getAllSuperclassNames	^ self target isNil		ifTrue: [#( )]		ifFalse: [self getAllSuperclasses collect: [:each | each name]]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'mu 1/1/2001 01:21'!getAllSuperclasses	^ self target isNil		ifTrue: [#( )]		ifFalse: [self target allSuperclasses]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'mu 11/23/2004 01:11'!getClassComment	^ self target isNil		ifTrue: ['']		ifFalse: [self target theNonMetaClass organization classComment]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'M.U 11/6/1999 01:13'!getSubclassNames	^self getSubclasses collect: [:each | each name]	! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'mu 1/1/2001 01:15'!getSubclasses	^ self target isNil		ifTrue: [#()]		ifFalse: [self target subclasses]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'mu 1/1/2001 01:16'!getSuperclass	^ self target isNil		ifTrue: [nil]		ifFalse: [self target superclass]! !!DlClassIntrospector methodsFor: 'actions-hierarchy' stamp: 'M.U 11/6/1999 01:15'!getSuperclassName	^self getSuperclass name! !!DlClassIntrospector methodsFor: 'actions-pools' stamp: 'mu 1/1/2001 01:17'!getAllPools	^ self target isNil		ifTrue: [#()]		ifFalse: [self target allSharedPools]! !!DlClassIntrospector methodsFor: 'actions-pools' stamp: 'mu 11/26/2003 02:43'!getDeclarativePoolNames	^self getDeclarativePools collect: [:each | each name]! !!DlClassIntrospector methodsFor: 'actions-pools' stamp: 'mu 11/26/2003 02:45'!getDeclarativePools	^ self target isNil		ifTrue: [#()]		ifFalse: [self target sharedPools select: [:each | each isKindOf: SharedPool]]! !!DlClassIntrospector methodsFor: 'actions-pools' stamp: 'M.U 11/6/1999 01:30'!getPoolNames	^self getPools collect: [:each | Smalltalk keyAtIdentityValue: each]! !!DlClassIntrospector methodsFor: 'actions-pools' stamp: 'mu 1/1/2001 01:17'!getPools	^ self target isNil		ifTrue: [#()]		ifFalse: [self target sharedPools]! !!DlClassIntrospector methodsFor: 'private' stamp: 'MU 6/18/2000 01:41'!classMethodIntrospectorOf: aSelectorSymbol 	^classSelectorCache ~~ aSelectorSymbol		ifTrue: 			[classSelectorCache := aSelectorSymbol.			classMethodIntrospector := DlMethodIntrospector named: aSelectorSymbol in: self target class]		ifFalse: [classMethodIntrospector].! !!DlClassIntrospector methodsFor: 'private' stamp: 'MU 6/18/2000 01:42'!methodIntrospectorOf: aSelectorSymbol	^selectorCache ~~ aSelectorSymbol		ifTrue: 			[selectorCache := aSelectorSymbol.			methodIntrospector := DlMethodIntrospector named: aSelectorSymbol in: self target]		ifFalse: [methodIntrospector].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlClassIntrospector class	instanceVariableNames: ''!!DlClassIntrospector class methodsFor: 'instance creation' stamp: 'mu 1/2/2001 00:09'!on: aClass	(aClass isNil or: [(aClass isKindOf: Class) not]) ifTrue:[DlInstanceCreationFailed new signal].	^self new target: aClass! !DlAbstractIntrospector subclass: #DlGlobalRootIntrospector	instanceVariableNames: 'pools globalVariables'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlGlobalRootIntrospector commentStamp: '<historical>' prior: 0!I introspect GlobalRoot (a.k.a Smalltalk).#creator [:masashi | ^umezawa] #version 0.1!!DlGlobalRootIntrospector methodsFor: 'actions' stamp: 'M.U 10/30/1999 19:29'!getGlobalVariableNames	self isIntrospected ifFalse: [ self introspect ].	^self globalVariables collect: [:global | self target keyAtIdentityValue: global].! !!DlGlobalRootIntrospector methodsFor: 'actions' stamp: 'M.U 10/30/1999 21:00'!getGlobalVariableValueNamed: aGlobalVariableName	^self target at: aGlobalVariableName asSymbol ifAbsent:[].	! !!DlGlobalRootIntrospector methodsFor: 'actions' stamp: 'M.U 10/30/1999 19:20'!getPoolNames	self isIntrospected ifFalse: [ self introspect ].	^self pools collect: [:pool | self target keyAtIdentityValue: pool].! !!DlGlobalRootIntrospector methodsFor: 'actions' stamp: 'M.U 10/30/1999 21:00'!getPoolValueNamed: aPoolName	^self target at: aPoolName asSymbol ifAbsent:[].! !!DlGlobalRootIntrospector methodsFor: 'introspection' stamp: 'mu 11/9/2004 01:27'!privIntrospect	self pools: Set new.	self target allClassesDo: [:cls | self pools addAll: cls sharedPools].	self globalVariables: (self target select: [:each | (each isKindOf: Class) not]) asOrderedCollection.	self pools do: [:each | self globalVariables remove: each ifAbsent:[]]. 		! !!DlGlobalRootIntrospector methodsFor: 'accessing' stamp: 'M.U 10/30/1999 19:12'!globalVariables	^globalVariables! !!DlGlobalRootIntrospector methodsFor: 'accessing' stamp: 'M.U 10/30/1999 19:12'!globalVariables: aValue	globalVariables := aValue! !!DlGlobalRootIntrospector methodsFor: 'accessing' stamp: 'M.U 10/30/1999 19:12'!pools	^pools! !!DlGlobalRootIntrospector methodsFor: 'accessing' stamp: 'M.U 10/30/1999 19:12'!pools: aValue	pools := aValue! !DlAbstractIntrospector subclass: #DlLocalScopeVariableIntrospector	instanceVariableNames: 'instVarTypeDict clsVarTypeDict clsInstVarTypeDict instVarInitialValueDict clsVarInitialValueDict clsInstVarInitialValueDict instVarCommentDict clsVarCommentDict clsInstVarCommentDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlLocalScopeVariableIntrospector commentStamp: '<historical>' prior: 0!I represent a abstract DlVariableIntrospector.Type, initial value, and comment can be introspected.#creator[:masashi | ^umezawa] #version 0.3 M.U 5/5/1999 21:36!!DlLocalScopeVariableIntrospector methodsFor: 'actions-type' stamp: 'M.U 5/8/1999 01:28'!getClassInstVarTypeOf: aVariableName	self introspect.	^self clsInstVarTypeDict at: aVariableName asString ifAbsent: [nil]			! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-type' stamp: 'M.U 5/8/1999 01:28'!getClassVarTypeOf: aVariableName	self introspect.	^self clsVarTypeDict at: aVariableName asString ifAbsent: [nil]	! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-type' stamp: 'M.U 5/8/1999 01:29'!getInstVarTypeOf: aVariableName	self introspect.	^self instVarTypeDict at: aVariableName asString ifAbsent: [nil]	! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-initialValue' stamp: 'M.U 5/8/1999 01:29'!getClassInstVarInitialValueOf: aVariableName	self introspect.	^self clsInstVarInitialValueDict at: aVariableName asString ifAbsent: [nil]		! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-initialValue' stamp: 'M.U 5/8/1999 01:29'!getClassVarInitialValueOf: aVariableName	self introspect.	^self clsVarInitialValueDict at: aVariableName asString ifAbsent: [nil]	! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-initialValue' stamp: 'M.U 5/8/1999 01:29'!getInstVarInitialValueOf: aVariableName	self introspect.	^self instVarInitialValueDict at: aVariableName asString ifAbsent: [nil]	! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-comment' stamp: 'M.U 5/8/1999 01:29'!getClassInstVarCommentOf: aVariableName	self introspect.	^self clsInstVarCommentDict at: aVariableName asString ifAbsent: [nil]		! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-comment' stamp: 'M.U 5/8/1999 01:29'!getClassVarCommentOf: aVariableName	self introspect.	^self clsVarCommentDict at: aVariableName asString ifAbsent: [nil]	! !!DlLocalScopeVariableIntrospector methodsFor: 'actions-comment' stamp: 'M.U 5/8/1999 01:50'!getInstVarCommentOf: aVariableName	self introspect.	^self instVarCommentDict at: aVariableName asString ifAbsent: [nil]		! !!DlLocalScopeVariableIntrospector methodsFor: 'factory' stamp: 'MU 2/5/1999 23:41'!defaultDictionary	^Dictionary new! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:41'!clsInstVarCommentDict	clsInstVarCommentDict isNil ifTrue:[ clsInstVarCommentDict := self defaultDictionary].	^clsInstVarCommentDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!clsInstVarCommentDict: aValue	clsInstVarCommentDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:42'!clsInstVarInitialValueDict	clsInstVarInitialValueDict isNil ifTrue:[ clsInstVarInitialValueDict := self defaultDictionary].	^clsInstVarInitialValueDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!clsInstVarInitialValueDict: aValue	clsInstVarInitialValueDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:42'!clsInstVarTypeDict	clsInstVarTypeDict isNil ifTrue:[ clsInstVarTypeDict := self defaultDictionary].	^clsInstVarTypeDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!clsInstVarTypeDict: aValue	clsInstVarTypeDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:42'!clsVarCommentDict	clsVarCommentDict isNil ifTrue:[ clsVarCommentDict := self defaultDictionary].	^clsVarCommentDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!clsVarCommentDict: aValue	clsVarCommentDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:42'!clsVarInitialValueDict	clsVarInitialValueDict isNil ifTrue:[ clsVarInitialValueDict := self defaultDictionary].	^clsVarInitialValueDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!clsVarInitialValueDict: aValue	clsVarInitialValueDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:42'!clsVarTypeDict	clsVarTypeDict isNil ifTrue:[ clsVarTypeDict := self defaultDictionary].	^clsVarTypeDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!clsVarTypeDict: aValue	clsVarTypeDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:43'!instVarCommentDict	instVarCommentDict isNil ifTrue:[ instVarCommentDict := self defaultDictionary].	^instVarCommentDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!instVarCommentDict: aValue	instVarCommentDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:43'!instVarInitialValueDict	instVarInitialValueDict isNil ifTrue:[ instVarInitialValueDict := self defaultDictionary].	^instVarInitialValueDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!instVarInitialValueDict: aValue	instVarInitialValueDict := aValue! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:43'!instVarTypeDict	instVarTypeDict isNil ifTrue:[ instVarTypeDict := self defaultDictionary].	^instVarTypeDict! !!DlLocalScopeVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/5/1999 23:31'!instVarTypeDict: aValue	instVarTypeDict := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlLocalScopeVariableIntrospector class	instanceVariableNames: ''!!DlLocalScopeVariableIntrospector class methodsFor: 'instance creation' stamp: 'M.U 1/2/2000 22:30'!on: aClass	^self new target: aClass theNonMetaClass! !DlLocalScopeVariableIntrospector subclass: #DlClassCommentVariableIntrospector	instanceVariableNames: 'commentString readStream cachedWriteStream instMark clsMark clsInstMark'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlClassCommentVariableIntrospector commentStamp: '<historical>' prior: 0!Ported from "Rose/Smalltalk PrivateExtension 1996 Masashi Umezawa".Original name was RoseConventionalTypeParser.I parse class comment written in conventional format like this:'instance | class | class instance  variable names: 	variableName <className>  comment'And regard parsed values as variable type or variable commentNote: the porting is a kind of quick hack...#creator [:masashi | ^umezawa] #version 0.1 MU!!DlClassCommentVariableIntrospector methodsFor: 'initialize-release' stamp: 'MU 2/7/1999 17:26'!initialize	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	super initialize.	commentString := ''.	cachedWriteStream := WriteStream on: (String new: 16).	instMark := clsMark := clsInstMark := -1! !!DlClassCommentVariableIntrospector methodsFor: 'introspection' stamp: 'MU 2/20/1999 23:53'!privIntrospect	"Copyright(C) 1999 Masashi Umezawa All Rights Reserved"	self parse! !!DlClassCommentVariableIntrospector methodsFor: 'parsing' stamp: 'MU 2/5/1999 22:38'!parse	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| nextChar result mark offset chop rStream |	rStream := self readStream.	[rStream atEnd]		whileFalse: 			[nextChar _ rStream next.			(nextChar == $v or: [nextChar == $V])				ifTrue: 					[result := rStream skipToAll: 'ariable'.					result isNil						ifFalse: 							[mark := rStream position.							offset := 15.							"back 15 characters 'class instance'"							[mark < offset]								whileTrue: [offset := offset - 1].							rStream skip: offset negated.							rStream skipSeparators.							chop := rStream copyFrom: rStream position to: mark - 1.							self parseChoppedComment: chop markPosition: mark + 7. "skip 'ariable'"							rStream position: mark + 7]]]! !!DlClassCommentVariableIntrospector methodsFor: 'parsing' stamp: 'MU 2/7/1999 17:34'!parseChoppedComment: aString markPosition: position 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| match |	match := self removeSeparators: aString.	('classinstance' match: match)		ifTrue: 			[self clsInstMark: position.			^self parseClsInstVarArea].	('*class' match: match)		ifTrue: 			[self clsMark: position.			^self parseClsVarArea].	('*instance' match: match)		ifTrue: 			[self instMark: position.			^self parseInstVarArea]! !!DlClassCommentVariableIntrospector methodsFor: 'parsing' stamp: 'MU 2/7/1999 17:43'!parseClsInstVarArea	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| tmpArray |	self readStream position: self clsInstMark.	tmpArray := self parseVariableTypeAndComment: readStream.	(tmpArray at: 1)		associationsDo: [:assoc | self clsInstVarTypeDict at: assoc key put: assoc value].	(tmpArray at: 2)		associationsDo: [:assoc | self clsInstVarCommentDict at: assoc key put: assoc value]! !!DlClassCommentVariableIntrospector methodsFor: 'parsing' stamp: 'MU 2/7/1999 17:43'!parseClsVarArea	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| tmpArray |	self readStream position: self clsMark.	tmpArray := self parseVariableTypeAndComment: readStream.	(tmpArray at: 1)		associationsDo: [:assoc | self clsVarTypeDict at: assoc key put: assoc value].	(tmpArray at: 2)		associationsDo: [:assoc | self clsVarCommentDict at: assoc key put: assoc value]! !!DlClassCommentVariableIntrospector methodsFor: 'parsing' stamp: 'MU 2/7/1999 17:43'!parseInstVarArea	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| tmpArray |	self readStream position: self instMark.	tmpArray := self parseVariableTypeAndComment: readStream.	(tmpArray at: 1)		associationsDo: [:assoc | self instVarTypeDict at: assoc key put: assoc value].	(tmpArray at: 2)		associationsDo: [:assoc | self instVarCommentDict at: assoc key put: assoc value]! !!DlClassCommentVariableIntrospector methodsFor: 'parsing' stamp: 'M.U 5/8/1999 13:41'!parseVariableTypeAndComment: choppedStream 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| tmpNameVarDictionary tmpNameCommentDictionary status commentWStream nameKey nextChar crMark openMarkFound closeMarkFound openMark closeMark typeValue |	nameKey := ''.	tmpNameVarDictionary := Dictionary new.	tmpNameCommentDictionary := Dictionary new.	status := #start.	commentWStream := WriteStream on: (String new: 64).	[choppedStream atEnd]		whileFalse: 			[nextChar := choppedStream next.			status == #found ifTrue: [commentWStream nextPut: nextChar].			(nextChar == Character cr or: [nextChar == Character lf])				ifTrue: 					[status == #found ifTrue: [tmpNameCommentDictionary add: (self makeVarNameCommentAssoc: nameKey with: commentWStream contents)].					(self isVarModeSwitchPoint: choppedStream)						ifTrue: [^ Array with: tmpNameVarDictionary with: tmpNameCommentDictionary].					crMark := choppedStream position.					choppedStream peek == Character lf ifTrue: [crMark := crMark + 1].					openMarkFound := choppedStream skipTo: $<.					openMarkFound						ifTrue: 							[commentWStream reset.							openMark := choppedStream position.							closeMarkFound := choppedStream skipTo: $>.							closeMarkFound								ifTrue: 									[status := #found.									closeMark := choppedStream position.									nameKey := choppedStream copyFrom: crMark + 1 to: openMark - 1.									typeValue := choppedStream copyFrom: openMark + 1 to: closeMark - 1.									tmpNameVarDictionary add: (self makeVarNameTypeAssoc: nameKey with: typeValue)]]]].	status == #found ifTrue: [tmpNameCommentDictionary add: (self makeVarNameCommentAssoc: nameKey with: commentWStream contents)].	^ Array with: tmpNameVarDictionary with: tmpNameCommentDictionary.! !!DlClassCommentVariableIntrospector methodsFor: 'private' stamp: 'M.U 5/8/1999 13:52'!isVarMode: aString 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| match |	match := self removeSeparators: aString.	('classinstance' match: match)		ifTrue: [^true].	('*class' match: match)		ifTrue: [^true].	('*instance' match: match)		ifTrue: [^true].	^false! !!DlClassCommentVariableIntrospector methodsFor: 'private' stamp: 'M.U 5/9/1999 01:06'!isVarModeSwitchPoint: aChoppedStream 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| rStream nextChar mark offset chop storePosition vmark emark |	rStream := aChoppedStream.	storePosition := rStream position.	nextChar := rStream next.	rStream atEnd ifTrue: [^ false].	[nextChar == $< or: [rStream atEnd]]		whileFalse: 			[(nextChar == $v or: [nextChar == $V])				ifTrue: 					[vmark := rStream position.					emark := vmark + 7.					emark > rStream size						ifFalse: 							[rStream skip: 7.							"skip 'ariable'"							(rStream copyFrom: vmark + 1 to: emark) asString = 'ariable'								ifTrue: 									[mark := vmark.									rStream skip: -7.									offset := 15.									"back 15 characters 'class instance'"									[mark < offset]										whileTrue: [offset := offset - 1].									rStream skip: offset negated.									rStream skipSeparators.									chop := rStream copyFrom: rStream position to: mark - 1.									rStream position: storePosition.									^ self isVarMode: chop]]].			nextChar := rStream next].	rStream position: storePosition.	^ false.! !!DlClassCommentVariableIntrospector methodsFor: 'private'!makeChoppedCommentType: choppedString 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| rst wst nextChar |	rst := ReadStream on: choppedString.	wst := self cachedWriteStream reset.	nextChar := rst next.	[nextChar == Character space or: [nextChar == Character tab]]		whileTrue: [nextChar := rst next].	[nextChar == Character cr or: [nextChar == Character lf or: [rst atEnd]]]		whileFalse: 			[wst nextPut: nextChar.			nextChar := rst next].	^wst contents! !!DlClassCommentVariableIntrospector methodsFor: 'private' stamp: 'MU 2/5/1999 22:50'!makeChoppedVarName: choppedString 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	"rare case: choppedString might contain cr or lf"	| mark size varNameString each |	size := choppedString size.	1 to: size do: 		[:index | 		each _ choppedString at: index.		(each == Character cr or: [each == Character lf])			ifTrue: [mark := index]].	varNameString := mark notNil				ifTrue: [choppedString copyFrom: mark + 1 to: size]				ifFalse: [choppedString].	^ self removeSeparators: varNameString! !!DlClassCommentVariableIntrospector methodsFor: 'private'!makeChoppedVarType: choppedString 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^self removeSeparators: choppedString! !!DlClassCommentVariableIntrospector methodsFor: 'private'!makeVarNameCommentAssoc: key with: value 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^(self makeChoppedVarName: key)		-> (self makeChoppedCommentType: value)! !!DlClassCommentVariableIntrospector methodsFor: 'private'!makeVarNameTypeAssoc: key with: value 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^(self makeChoppedVarName: key)		-> (self makeChoppedVarType: value)! !!DlClassCommentVariableIntrospector methodsFor: 'private'!removeSeparators: aString 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| wstrm rstrm |	wstrm := self cachedWriteStream reset.	rstrm := ReadStream on: aString.	rstrm skipSeparators.	[rstrm atEnd]		whileFalse: 			[wstrm nextPut: rstrm next.			rstrm skipSeparators].	^wstrm contents! !!DlClassCommentVariableIntrospector methodsFor: 'testing' stamp: 'MU 2/7/1999 17:36'!hasClsInstVar	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^self clsInstMark ~= -1! !!DlClassCommentVariableIntrospector methodsFor: 'testing' stamp: 'MU 2/7/1999 17:36'!hasClsVar	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^self clsMark ~= -1! !!DlClassCommentVariableIntrospector methodsFor: 'testing' stamp: 'MU 2/7/1999 17:36'!hasInstVar	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^self instMark ~= -1! !!DlClassCommentVariableIntrospector methodsFor: 'accessing'!cachedWriteStream	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^cachedWriteStream! !!DlClassCommentVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/7/1999 17:33'!clsInstMark	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^clsInstMark! !!DlClassCommentVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/7/1999 17:34'!clsInstMark: anInteger	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	clsInstMark := anInteger! !!DlClassCommentVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/7/1999 17:33'!clsMark	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^clsMark! !!DlClassCommentVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/7/1999 17:34'!clsMark: anInteger	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	clsMark := anInteger! !!DlClassCommentVariableIntrospector methodsFor: 'accessing'!commentString	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^commentString! !!DlClassCommentVariableIntrospector methodsFor: 'accessing'!commentString: aString 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	commentString := aString! !!DlClassCommentVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/7/1999 17:33'!instMark	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	^instMark! !!DlClassCommentVariableIntrospector methodsFor: 'accessing' stamp: 'MU 2/7/1999 17:34'!instMark: anInteger	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	instMark := anInteger! !!DlClassCommentVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/31/1999 23:58'!readStream	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	readStream isNil ifTrue: [ readStream := self defaultReadStreamClass on: self commentString].	^readStream! !!DlClassCommentVariableIntrospector methodsFor: 'factory' stamp: 'MU 1/31/1999 23:37'!defaultReadStreamClass	^DlPositionableStream wrapClass: ReadStream.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlClassCommentVariableIntrospector class	instanceVariableNames: ''!!DlClassCommentVariableIntrospector class methodsFor: 'instance creation' stamp: 'mu 11/23/2004 01:15'!on: aClass 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	| inst | 	inst := super on: aClass.	inst commentString: aClass theNonMetaClass organization classComment.	^inst! !DlLocalScopeVariableIntrospector subclass: #DlDynamicVariableIntrospector	instanceVariableNames: 'inst defaultInstanceSelector initializeSelector isLazySupport isNilBlank errorStrings'	classVariableNames: 'ClassVarFiller'	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlDynamicVariableIntrospector commentStamp: '<historical>' prior: 0!Ported from "Rose/Smalltalk PrivateExtension 1996 Masashi Umezawa".Original name was RoseDynamicClassIntrospector.I introspect class variable types and initial values by instantiate the target class and initialize the instance.#creator [:masashi | ^umezawa] #version 0.2!!DlDynamicVariableIntrospector methodsFor: 'initialize-release' stamp: 'MU 3/14/2000 02:28'!initSetting	"Copyright(C) 1999 Masashi Umezawa All Rights Reserved"	defaultInstanceSelector := #default.	initializeSelector := #initialize. 	isLazySupport := true.	isNilBlank := false.! !!DlDynamicVariableIntrospector methodsFor: 'initialize-release' stamp: 'M.U 5/7/1999 23:42'!initialize	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	super initialize.	inst := nil.	self initSetting! !!DlDynamicVariableIntrospector methodsFor: 'introspection' stamp: 'MU 2/25/1999 00:37'!privIntrospect	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	self tryInstantiating.	self tryInitializing.	self reflectInstVariales.	self reflectClassVariables.	self reflectClassInstanceVariables! !!DlDynamicVariableIntrospector methodsFor: 'introspection' stamp: 'MU 3/25/2000 01:40'!tryInitializing	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	"$POST: instance initialized"	| ds initSele i cls |	initSele := self initializeSelector.	i := self inst.	i notNil		ifTrue: [[(i respondsTo: initSele)				ifTrue: [i perform: initSele]				ifFalse: 					[ds := self defaultInstanceSelector.					cls := i class.					(cls respondsTo: ds)						ifTrue: [self validateSetInst: (cls perform: ds) class: cls]]]				on: Error do: 				[:ex | 				self reportException: ex.				ex retryUsing:[]]].! !!DlDynamicVariableIntrospector methodsFor: 'introspection' stamp: 'MU 3/25/2000 02:19'!tryInstantiating	"Copyright(C) 1999 Masashi Umezawa All Rights Reserved"	"$PRE: inst == nil"	| cls |	cls := self target.	(self isIntrospectableClass: cls)		ifTrue: [[cls isVariable				ifTrue: [(cls respondsTo: #new:)						ifTrue: [self validateSetInst: (cls new: 0) class: cls  ]						ifFalse: ["the last resort"							(cls respondsTo: #basicNew:)								ifTrue: [self inst: (cls basicNew: 0) ]]]				ifFalse: [(cls respondsTo: #new)						ifTrue: [self validateSetInst:  cls new class: cls]						ifFalse: ["the last resort"							(cls respondsTo: #basicNew)								ifTrue: [self inst: cls basicNew]]]]				on: Error do: 				[:ex | 				self reportException: ex.				ex retryUsing:[self inst: nil]]].! !!DlDynamicVariableIntrospector methodsFor: 'reflection' stamp: 'M.U 1/10/2000 18:08'!reflectClassInstanceVariables	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	"$PRE: targetClass notNil"	"$NOTE: ClassVarFiller must be Initialized if you add some 	variables to 'Class' class ( and it's  		superclass)"	| dict cls names idx vValue |	dict := self clsInstVarTypeDict.	cls := self target.	cls notNil		ifTrue: 			[names := cls class instVarNames.			names do: [:name | dict at: name put: nil].			self isLazySupport ifTrue: [self lazyInit: dict target: cls].			idx := ClassVarFiller.			names do: 				[:name | 				vValue := cls instVarAt:  (idx := idx + 1).				self clsInstVarInitialValueDict at: name put: vValue.				dict at: name put: vValue].			self processTypeVarDict: dict].	^ dict! !!DlDynamicVariableIntrospector methodsFor: 'reflection' stamp: 'M.U 1/10/2000 18:08'!reflectClassVariables	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	"$PRE: targetClass notNil"	| dict cls nm vValue |	dict := self clsVarTypeDict.	cls := self target.	cls notNil		ifTrue: 			[self isLazySupport ifTrue: [self lazyInit: dict target: cls].			cls classPool				associationsDo: 					[:assoc | 					nm := assoc key asString.					vValue := assoc value.					dict at: nm asString put: vValue.					self clsVarInitialValueDict at: nm put: vValue].			self processTypeVarDict: dict].	^ dict! !!DlDynamicVariableIntrospector methodsFor: 'reflection' stamp: 'M.U 1/12/2000 23:50'!reflectInstVariales	"Copyright(C) 2000 Masashi Umezawa All Rights Reserved"	"$PRE: inst notNil & initialized"	"now using instVarNamed:" 	| dict cls names vValue |	dict := self instVarTypeDict.	cls := self target.	(inst notNil and: [cls notNil])		ifTrue: 			[names := cls instVarNames.			names do: [:name | dict at: name put: nil].			self isLazySupport ifTrue: [self lazyInit: dict target: inst].			names do: 				[:name | 				vValue := inst instVarNamed: name.				self instVarInitialValueDict at: name put: vValue.				dict at: name put: vValue.].			self processTypeVarDict: dict].	^ dict! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!defaultInstanceSelector	^defaultInstanceSelector! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!defaultInstanceSelector: aValue	defaultInstanceSelector := aValue! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!initializeSelector	^initializeSelector! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!initializeSelector: aValue	initializeSelector := aValue! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:27'!inst	"Copyright(C) 1999 Masashi Umezawa All Rights Reserved"	^inst! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 3/25/2000 01:05'!inst: anObject 	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	inst := anObject! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!isLazySupport	^isLazySupport! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!isLazySupport: aValue	isLazySupport := aValue! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!isNilBlank	^isNilBlank! !!DlDynamicVariableIntrospector methodsFor: 'accessing' stamp: 'MU 1/17/1999 23:52'!isNilBlank: aValue	isNilBlank := aValue! !!DlDynamicVariableIntrospector methodsFor: 'private' stamp: 'MU 3/21/2000 01:23'!isIntrospectableClass: aClass 	^ (aClass superclass notNil or: [aClass name == #Object		"For other Smalltalks"])		and: [aClass isKindOf: Class].! !!DlDynamicVariableIntrospector methodsFor: 'private' stamp: 'MU 3/25/2000 01:40'!lazyInit: aDictionary target: anInstanceOrClass 	"Copyright(C) 2000 Masashi Umezawa All Rights Reserved"	aDictionary		keysAndValuesDo: [:key :value | value isNil				ifTrue: 					[ | accssr | 					accssr := key asSymbol.					[(anInstanceOrClass respondsTo: accssr)						ifTrue: [anInstanceOrClass perform: accssr]]						on: Error do: 						[:ex | 						self reportException: ex.						ex retryUsing:[]]]].	^ aDictionary.! !!DlDynamicVariableIntrospector methodsFor: 'private' stamp: 'MU 3/26/2000 22:55'!processTypeVarDict: aDictionary 	"Copyright(C) 1999 Masashi Umezawa All Rights Reserved"	aDictionary		keysAndValuesDo: 			[:key :value | 			aDictionary at: key put: (self typeStringOf: value)].	^aDictionary! !!DlDynamicVariableIntrospector methodsFor: 'private' stamp: 'MU 3/25/2000 00:54'!reportException: anException 	"Copyright(C) 2000 Masashi Umezawa All Rights Reserved"	self class isDebugMode		ifTrue: 			[Transcript cr; show: self name printString , ' caught this error in introspection: '.			Transcript space; show: anException description printString.			Transcript space; show: 'target= ', self target printString.].			! !!DlDynamicVariableIntrospector methodsFor: 'private' stamp: 'MU 3/26/2000 22:55'!typeStringOf: anObject	"Copyright(C) 2000 Masashi Umezawa All Rights Reserved"	^(self isNilBlank and: [anObject isNil])		ifTrue: ['']		ifFalse: [anObject class name asString]! !!DlDynamicVariableIntrospector methodsFor: 'private' stamp: 'MU 3/25/2000 02:19'!validateSetInst: anInstance class: aClass 		((anInstance respondsTo: #class) and:[(anInstance class == aClass)])		ifTrue: [self inst: anInstance]		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDynamicVariableIntrospector class	instanceVariableNames: 'isDebugMode'!!DlDynamicVariableIntrospector class methodsFor: 'class initialization' stamp: 'MU 3/26/2000 23:13'!initialize	"Copyright(C) 1997 Masashi Umezawa All Rights Reserved"	"DlDynamicVariableIntrospector initialize"	"DlDynamicVariableIntrospector isDebugMode: true"	ClassVarFiller := Class allInstVarNames size.	! !!DlDynamicVariableIntrospector class methodsFor: 'accessing' stamp: 'MU 3/26/2000 23:13'!isDebugMode	isDebugMode isNil ifTrue: [isDebugMode := false].	^isDebugMode! !!DlDynamicVariableIntrospector class methodsFor: 'accessing' stamp: 'MU 3/11/2000 18:44'!isDebugMode: aBoolean	isDebugMode := aBoolean! !DlAbstractIntrospector subclass: #DlMethodIntrospector	instanceVariableNames: 'selector klass source classIntrospector'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlMethodIntrospector commentStamp: '<historical>' prior: 0!I introspect methods. See 'actions' method category for details.#creator [:masashi | ^umezawa] #version 0.1!!DlMethodIntrospector methodsFor: 'accessing' stamp: 'MU 6/18/2000 02:13'!classIntrospector	classIntrospector isNil ifTrue:[classIntrospector := DlClassIntrospector on: self klass].	^classIntrospector! !!DlMethodIntrospector methodsFor: 'accessing' stamp: 'MU 6/18/2000 00:25'!klass	^klass! !!DlMethodIntrospector methodsFor: 'accessing' stamp: 'MU 6/18/2000 00:25'!klass: aValue	klass := aValue! !!DlMethodIntrospector methodsFor: 'accessing' stamp: 'MU 6/18/2000 00:25'!selector	^selector! !!DlMethodIntrospector methodsFor: 'accessing' stamp: 'MU 6/18/2000 00:25'!selector: aValue	selector := aValue! !!DlMethodIntrospector methodsFor: 'accessing' stamp: 'MU 6/18/2000 02:00'!source	^source! !!DlMethodIntrospector methodsFor: 'accessing' stamp: 'MU 6/18/2000 02:00'!source: aValue	source := aValue! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'mu 1/1/2001 23:50'!getCategoryName	self klass isNil ifTrue:[^nil].	^self klass organization categoryOfElement: self selector! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'MU 6/18/2000 02:01'!getMethodAllComments	| src |	src := self getMethodSource.	^src isNil ifTrue:[src] ifFalse: [ self pickMethodComments: src]! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'MU 6/18/2000 01:59'!getMethodBody 	| src |	src := self getMethodSource.	^src isNil ifTrue:[src] ifFalse: [ self pickMethodBody: src]! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'MU 6/18/2000 02:02'!getMethodConcatComment	| src |	src := self getMethodSource.	^src isNil ifTrue:[src] ifFalse: [ self pickMethodConcatComment: src]! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'MU 6/18/2000 02:02'!getMethodFirstComment	| src |	src := self getMethodSource.	^src isNil ifTrue:[src] ifFalse: [ self pickMethodFirstComment: src]! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'MU 6/18/2000 01:59'!getMethodHead 	| src |	src := self getMethodSource.	^src isNil ifTrue:[src] ifFalse: [ self pickMethodHead: src]! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'mu 11/23/2004 23:22'!getMethodNameArgs	| head |	head := self getMethodHead.	^ head isNil		ifTrue: [head]		ifFalse: [(head includes: $:)				ifTrue: [Scanner new scanFieldNames: head]				ifFalse: [#()]]! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'mu 1/1/2001 23:48'!getMethodNumArgs	| ret |	self klass isNil ifTrue:[^nil].	ret :=  self klass compiledMethodAt:  self selector ifAbsent: [-1].	^(ret = -1 ) ifTrue: [ret] ifFalse:[ret numArgs]! !!DlMethodIntrospector methodsFor: 'actions' stamp: 'MU 12/4/2000 01:09'!getMethodSource 	self klass isNil ifTrue:[^nil].	self source:  (self klass sourceCodeAt:  self selector ifAbsent:[nil]).	^self source! !!DlMethodIntrospector methodsFor: 'private' stamp: 'MU 6/18/2000 01:28'!pickMethodBody: aSourceString 	| parser |	parser := Parser new.	parser parseSelector: aSourceString.	^aSourceString copyFrom: (parser endOfLastToken min: aSourceString size) + 1 to: ( aSourceString size)! !!DlMethodIntrospector methodsFor: 'private' stamp: 'MU 6/18/2000 01:29'!pickMethodComments: aSourceString 	"ugly but fast"	| stream char collection comment nextchar status |	status := #outString.	collection := OrderedCollection new.	comment := WriteStream on: ''.	stream := ReadWriteStream with: aSourceString.	stream nextPut: Character space.	stream reset.	nextchar := stream next.	[stream atEnd]		whileFalse: 			[char := nextchar.			nextchar := stream next.			status == #outString				ifTrue: 					[char == $' ifTrue: [status := #inString].					char == $" ifTrue: [status := #inComment].					char == $$ ifTrue: [status := #inChar]]				ifFalse: [status == #doubleQuote						ifTrue: [status := #inComment]						ifFalse: [status == #inString								ifTrue: [char == $' ifTrue: [status := #outString]]								ifFalse: [status == #inComment										ifTrue: [char == $"												ifTrue: [nextchar == $"														ifTrue: 															[ status := #doubleQuote]														ifFalse: 															[ status := #outString].															collection add: comment contents.															comment reset.]												ifFalse: [comment nextPut: char]]										ifFalse: [status == #inChar ifTrue: [status := #outString]]]]]].	^collection! !!DlMethodIntrospector methodsFor: 'private' stamp: 'MU 6/18/2000 01:29'!pickMethodConcatComment: aSourceString 	"ugly but fast"	| stream char comment nextchar status |	status := #outString.	comment := WriteStream on: ''.	stream := ReadWriteStream with: aSourceString.	stream nextPut: Character space.	stream reset.	nextchar := stream next.	[stream atEnd]		whileFalse: 			[char := nextchar.			nextchar := stream next.			status == #outString				ifTrue: 					[char == $' ifTrue: [status := #inString].					char == $" ifTrue: [status := #inComment].					char == $$ ifTrue: [status := #inChar]]				ifFalse: [status == #doubleQuote						ifTrue: [status := #inComment]						ifFalse: [status == #inString								ifTrue: [char == $' ifTrue: [status := #outString]]								ifFalse: [status == #inComment										ifTrue: [char == $"												ifTrue: [nextchar == $"														ifTrue: 															[status := #doubleQuote]														ifFalse: 															[status := #outString].															comment nextPut: Character cr]												ifFalse: [comment nextPut: char]]										ifFalse: [status == #inChar ifTrue: [status := #outString]]]]]].	^comment contents! !!DlMethodIntrospector methodsFor: 'private' stamp: 'MU 6/18/2000 01:29'!pickMethodFirstComment: aSourceString 	"ugly but fast"	| stream char comment nextchar status |	status := #outString.	comment := WriteStream on: ''.	stream := ReadWriteStream with: aSourceString.	stream nextPut: Character space.	stream reset.	nextchar := stream next.	[stream atEnd]		whileFalse: 			[char := nextchar.			nextchar := stream next.			status == #outString				ifTrue: 					[char == $' ifTrue: [status := #inString].					char == $" ifTrue: [status := #inComment].					char == $$ ifTrue: [status := #inChar]]				ifFalse: [status == #doubleQuote						ifTrue: [status := #inComment]						ifFalse: [status == #inString								ifTrue: [char == $' ifTrue: [status := #outString]]								ifFalse: [status == #inComment										ifTrue: [char == $"												ifTrue: [^comment contents]												ifFalse: [comment nextPut: char]]										ifFalse: [status == #inChar ifTrue: [status := #outString]]]]]].		^comment contents	! !!DlMethodIntrospector methodsFor: 'private' stamp: 'MU 6/18/2000 01:30'!pickMethodHead: aSourceString 	| parser |	parser := Parser new.	parser parseSelector: aSourceString.	^aSourceString copyFrom:1 to: (parser endOfLastToken min: aSourceString size)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlMethodIntrospector class	instanceVariableNames: ''!!DlMethodIntrospector class methodsFor: 'instance creation' stamp: 'MU 6/18/2000 01:09'!named: aSelectorName in: aClassOrMetaclass	| inst |	inst := super new.	inst selector: aSelectorName.	inst klass: aClassOrMetaclass.	^inst! !DlAbstractIntrospector subclass: #DlPoolIntrospector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlPoolIntrospector commentStamp: '<historical>' prior: 0!I can introspect Smalltalk Pools.Pool referencing classes can be detected.#creator[:masashi | ^umezawa] #version 0.3 M.U 5/5/1999 21:36!!DlPoolIntrospector methodsFor: 'actions' stamp: 'mu 11/9/2004 01:31'!getPoolVariableNames	self subclassResponsibility! !!DlPoolIntrospector methodsFor: 'actions' stamp: 'M.U 11/28/1999 23:15'!getReferringClassNames	^ self getReferringClasses collect: [:each | each name].! !!DlPoolIntrospector methodsFor: 'actions' stamp: 'M.U 5/1/1999 23:13'!getReferringClasses	| ord |	ord := OrderedCollection new.	Smalltalk		allClassesDo: [:each | (each sharedPools detect: [:pool | pool == self target]				ifNone: [])				~~ nil ifTrue: [ord add: each]].	^ ord! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPoolIntrospector class	instanceVariableNames: ''!!DlPoolIntrospector class methodsFor: 'instance creation' stamp: 'mu 11/9/2004 01:36'!on: aPool 	| actualClass |	actualClass := (aPool isKindOf: Dictionary)				ifTrue: [DlPoolDictionaryIntrospector]				ifFalse: [DlDeclarativePoolIntrospector].	^ actualClass new target: aPool! !DlPoolIntrospector subclass: #DlDeclarativePoolIntrospector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlDeclarativePoolIntrospector commentStamp: 'mu 11/26/2003 02:00' prior: 0!I can introspect Squeak specific DeclarativePools.Pool referencing classes can be detected.#creator[:masashi | ^umezawa] #version mu 11/26/2003 02:00!!DlDeclarativePoolIntrospector methodsFor: 'actions' stamp: 'mu 11/26/2003 01:52'!getPoolVariableNames	^self target classPool keys asOrderedCollection.	! !!DlDeclarativePoolIntrospector methodsFor: 'actions' stamp: 'mu 11/24/2004 01:21'!getPoolVariableValueNamed: aPoolVariableName	| assoc |	assoc := self target classPool at: aPoolVariableName asSymbol ifAbsent:[].	^assoc isNil ifFalse: [assoc value]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDeclarativePoolIntrospector class	instanceVariableNames: ''!!DlDeclarativePoolIntrospector class methodsFor: 'instance creation' stamp: 'mu 11/26/2003 01:49'!on: aPool	^self new target: aPool! !DlPoolIntrospector subclass: #DlPoolDictionaryIntrospector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlPoolDictionaryIntrospector methodsFor: 'actions' stamp: 'mu 11/26/2003 03:00'!getPoolVariableNames	^self target keys.	! !!DlPoolDictionaryIntrospector methodsFor: 'actions' stamp: 'mu 11/26/2003 03:01'!getPoolVariableValueNamed: aPoolVariableName	^self target at: aPoolVariableName asSymbol ifAbsent:[].	! !DlDynamicVariableIntrospector subclass: #DlTiVariableIntrospector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-introspector'!!DlTiVariableIntrospector commentStamp: '<historical>' prior: 0!I am a VariableIntrospector which can be used with TiSystem.(See author's web site: http://typeinference.swiki.net).#creator [:masashi | ^umezawa] #version 0.1!!DlTiVariableIntrospector methodsFor: 'private' stamp: 'MU 3/26/2000 23:17'!typeStringOf: anObject	"use 'type inference' for type inference(correct way!!)- MU"	^(self class isTiInstalled)		ifTrue: [anObject type printString]		ifFalse: [super typeStringOf: anObject]		! !!DlTiVariableIntrospector methodsFor: 'reflection' stamp: 'MU 3/31/2000 20:58'!reflectInstVariales	"Copyright(C) 2000 Masashi Umezawa All Rights Reserved"	"$PRE: inst notNil & initialized"	"now using instVarNamed:" 	| dict cls names vValue |	dict := self instVarTypeDict.	cls := self target.	(inst notNil and: [cls notNil])		ifTrue: 			[names := cls instVarNames.			names do: [:name | dict at: name put: nil].			self isLazySupport ifTrue: [self lazyInit: dict target: inst].			names do: 				[:name | 				vValue := inst instVarNamed: name.				self instVarInitialValueDict at: name put: vValue.				inst type isNil ifFalse:[				dict at: name put: ((				inst type instVarTypeAt: name asSymbol) printString).].			].			].	^ dict! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlTiVariableIntrospector class	instanceVariableNames: 'isTiInstalled'!!DlTiVariableIntrospector class methodsFor: 'accessing' stamp: 'MU 3/26/2000 23:03'!isTiInstalled	isTiInstalled isNil ifTrue: [isTiInstalled := (Smalltalk at: #TiSystem ifAbsent:[]) notNil].	^isTiInstalled! !!DlTiVariableIntrospector class methodsFor: 'accessing' stamp: 'MU 3/26/2000 23:04'!isTiInstalled: aBoolean	isTiInstalled := aBoolean! !DlDynamicVariableIntrospector initialize!