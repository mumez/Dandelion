DlPropertyObject subclass: #DlAbstractOutputter	instanceVariableNames: 'analysisStorage eventServer actionSequence currentAction'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter'!!DlAbstractOutputter commentStamp: '<historical>' prior: 0!Based on AnalysisStorage, I generate some output in a specific format.#annotaioninstance variables: analysisStorage <DlAnalysisStorage> referencing AnalysisStorage eventServer <DlEventServer> used to generate outputting events actionSequence <OrderedCollection | Array> collection of selectors to perform whole sequential output process currentAction <Symbol> currently performed selector in actionSequence #creator[:masashi | ^umezawa] #version 0.5!!DlAbstractOutputter methodsFor: 'actions' stamp: 'M.U 5/3/1999 18:09'!endOutput	self fireEventLabeled: #endOutput! !!DlAbstractOutputter methodsFor: 'actions' stamp: 'M.U 5/3/1999 18:56'!output	self outputWith: self actionSequence! !!DlAbstractOutputter methodsFor: 'actions' stamp: 'M.U 5/3/1999 18:43'!outputWith: anActionSequence 	"anActionSequence is a sequence of selectors"	self startOutput.	anActionSequence do: 		[:each | 		self fireEventLabeled: (each , 'Start') asSymbol.		self perform: each.		self currentAction: each.		self fireEventLabeled: (each , 'End') asSymbol].	self endOutput.! !!DlAbstractOutputter methodsFor: 'actions' stamp: 'M.U 5/3/1999 18:08'!startOutput	self fireEventLabeled: #startOutput! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'MU 4/7/2000 18:31'!actionSequence	actionSequence isNil ifTrue: [ actionSequence := self defaultActionSequence asOrderedCollection].	^actionSequence! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'M.U 5/3/1999 18:23'!actionSequence: aValue	actionSequence := aValue! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'MU 1/1/1999 01:17'!analysisStorage	^analysisStorage! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'MU 1/1/1999 01:17'!analysisStorage: aValue	analysisStorage := aValue! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'M.U 5/3/1999 18:43'!currentAction	^currentAction! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'M.U 5/3/1999 18:43'!currentAction: aValue	currentAction := aValue! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'MU 3/14/1999 23:29'!eventServer	eventServer isNil ifTrue:[ eventServer := self defaultEventServer].	^eventServer! !!DlAbstractOutputter methodsFor: 'accessing' stamp: 'MU 3/14/1999 23:30'!eventServer: aValue	eventServer := aValue! !!DlAbstractOutputter methodsFor: 'event' stamp: 'MU 2/20/2000 22:33'!fireEventLabeled: aSymbol	(self eventServer at: #outputEvent) fire: self info: aSymbol! !!DlAbstractOutputter methodsFor: 'factory' stamp: 'MU 4/7/2000 18:32'!defaultActionSequence	^#()! !!DlAbstractOutputter methodsFor: 'factory' stamp: 'M.U 1/16/2000 02:21'!defaultEventServer	^DlDandelionEventServer default! !!DlAbstractOutputter methodsFor: 'printing' stamp: 'M.U 5/3/1999 18:50'!printOn: aStream 	super printOn: aStream.	aStream space.	aStream nextPutAll: self actionSequence printString.	self currentAction isNil		ifFalse: 			[aStream space.			aStream nextPut: $>.			aStream space.			aStream nextPut: $(.			aStream nextPutAll: self currentAction printString.			aStream nextPut: $)].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAbstractOutputter class	instanceVariableNames: ''!!DlAbstractOutputter class methodsFor: 'instance creation' stamp: 'M.U 12/30/1999 17:17'!on: aDlAnalysisStorage	^self new analysisStorage: aDlAnalysisStorage! !DlAbstractOutputter subclass: #DlStreamOutputter	instanceVariableNames: 'outStream'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter'!!DlStreamOutputter commentStamp: '<historical>' prior: 0!I represent an abstract DlOutputter. I output in Stream.#creator[:masashi | ^umezawa] #version 0.3 M.U 5/5/1999 21:36!!DlStreamOutputter methodsFor: 'accessing' stamp: 'MU 1/3/1999 20:00'!outStream	^outStream! !!DlStreamOutputter methodsFor: 'accessing' stamp: 'MU 1/3/1999 20:00'!outStream: aValue	outStream := aValue! !!DlStreamOutputter methodsFor: 'actions' stamp: 'mu 1/3/2001 01:11'!closeStream	"By default, do nothing"! !DlStreamOutputter subclass: #DlDualStreamOutputter	instanceVariableNames: 'fileStreamOutputter isExternal'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter'!!DlDualStreamOutputter commentStamp: '<historical>' prior: 0!I am also an abstract Dandelion outputter. I can output in internal or external stream in an uniformed way.#creator[:masashi | ^umezawa] #version 0.1!!DlDualStreamOutputter methodsFor: 'initialize-release' stamp: 'MU 4/7/2000 01:01'!initialize	super initialize.	isExternal := true.	! !!DlDualStreamOutputter methodsFor: 'actions-stream creation' stamp: 'MU 10/2/2000 23:09'!closeStream	(self isExternal and: [outStream notNil])		ifTrue: [outStream close]! !!DlDualStreamOutputter methodsFor: 'actions-stream creation' stamp: 'MU 4/7/2000 01:02'!outStream	outStream isNil ifTrue:[ self outStream:  self defaultInternalStream].	^outStream! !!DlDualStreamOutputter methodsFor: 'actions-stream creation' stamp: 'MU 4/7/2000 01:03'!outStreamNamed: aString	^self outStreamNamed: aString  in: #() ! !!DlDualStreamOutputter methodsFor: 'actions-stream creation' stamp: 'MU 7/9/2000 01:02'!outStreamNamed: aString in: subDirectoryArray 	self isExternal		ifTrue: 			[self fileStreamOutputter outRootPathArray: self outputRootDirectoryArray.			self outStream: (self fileStreamOutputter outStreamNamed: aString in: subDirectoryArray)].	^outStream.! !!DlDualStreamOutputter methodsFor: 'accessing' stamp: 'MU 4/7/2000 01:49'!fileStreamOutputter	fileStreamOutputter isNil ifTrue: [fileStreamOutputter := self defaultFileStreamOutputter].	^fileStreamOutputter! !!DlDualStreamOutputter methodsFor: 'accessing' stamp: 'MU 4/7/2000 01:00'!fileStreamOutputter: aValue	fileStreamOutputter := aValue! !!DlDualStreamOutputter methodsFor: 'accessing' stamp: 'MU 4/7/2000 01:00'!isExternal	^isExternal! !!DlDualStreamOutputter methodsFor: 'accessing' stamp: 'MU 4/7/2000 01:00'!isExternal: aValue	isExternal := aValue! !!DlDualStreamOutputter methodsFor: 'accessing' stamp: 'MU 4/7/2000 01:16'!outputRootDirectoryArray	^self properties at: #outputRootDirectoryArray! !!DlDualStreamOutputter methodsFor: 'factory' stamp: 'MU 4/7/2000 01:05'!defaultFileStreamOutputter	^DlFileStreamOutputter new! !!DlDualStreamOutputter methodsFor: 'factory' stamp: 'MU 7/9/2000 01:12'!defaultInternalStream	^DlWrapStream wrap: Transcript! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlDualStreamOutputter class	instanceVariableNames: ''!!DlDualStreamOutputter class methodsFor: 'property' stamp: 'MU 4/7/2000 01:40'!defaultProperties	"	* outputRootDirectoryArray (Array of: String) - specifies output root default path array	"	^super defaultProperties		at: #outputRootDirectoryArray put: #('dandelionOutput');		yourself.! !DlDualStreamOutputter subclass: #DlConvertibleOutputter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter'!!DlConvertibleOutputter commentStamp: '<historical>' prior: 0!I am also an abstract Dandelion outputter. I support outputter converting protocol for convenience.#creator[:masashi | ^umezawa] #version 0.1!!DlConvertibleOutputter methodsFor: 'private' stamp: 'MU 7/7/2000 00:04'!tryConvertNamed: aSymbol	| cls |	cls := Smalltalk at: aSymbol ifAbsent:[].	^cls notNil ifTrue:[ cls new]	! !!DlConvertibleOutputter methodsFor: 'converting' stamp: 'MU 7/7/2000 00:07'!as: aDlAnalyzableOutputterClass	^aDlAnalyzableOutputterClass new analysisStorage: self analysisStorage. ! !!DlConvertibleOutputter methodsFor: 'converting' stamp: 'MU 7/6/2000 23:51'!asChangeSetOutputter	^self! !!DlConvertibleOutputter methodsFor: 'converting' stamp: 'MU 7/7/2000 00:07'!asNamed: aDlAnalyzableOutputterName	| inst |	inst := self tryConvertNamed: aDlAnalyzableOutputterName.	^inst analysisStorage: self analysisStorage. ! !!DlConvertibleOutputter methodsFor: 'converting' stamp: 'MU 7/6/2000 23:52'!asStandardOutputter	^self! !DlStreamOutputter subclass: #DlFileStreamOutputter	instanceVariableNames: 'outFilePath outRootPathArray isCleared'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter'!!DlFileStreamOutputter commentStamp: '<historical>' prior: 0!I am a Dandelion outputter. I output in FileStream.#creator[:masashi | ^umezawa] #version 0.3 M.U 5/5/1999 21:36!!DlFileStreamOutputter methodsFor: 'initialize-release' stamp: 'M.U 5/5/1999 21:16'!initialize	super initialize.	isCleared := false.	! !!DlFileStreamOutputter methodsFor: 'actions' stamp: 'M.U 5/5/1999 21:17'!clear	self outFilePath forceRemove.	self isCleared: true! !!DlFileStreamOutputter methodsFor: 'actions' stamp: 'MU 10/2/2000 23:09'!closeStream	(outStream notNil)		ifTrue: [outStream close]! !!DlFileStreamOutputter methodsFor: 'actions' stamp: 'MU 1/3/1999 19:16'!outStreamNamed: aString	^self outStreamNamed: aString in: #() ! !!DlFileStreamOutputter methodsFor: 'actions' stamp: 'MU 10/6/2000 23:40'!outStreamNamed: aString in: subDirectoryArray 	| path str pName |	(self shouldClearPreviousOutput and: [self isCleared not]) ifTrue: [self clear].	subDirectoryArray isEmpty		ifTrue: [path := self outFilePath forceExist]		ifFalse: 			[path := self outFilePath copyChainComponents: subDirectoryArray.			path beDirectoryPath; forceExist].	pName := (path copyChainComponents: (Array with: aString)) pathName.	str := self defaultFileStreamClass fileNamed: pName.	self outStream: str.	^ str.! !!DlFileStreamOutputter methodsFor: 'accessing' stamp: 'M.U 5/5/1999 21:16'!isCleared	^isCleared! !!DlFileStreamOutputter methodsFor: 'accessing' stamp: 'M.U 5/5/1999 21:16'!isCleared: aValue	isCleared := aValue! !!DlFileStreamOutputter methodsFor: 'accessing' stamp: 'MU 1/3/1999 01:51'!outFilePath	outFilePath isNil ifTrue: [outFilePath := self defaultOutFilePath].	^outFilePath! !!DlFileStreamOutputter methodsFor: 'accessing' stamp: 'MU 1/3/1999 01:51'!outFilePath: aValue	outFilePath := aValue! !!DlFileStreamOutputter methodsFor: 'accessing' stamp: 'MU 2/7/1999 19:09'!outRootPathArray	outRootPathArray isNil ifTrue: [outRootPathArray := self defaultOutRootPathArray].	^outRootPathArray! !!DlFileStreamOutputter methodsFor: 'accessing' stamp: 'M.U 5/5/1999 20:56'!outRootPathArray: aValue	"need to re-calculate outFilePath"	outRootPathArray := aValue.	self outFilePath: nil. ! !!DlFileStreamOutputter methodsFor: 'factory' stamp: 'MU 1/4/1999 01:10'!defaultFileStreamClass	^CrLfFileStream! !!DlFileStreamOutputter methodsFor: 'factory' stamp: 'M.U 5/5/1999 21:09'!defaultOutFilePath		^(DlPortableFilePath with: (self outRootPathArray)) beDirectoryPath.! !!DlFileStreamOutputter methodsFor: 'factory' stamp: 'MU 2/7/1999 19:09'!defaultOutRootPathArray	^#('dandelionOutput')! !!DlFileStreamOutputter methodsFor: 'testing' stamp: 'MU 10/6/2000 23:38'!shouldClearPreviousOutput	^self properties at: #clearPreviousOutput! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlFileStreamOutputter class	instanceVariableNames: ''!!DlFileStreamOutputter class methodsFor: 'property' stamp: 'MU 10/6/2000 23:39'!defaultProperties	"	* clearPreviousOutput (Array of: String) - clear previousOutput or not	"	^super defaultProperties		at: #clearPreviousOutput put: true;		yourself.! !