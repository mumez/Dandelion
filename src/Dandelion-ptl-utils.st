Object subclass: #DlPetalQuidMaker	instanceVariableNames: 'highValue lowValue highValueCounter'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-ptl-utils'!!DlPetalQuidMaker commentStamp: '<historical>' prior: 0!I generate QUID (Petal internal id for model elements).Since Petal format specification is not available in public, my QUID generation algorism is just a guess work. ;->#creator[:masashi | ^umezawa] #version 0.1!!DlPetalQuidMaker methodsFor: 'initialize-release' stamp: 'M.U 6/6/1999 00:58'!initialize	highValueCounter := 0.! !!DlPetalQuidMaker methodsFor: 'actions' stamp: 'M.U 6/6/1999 00:56'!nextValue	^self nextHighValue , self nextLowValue! !!DlPetalQuidMaker methodsFor: 'private' stamp: 'M.U 6/6/1999 01:16'!nextHighValue	self highValueCounter: self highValueCounter + 1.	self highValueCounter > 99		ifTrue: 			[self highValueCounter: 0.			self highValue: self privNextValue].	^ self highValue.! !!DlPetalQuidMaker methodsFor: 'private' stamp: 'M.U 6/6/1999 01:02'!nextLowValue	self lowValue: self privNextValue.	^ self lowValue.! !!DlPetalQuidMaker methodsFor: 'private' stamp: 'MU 8/19/2000 20:47'!privNextValue	| sz str |	sz := 6.	str := String new: sz.	1 to: sz do:[ :idx |	str at: idx put: 15 atRandom asHexDigit]. 	^str		! !!DlPetalQuidMaker methodsFor: 'accessing' stamp: 'M.U 6/6/1999 01:04'!highValue	highValue isNil ifTrue:[ highValue := self privNextValue. ].	^highValue! !!DlPetalQuidMaker methodsFor: 'accessing' stamp: 'M.U 6/6/1999 00:49'!highValue: aValue	highValue := aValue! !!DlPetalQuidMaker methodsFor: 'accessing' stamp: 'M.U 6/6/1999 00:58'!highValueCounter	^highValueCounter! !!DlPetalQuidMaker methodsFor: 'accessing' stamp: 'M.U 6/6/1999 00:58'!highValueCounter: aValue	highValueCounter := aValue! !!DlPetalQuidMaker methodsFor: 'accessing' stamp: 'M.U 6/6/1999 01:04'!lowValue	lowValue isNil ifTrue:[ lowValue := self privNextValue. ].	^lowValue! !!DlPetalQuidMaker methodsFor: 'accessing' stamp: 'M.U 6/6/1999 00:49'!lowValue: aValue	lowValue := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPetalQuidMaker class	instanceVariableNames: ''!!DlPetalQuidMaker class methodsFor: 'instance creation' stamp: 'M.U 6/6/1999 23:54'!default	^ DlDefaultInstanceFactory default createInstanceOf: self! !!DlPetalQuidMaker class methodsFor: 'instance creation' stamp: 'M.U 6/6/1999 00:41'!new	^super new initialize! !Object subclass: #DlPetalUnnamedCounter	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-ptl-utils'!!DlPetalUnnamedCounter commentStamp: '<historical>' prior: 0!I count 'UNNAMED' petal element.Mainly used for generating Petal Associations.#creator[:masashi | ^umezawa] #version 0.1!!DlPetalUnnamedCounter methodsFor: 'initialize-release' stamp: 'MU 8/20/2000 23:53'!initialize	value := -1.! !!DlPetalUnnamedCounter methodsFor: 'actions' stamp: 'MU 8/20/2000 23:53'!next	value := value + 1.	^value! !!DlPetalUnnamedCounter methodsFor: 'actions' stamp: 'MU 8/20/2000 23:56'!nextUnnamedString	"For stupid Rose name-less Role management"	^'$UNNAMED$', self next printString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPetalUnnamedCounter class	instanceVariableNames: ''!!DlPetalUnnamedCounter class methodsFor: 'instance creation' stamp: 'MU 8/20/2000 23:52'!default	^ DlDefaultInstanceFactory default createInstanceOf: self! !!DlPetalUnnamedCounter class methodsFor: 'instance creation' stamp: 'MU 8/20/2000 23:51'!new	^super new initialize! !DlWrapStream subclass: #DlPetalWriteStream	instanceVariableNames: 'indentDepth'	classVariableNames: 'CrChar EscapeChar LfChar LnEndChar LnStartChar MultiLineSuggestChars NonCharTable ParenChar ParenEndChar Platform QuotChar SpaceChar TabChar'	poolDictionaries: ''	category: 'Dandelion-ptl-utils'!!DlPetalWriteStream commentStamp: '<historical>' prior: 0!I am a customized WriteStream for writing Petal files.#creator[:masashi | ^umezawa] #version 0.1!!DlPetalWriteStream methodsFor: 'write stream mocking' stamp: 'MU 8/13/2000 23:45'!cr	self ln! !!DlPetalWriteStream methodsFor: 'write stream mocking' stamp: 'MU 8/13/2000 23:47'!space	self stream space! !!DlPetalWriteStream methodsFor: 'write stream mocking' stamp: 'MU 8/13/2000 23:47'!tab	self stream tab! !!DlPetalWriteStream methodsFor: 'writing petal' stamp: 'MU 9/3/2000 00:38'!crKey: key type: listTypeName list: aCollectionOnPetalElement 	(aCollectionOnPetalElement isNil or: [aCollectionOnPetalElement isEmpty])		ifTrue: [^ self].	self cr.	self nextPutAll: key.	self tab.	self paren.	self nextPutAll: 'list '.	self nextPutAll: listTypeName.	self incIndent.	self petalPutAll: aCollectionOnPetalElement.	self decIndent.	self parenEnd! !!DlPetalWriteStream methodsFor: 'writing petal' stamp: 'MU 9/3/2000 00:38'!crKey: key value: value 	(value isNil		or: [value isCollection and: [value isEmpty]])		ifTrue: [^ self].	self cr.	self nextPutAll: key.	self tab.	self value: value! !!DlPetalWriteStream methodsFor: 'writing petal' stamp: 'MU 9/3/2000 00:42'!key: key type: listTypeName list: aCollectionOnPetalElement 	(aCollectionOnPetalElement isNil or: [aCollectionOnPetalElement isEmpty])		ifTrue: [^ self].	self tab.	self nextPutAll: key.	self tab.	self paren.	self nextPutAll: 'list '.	self nextPutAll: listTypeName.	self incIndent.	self petalPutAll: aCollectionOnPetalElement.	self decIndent.	self parenEnd! !!DlPetalWriteStream methodsFor: 'writing petal' stamp: 'MU 9/3/2000 00:42'!key: key value: value 	(value isNil		or: [value isCollection and: [value isEmpty]])		ifTrue: [^ self].	self tab.	self nextPutAll: key.	self tab.	self value: value! !!DlPetalWriteStream methodsFor: 'writing petal' stamp: 'MU 8/27/2000 01:43'!petalPut: aDlPetalElement	aDlPetalElement printPetalOn: self indent: self indentDepth! !!DlPetalWriteStream methodsFor: 'writing petal' stamp: 'M.U 6/7/1999 00:27'!petalPutAll: aCollectionOfDlPetalElement	aCollectionOfDlPetalElement do:[:each | self petalPut: each].! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'mu 1/4/2001 01:31'!commentPutAll: aString 	1 to: aString size do: [:idx | | asciiValue |	asciiValue := (aString at: idx) asciiValue.	(NonCharTable includesKey: asciiValue)			ifTrue: [aString at: idx put: (NonCharTable at: asciiValue)]].	(self isMultiLineComment: aString)		ifTrue: [self longQuote: aString]		ifFalse: [self quote: aString]! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'M.U 5/15/1999 20:35'!ln	self stream nextPut: LnEndChar.	self indent.! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'mu 1/3/2001 23:44'!longQuote: aString 	| indentDepthStore readStr next |	indentDepthStore := self indentDepth.	self indentDepth: 0.	self ln; ls.	readStr := ReadStream on: aString.	[readStr atEnd]		whileFalse: 			[next := readStr next.			((next == CrChar) or:[(next == LfChar)])					ifTrue:[self ln. self ls. (readStr peek == Character lf) ifTrue:[readStr skip:1]]					ifFalse: [self nextPut: next.]			].	self ln.	self indentDepth: indentDepthStore! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'M.U 5/15/1999 20:35'!ls	self stream nextPut: LnStartChar.	! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'M.U 5/15/1999 19:38'!paren	self stream nextPut: ParenChar! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'M.U 5/15/1999 19:39'!parenEnd	self stream nextPut: ParenEndChar! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'M.U 5/15/1999 19:39'!quot	self stream nextPut: QuotChar! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'MU 11/21/2001 12:14'!quote: aString 	self quot.	aString do: 		[:eachChar | 		eachChar == EscapeChar ifTrue: [self stream nextPut: EscapeChar].		self stream nextPut: eachChar].	self quot! !!DlPetalWriteStream methodsFor: 'writing petal-primitive' stamp: 'MU 10/2/2000 00:02'!value: aStringOrNumberOrBooleanOrPetalElement 	"We need isString!!"	(aStringOrNumberOrBooleanOrPetalElement isKindOf: String)		ifTrue: [^ self commentPutAll: aStringOrNumberOrBooleanOrPetalElement].	aStringOrNumberOrBooleanOrPetalElement isNumber ifTrue: [^ self nextPutAll: aStringOrNumberOrBooleanOrPetalElement printString].	(aStringOrNumberOrBooleanOrPetalElement isKindOf: Boolean)		ifTrue: [^ aStringOrNumberOrBooleanOrPetalElement				ifTrue: [self nextPutAll: 'TRUE']				ifFalse: [self nextPutAll: 'FALSE']].	(aStringOrNumberOrBooleanOrPetalElement isKindOf: DlPetalElement)		ifTrue: [^ self nextPutAll: aStringOrNumberOrBooleanOrPetalElement petalString].	"last resort"	self commentPutAll: aStringOrNumberOrBooleanOrPetalElement printString! !!DlPetalWriteStream methodsFor: 'indenting' stamp: 'M.U 5/15/1999 19:20'!indent	self indentDepth timesRepeat: [self tab].! !!DlPetalWriteStream methodsFor: 'actions' stamp: 'MU 8/13/2000 23:49'!decIndent	self indentDepth: self indentDepth - 1.! !!DlPetalWriteStream methodsFor: 'actions' stamp: 'MU 8/27/2000 01:57'!incIndent	self indentDepth: self indentDepth + 1.! !!DlPetalWriteStream methodsFor: 'accessing' stamp: 'M.U 5/15/1999 18:51'!indentDepth	indentDepth isNil ifTrue:[ indentDepth := 0].	^indentDepth! !!DlPetalWriteStream methodsFor: 'accessing' stamp: 'M.U 5/15/1999 18:50'!indentDepth: aValue	indentDepth := aValue! !!DlPetalWriteStream methodsFor: 'testing' stamp: 'mu 1/4/2001 01:16'!isMultiLineComment: aString 	^ aString includesAnyOf: MultiLineSuggestChars		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPetalWriteStream class	instanceVariableNames: ''!!DlPetalWriteStream class methodsFor: 'class initialization' stamp: 'M.U 5/15/1999 20:23'!initForPlatform	"Just a mimic of CrLfFileStream class >> guessDefaultLineEndConvention"	"I hope more sophisticated way is provided from Squeak"		| delim |	delim := FileDirectory pathNameDelimiter.	delim = $: ifTrue:[LnEndChar := Character cr. Platform := #mac].	delim = $/ ifTrue:[LnEndChar := Character lf. Platform := #unix].	delim = $\ ifTrue:[LnEndChar := Character cr. Platform := #win].	! !!DlPetalWriteStream class methodsFor: 'class initialization' stamp: 'mu 1/4/2001 01:18'!initMultiLineSuggestChars		MultiLineSuggestChars := Array with: CrChar with: LfChar with: QuotChar! !!DlPetalWriteStream class methodsFor: 'class initialization' stamp: 'mu 1/4/2001 00:58'!initNonCharTable	| regBlock |	"DlPetalWriteStream initNonCharTable"	"Init translation table for not acceptable charatcers"	NonCharTable := Dictionary new.	regBlock := [:idx | NonCharTable at: idx put: $?].	0 to: 8 do: regBlock.	11 to: 12 do: regBlock.	14 to: 31 do: regBlock.		NonCharTable at: 127 put: $?	! !!DlPetalWriteStream class methodsFor: 'class initialization' stamp: 'MU 11/21/2001 12:07'!initialize	"DlPetalWriteStream initialize"	CrChar := Character cr.	LfChar := Character lf.	SpaceChar := Character space.	TabChar := Character tab.	ParenChar := $(.	ParenEndChar := $).	QuotChar := $".	LnStartChar := $|.	EscapeChar := $\.		self initMultiLineSuggestChars.	self initNonCharTable.	self initForPlatform! !!DlPetalWriteStream class methodsFor: 'examples' stamp: 'MU 9/29/2000 00:28'!example1	| stream petalObject |	Transcript cr; show: 'test start'; cr.	stream := DlPetalWriteStream wrap: Transcript.	petalObject := DlPetalHeader new.	stream petalPut: petalObject.	stream close.	Transcript cr; show: 'test end'; cr.! !DlPetalWriteStream initialize!