Object subclass: #DlPetalElementInitializer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter-ptl'!!DlPetalElementInitializer commentStamp: '<historical>' prior: 0!I just initialize Petal-generation related objects.#creator[:masashi | ^umezawa] #version 0.1!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPetalElementInitializer class	instanceVariableNames: ''!!DlPetalElementInitializer class methodsFor: 'actions' stamp: 'MU 10/7/2000 00:33'!initElements	DlPetalClassCategory initialize.	DlPetalUnnamedCounter default initialize.	! !DlProperties subclass: #DlPetalOutputProperties	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter-ptl'!!DlPetalOutputProperties commentStamp: '<historical>' prior: 0!Below properties can be set. see each method for detailstype properties:#(primitiveTypes)file properties:#(petalFilename petalSuffix)"primitiveTypes" determines whether a type inferred element is generated as Attribute or UnidirectionalAssociation.You can customize what type should be generated as Attribute ( or UnidirectionalAssociation) by changing this primitiveTypes values.#creator[:masashi | ^umezawa] #version 0.5 M.U!!DlPetalOutputProperties methodsFor: 'type properties' stamp: 'MU 12/3/2000 01:48'!primitiveTypes	^self at: #primitiveTypes ifAbsentPutValue: self class primitiveTypes! !!DlPetalOutputProperties methodsFor: 'file properties' stamp: 'MU 12/3/2000 01:42'!petalFilename	^self at: #petalFilename ifAbsentPutValue: 'reversed'! !!DlPetalOutputProperties methodsFor: 'file properties' stamp: 'MU 12/3/2000 01:41'!petalSuffix	^self at: #petalSuffix ifAbsentPutValue: '.ptl'! !!DlPetalOutputProperties methodsFor: 'petal properties' stamp: 'MU 11/21/2001 11:36'!unresolvedClassCategoryName	^self at: #unresolvedClassCategoryName ifAbsentPutValue: DlPetalClassCategory defaultUnresolvedName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPetalOutputProperties class	instanceVariableNames: 'primitiveTypes'!!DlPetalOutputProperties class methodsFor: 'accessing' stamp: 'MU 12/3/2000 01:47'!primitiveTypes	primitiveTypes isNil ifTrue:[primitiveTypes := self defaultPrimitiveTypes].	^primitiveTypes! !!DlPetalOutputProperties class methodsFor: 'accessing' stamp: 'MU 12/3/2000 01:46'!primitiveTypes: anArray	primitiveTypes := anArray! !!DlPetalOutputProperties class methodsFor: 'factory' stamp: 'MU 12/3/2000 01:46'!defaultPrimitiveTypes	^#(		#True #False #UndefinedObject 		#Date #Time		#Float #Fraction #Integer #LargeNegativeInteger #LargePositiveInteger #Number #Random #SmallInteger		#ArrayedCollection #Collection #SequenceableCollection		#Bag #Dictionary #IdentityDictionary #IdentitySet #PluggableDictionary #PluggableSet #Set		#Heap #Interval #LinkedList #MappedCollection #OrderedCollection #SharedQueue #SortedCollection		#Character #CharacterSet #String #Symbol #Text		#Array #Array2D #ByteArray #FloatArray #IntegerArray #RunArray #WordArray		#ReadStream #ReadWriteStream #Stream #WriteStream		#WeakArray #WeakKeyDictionary #WeakRegistry #WeakValueDictionary		#Association #Link #LookupKey #WeakKeyAssociation #WeakValueAssociation		#Point #Quadrangle #Rectangle		#Color	)! !DlConvertibleOutputter subclass: #DlPetalOutputter	instanceVariableNames: 'classCategoriesDict classesDict generatedClasses'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter-ptl'!!DlPetalOutputter commentStamp: '<historical>' prior: 0!I write class category contents in Petal format.#creator[:masashi | ^umezawa] #version 0.1!!DlPetalOutputter methodsFor: 'actions-output' stamp: 'MU 11/21/2001 11:33'!outputClassCategories	| props suffix petalFileName |	props := self properties.	suffix := props petalSuffix.	petalFileName := self petalFilename.	self initPetalElements.	self preparePetalElementCache.		DlPetalClassCategory unresolved name: props unresolvedClassCategoryName.		[self outStreamNamed: petalFileName , Time dateAndTimeNow printString , suffix.	self writePetal.]		ensure: [self closeStream].		self clearPetalElementCache! !!DlPetalOutputter methodsFor: 'actions-writing' stamp: 'MU 9/30/2000 22:28'!writeClassCategories	self analysisStorage getAllClassCategories do: [:each | self writeClassCategoryFor: each]! !!DlPetalOutputter methodsFor: 'actions-writing' stamp: 'mu 12/31/2000 23:22'!writePetal	self writePetalHeader.	self writeClassCategories.	self writeUnresolvedClasses.! !!DlPetalOutputter methodsFor: 'actions-writing' stamp: 'MU 9/29/2000 00:38'!writePetalHeader	DlPetalHeader new printPetalOn: self outStream! !!DlPetalOutputter methodsFor: 'actions-writing' stamp: 'MU 10/9/2000 11:43'!writeUnresolvedClasses	DlPetalClassCategory unresolved printPetalOn: self outStream.! !!DlPetalOutputter methodsFor: 'factory-Petal' stamp: 'MU 10/9/2000 12:49'!classAttributeOn: aDlAnalyzableLocalScopeVariable kind: aSymbol 	| att |	att := DlPetalClassAttribute named: aDlAnalyzableLocalScopeVariable name.	(aSymbol == #class or: [aSymbol == #classInst])		ifTrue: [att beStatic].	aSymbol == #classInst ifTrue: [att stereotype: 'classInstance'].	att type: aDlAnalyzableLocalScopeVariable type.	att initv: aDlAnalyzableLocalScopeVariable initialValue.	^ att! !!DlPetalOutputter methodsFor: 'factory-Petal' stamp: 'mu 12/31/2000 00:28'!classCategoryOn: aDlAnalyzableClassCategory 	| pcat |	pcat := self classCategoriesDict at: aDlAnalyzableClassCategory.	aDlAnalyzableClassCategory classes do: [:each | pcat addClass: (self classOn: each)].	^ pcat! !!DlPetalOutputter methodsFor: 'factory-Petal' stamp: 'mu 1/1/2001 01:35'!classOn: aDlAnalyzableClass 	| pcls |	pcls := self classesDict at: aDlAnalyzableClass ifAbsentPut: [(DlPetalClass named: aDlAnalyzableClass name) beInUnresolvedCategory].	(aDlAnalyzableClass isResolved and: [(self generatedClasses includes: pcls) not])		ifTrue: [self setPetalClass: pcls by: aDlAnalyzableClass].	^ pcls! !!DlPetalOutputter methodsFor: 'factory-Petal' stamp: 'mu 12/31/2000 01:20'!operationOn: aDlAnalyzableMethod static: aBoolean 	| pOpe |	pOpe := DlPetalOperation named: aDlAnalyzableMethod name.	aBoolean ifTrue: [pOpe beStatic].	self setPetalOperation: pOpe by: aDlAnalyzableMethod.	^pOpe.! !!DlPetalOutputter methodsFor: 'factory-private' stamp: 'MU 10/9/2000 12:27'!addClassAttributesTo: aDlPetalClass using: aDlAnalyzableClass 	| cls |	cls := aDlPetalClass.	aDlAnalyzableClass instVariables do: [:each | (each hasType and: [(self typeIsPrimitive: each type) not])			ifTrue: [self addUnidirectionalAssociationTo: cls using: each]			ifFalse: [cls addClassAttribute: (self classAttributeOn: each kind: #inst)]].	aDlAnalyzableClass classVariables do: [:each | cls addClassAttribute: (self classAttributeOn: each kind: #class)].	aDlAnalyzableClass classInstVariables do: [:each | cls addClassAttribute: (self classAttributeOn: each kind: #classInst)]! !!DlPetalOutputter methodsFor: 'factory-private' stamp: 'mu 12/31/2000 01:14'!addOperationsTo: aDlPetalClass using: aDlAnalyzableClass	| pcls |	pcls := aDlPetalClass.	aDlAnalyzableClass instMethods do: [:each |		pcls addOperation: (self operationOn: each static: false).	].	aDlAnalyzableClass classMethods do: [:each |		pcls addOperation: (self operationOn: each static: true).	].	! !!DlPetalOutputter methodsFor: 'factory-private' stamp: 'MU 10/9/2000 12:49'!addUnidirectionalAssociationTo: aDlPetalClass using: aDlAnalyzableLocalScopeVariable 	| var targetCls |	var := aDlAnalyzableLocalScopeVariable.	targetCls := self findAnalyzableClassTyped: var type.	targetCls isNil ifFalse: [aDlPetalClass addUnidirectionalAssociationTo: (self classesDict at: targetCls)			roleNamed: var name]! !!DlPetalOutputter methodsFor: 'cache mgmt' stamp: 'MU 10/9/2000 01:37'!clearPetalElementCache	classCategoriesDict := classesDict := nil! !!DlPetalOutputter methodsFor: 'cache mgmt' stamp: 'MU 10/9/2000 12:05'!preparePetalElementCache	self analysisStorage getAllClassCategories do: 		[:eachCat | 		| pCat | 		pCat := DlPetalClassCategory named: eachCat name.		self classCategoriesDict at: eachCat put: pCat.		eachCat classes do: 			[:eachCls | 			| pCls | 			pCls := DlPetalClass named: eachCls name.			pCls container: pCat.			self classesDict at: eachCls put: pCls]].! !!DlPetalOutputter methodsFor: 'accessing' stamp: 'MU 10/7/2000 01:34'!classCategoriesDict	classCategoriesDict isNil ifTrue:[ classCategoriesDict := Dictionary new].	^classCategoriesDict! !!DlPetalOutputter methodsFor: 'accessing' stamp: 'MU 10/4/2000 00:22'!classCategoriesDict: aDictionary	classCategoriesDict := aDictionary! !!DlPetalOutputter methodsFor: 'accessing' stamp: 'MU 10/7/2000 01:34'!classesDict	classesDict isNil ifTrue:[ classesDict := Dictionary new].	^classesDict! !!DlPetalOutputter methodsFor: 'accessing' stamp: 'MU 10/2/2000 23:14'!classesDict: aDictionary	classesDict := aDictionary! !!DlPetalOutputter methodsFor: 'accessing' stamp: 'MU 12/3/2000 03:02'!generatedClasses	generatedClasses isNil ifTrue:[ generatedClasses := Set new].	^generatedClasses! !!DlPetalOutputter methodsFor: 'private' stamp: 'MU 10/9/2000 02:05'!findAnalyzableClassTyped: aTypeName	^self analysisStorage getAllClasses detect:[:each | each name = aTypeName] ifNone:[]	! !!DlPetalOutputter methodsFor: 'private' stamp: 'MU 10/7/2000 00:52'!initPetalElements	DlPetalElementInitializer initElements! !!DlPetalOutputter methodsFor: 'private' stamp: 'mu 1/3/2001 23:25'!petalFilename	^self properties petalFilename.! !!DlPetalOutputter methodsFor: 'private' stamp: 'mu 11/20/2001 23:08'!setPetalClass: aPetalClass by: aDlAnalyzableClass 	| pcls supercls |	pcls := aPetalClass.	aDlAnalyzableClass minorKey isNil ifFalse:[pcls stereotype: aDlAnalyzableClass minorKey].	pcls documentation: aDlAnalyzableClass comment asString.	supercls := aDlAnalyzableClass superclass.	supercls isNil ifFalse:[ pcls addSuperclass: (self classOn: supercls)].	self addClassAttributesTo: pcls using: aDlAnalyzableClass.	self addOperationsTo: pcls using: aDlAnalyzableClass.	self generatedClasses add: pcls.	^ pcls! !!DlPetalOutputter methodsFor: 'private' stamp: 'mu 1/4/2001 01:58'!setPetalOperation: aPetalOperation by: aDlAnalyzableMethod 	| pOpe |	pOpe := aPetalOperation.	aDlAnalyzableMethod minorKey isNil ifFalse: [pOpe stereotype: aDlAnalyzableMethod minorKey].	aDlAnalyzableMethod arguments do: [:each | pOpe addParameter: (DlPetalParameter named: each)].	aDlAnalyzableMethod isPrivate ifTrue: [pOpe opExportControl: 'Protected'].	pOpe protocol: aDlAnalyzableMethod category name.	pOpe documentation: aDlAnalyzableMethod comment.	^ pOpe! !!DlPetalOutputter methodsFor: 'private' stamp: 'MU 12/3/2000 01:51'!typeIsPrimitive: aTypeName 	^ (self properties primitiveTypes)		includes: aTypeName! !!DlPetalOutputter methodsFor: 'private' stamp: 'mu 1/1/2001 02:08'!writeClassCategoryFor: aDlAnalyzableClassCategory	| cat |	cat := self classCategoryOn: aDlAnalyzableClassCategory.	cat printPetalOn: self outStream	! !!DlPetalOutputter methodsFor: 'converting' stamp: 'mu 12/31/2000 23:38'!asChangeSetOutputter	^self as: DlPetalChangeSetOutputter! !!DlPetalOutputter methodsFor: 'factory' stamp: 'mu 12/31/2000 00:23'!defaultActionSequence	^#(	#outputClassCategories	).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlPetalOutputter class	instanceVariableNames: ''!!DlPetalOutputter class methodsFor: 'property' stamp: 'MU 12/3/2000 01:39'!defaultProperties	^ DlPetalOutputProperties new inherit: super defaultProperties! !DlPetalOutputter subclass: #DlPetalChangeSetOutputter	instanceVariableNames: 'removedClassCategoriesDict removedClassesDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-outputter-ptl'!!DlPetalChangeSetOutputter commentStamp: '<historical>' prior: 0!I write changeSet contents in Petal format.#creator[:masashi | ^umezawa] #version 0.1!!DlPetalChangeSetOutputter methodsFor: 'actions-writing' stamp: 'mu 1/2/2001 01:54'!writePetal	super writePetal.	self writeRemovedElements! !!DlPetalChangeSetOutputter methodsFor: 'actions-writing' stamp: 'mu 1/3/2001 23:27'!writeRemovedClasses	| cha clsSetter |	cha := self changeSet.	clsSetter := 			[:each | 			| pCls | 			pCls := DlPetalClass named: each name.			pCls stereotype: each minorKey.			(self removedClassCategoriesDict includesKey: each category)				ifTrue: [(self removedClassCategoriesDict at: each category)						addClass: pCls]				ifFalse: [DlPetalClassCategory removed addClass: pCls]].	cha removedClasses do: clsSetter.	cha addedThenRemovedClasses do: clsSetter! !!DlPetalChangeSetOutputter methodsFor: 'actions-writing' stamp: 'mu 1/2/2001 01:54'!writeRemovedElements	self writeRemovedClasses.	self writeRemovedOperations.	DlPetalClassCategory removed printPetalOn: self outStream! !!DlPetalChangeSetOutputter methodsFor: 'actions-writing' stamp: 'mu 1/3/2001 23:27'!writeRemovedOperations	| cha |	cha := self changeSet.	(cha removedInstMethods, cha removedClassMethods) do: 		[:each | 		| pOpe pCls | 		pOpe := DlPetalOperation named: each name.		pOpe stereotype: each minorKey.		pCls := self removedClassesDict at: each klass.		pCls addOperation: pOpe].	(cha addedThenRemovedInstMethods, cha addedThenRemovedClassMethods) do: 		[:each | 		| pOpe pCls | 		pOpe := DlPetalOperation named: each name.		pOpe beStatic.		pOpe stereotype: each minorKey.		pCls := self removedClassesDict at: each klass.		pCls addOperation: pOpe].! !!DlPetalChangeSetOutputter methodsFor: 'accessing' stamp: 'mu 1/2/2001 00:25'!removedClassCategoriesDict	removedClassCategoriesDict isNil ifTrue:[ removedClassCategoriesDict := Dictionary new].	^removedClassCategoriesDict! !!DlPetalChangeSetOutputter methodsFor: 'accessing' stamp: 'mu 1/2/2001 00:25'!removedClassCategoriesDict: aValue	removedClassCategoriesDict := aValue! !!DlPetalChangeSetOutputter methodsFor: 'accessing' stamp: 'mu 1/2/2001 00:26'!removedClassesDict	removedClassesDict isNil ifTrue:[ removedClassesDict := Dictionary new].	^removedClassesDict! !!DlPetalChangeSetOutputter methodsFor: 'accessing' stamp: 'mu 1/2/2001 00:25'!removedClassesDict: aValue	removedClassesDict := aValue! !!DlPetalChangeSetOutputter methodsFor: 'cache mgmt' stamp: 'mu 1/2/2001 00:30'!clearPetalElementCache	removedClassCategoriesDict := removedClassesDict := nil.	super clearPetalElementCache.! !!DlPetalChangeSetOutputter methodsFor: 'cache mgmt' stamp: 'mu 1/3/2001 23:27'!preparePetalElementCache	| cha classDictRegister |	super preparePetalElementCache.	cha := self changeSet.	classDictRegister := 			[:eachMethod | 			| cls | 			cls := eachMethod klass.			(self removedClassesDict includesKey: cls)				ifFalse: 					[| pCls | 					pCls := DlPetalClass named: cls name.					self removedClassesDict at: cls put: pCls]].	cha removedInstMethods do: classDictRegister.	cha removedClassMethods do: classDictRegister.	cha addedThenRemovedInstMethods do: classDictRegister.	cha addedThenRemovedClassMethods do: classDictRegister.	self removedClassesDict		keysAndValuesDo: 			[:eachCls :eachPCls | 			| cat | 			cat := eachCls category.			(self removedClassCategoriesDict includesKey: cat)				ifFalse: 					[| pCat | 					pCat := DlPetalClassCategory named: cat name.					self removedClassCategoriesDict at: cat put: pCat].			(self removedClassCategoriesDict at: eachCls category)				addClass: eachPCls].	self removedClassCategoriesDict valuesDo: [:eachCat | DlPetalClassCategory removed addCategory: eachCat]! !!DlPetalChangeSetOutputter methodsFor: 'private' stamp: 'mu 1/3/2001 23:26'!changeSet	"Currently assuming only one changeSet"	^self analysisStorage getAllChangeSets first.! !!DlPetalChangeSetOutputter methodsFor: 'private' stamp: 'mu 1/3/2001 23:26'!petalFilename	^self changeSet name.! !