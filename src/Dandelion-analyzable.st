DlPropertyObject subclass: #DlAbstractAnalyzable	instanceVariableNames: 'target name scopeSpecifier comment isValid isStorable isResolved isResolveStarter isAnalyzed analysisStrategy introspector resolveStrategy analysisStorage eventServer taggedValues key minorKey'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAbstractAnalyzable commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk code element.Analysis process will begin by sending #analyze to me.I delegate the actual analysis process to DlAnalysisStrategy.#annotaioninstance variables: target <Object> analyzable Smalltalk element name <Symbol> unique name of analyzabe Smalltalk element scopeSpecifier <Object> used when the name is in some name scope comment <String> some comment of analyzable element isValid <Boolean>  isStorable <Boolean>  isResolved <Boolean>  isResolveStarter <Boolean>  isAnalyzed <Boolean>  analysisStrategy <DlAbstractAnalysisStrategy> actual analyzer introspector <DlAbstractIntrospector> resolveStrategy <DlAbstractAnalyzableResolveStrategy> eventServer <DlEventServer> used for generating analysis events taggedValues  <IdentityDictionary> used if the analyzable element wants to have special values key <DlKey> minorKey <Symbol>class instance variables: typeKey <DlKey> #creator[:masashi | ^umezawa] #version 0.5!!DlAbstractAnalyzable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:27'!initRelatives	"abstract analyzable has no relatives"	! !!DlAbstractAnalyzable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:16'!initStrategies	analysisStrategy := resolveStrategy := nil	! !!DlAbstractAnalyzable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:16'!initTaggedValues	taggedValues := nil	! !!DlAbstractAnalyzable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:26'!initValues	comment := nil	! !!DlAbstractAnalyzable methodsFor: 'initialize-release' stamp: 'M.U 1/30/2000 20:34'!initialize	isValid := true.	isAnalyzed := isResolved := isResolveStarter := isStorable := false.	target := name := scopeSpecifier := introspector := analysisStorage := eventServer :=  key := minorKey := nil.	self initRelatives. 	self initStrategies.	self initTaggedValues.	self initValues.	! !!DlAbstractAnalyzable methodsFor: 'analyzing' stamp: 'M.U 1/2/2000 01:04'!analyzableSize	self isResolved ifFalse: [self resolve].	^(self analysisStorage select: [:each | each isAnalyzed not]) size.	! !!DlAbstractAnalyzable methodsFor: 'analyzing' stamp: 'M.U 1/14/2000 23:14'!analyze	self isResolved ifFalse: [self resolve.].	self analysisStorage do: 		[:each | 		each analysisStrategy: self analysisStrategy.		each analyzeMe].	.! !!DlAbstractAnalyzable methodsFor: 'analyzing' stamp: 'MU 3/15/2000 00:32'!analyzeMe	self isAnalyzed		ifFalse: 			[self isAnalyzed: true.			self privAnalyze.			self fireAnalyzedEvent].! !!DlAbstractAnalyzable methodsFor: 'resolving' stamp: 'M.U 1/30/2000 20:36'!resolve	self isResolveStarter: true.	self resolveStrategy analysisStorage: self analysisStorage.	self resolveRelatives.	self resolveNext.	self isResolveStarter: nil.! !!DlAbstractAnalyzable methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:52'!resolveMoreBy: aDlAnalyzableResolveStrategy	self isResolveStarter: false.	self resolveRelativesBy: aDlAnalyzableResolveStrategy.	self resolveNext.! !!DlAbstractAnalyzable methodsFor: 'resolving' stamp: 'M.U 1/30/2000 19:43'!resolveNext		self privResolveNext! !!DlAbstractAnalyzable methodsFor: 'resolving' stamp: 'M.U 1/30/2000 21:18'!resolveRelatives	self isResolved		ifFalse: 			[self isResolved: true.			self isStorable: true.			self store. 			self privResolveRelatives.			self fireResolvedEvent].! !!DlAbstractAnalyzable methodsFor: 'resolving' stamp: 'M.U 1/30/2000 19:51'!resolveRelativesBy: aDlAnalyzableResolveStrategy	self resolveStrategy: aDlAnalyzableResolveStrategy.	self analysisStorage: aDlAnalyzableResolveStrategy analysisStorage.	self resolveRelatives! !!DlAbstractAnalyzable methodsFor: 'tagged values' stamp: 'MU 3/28/1999 22:39'!tagAt: tagkey	^self taggedValues at: tagkey ifAbsent:[]! !!DlAbstractAnalyzable methodsFor: 'tagged values' stamp: 'MU 4/8/2002 16:34'!tagAt: tagkey put: aValue	"Used for containing extra analysis information"	^self taggedValues at: tagkey put: aValue! !!DlAbstractAnalyzable methodsFor: 'tagged values' stamp: 'M.U. 9/24/1999 23:40'!tagIncludesKey: tagkey 	"Used for containing extra analysis information"	^self taggedValues includesKey: tagkey ! !!DlAbstractAnalyzable methodsFor: 'tagged values' stamp: 'MU 3/28/1999 22:39'!tagKeys	"Used for containing extra analysis information"	^self taggedValues keys! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/2/2000 19:32'!analysisStorage	analysisStorage isNil ifTrue:[ analysisStorage := self defaultAnalysisStorage].	^analysisStorage! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 9/18/1999 17:47'!analysisStorage: aValue	analysisStorage := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 12/31/1998 18:56'!analysisStrategy	analysisStrategy isNil ifTrue:[ analysisStrategy := self defaultAnalysisStrategy].	^analysisStrategy! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 12/30/1998 18:01'!analysisStrategy: aValue	analysisStrategy := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 1/5/1999 00:07'!comment	^comment! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 1/5/1999 00:07'!comment: aValue	comment := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 3/14/1999 00:19'!eventServer	eventServer isNil ifTrue:[ eventServer := self defaultEventServer].	^eventServer! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 3/14/1999 00:19'!eventServer: aValue	eventServer := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/2/2000 22:21'!introspector	introspector isNil ifTrue:[ introspector := self defaultIntrospector].	^introspector! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/3/2000 00:54'!introspector: aValue		introspector := aValue.	! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 8/30/1999 00:02'!isAnalyzed	^isAnalyzed! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 8/30/1999 00:02'!isAnalyzed: aValue		isAnalyzed := aValue.	! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/3/2000 17:37'!isResolveStarter	^isResolveStarter! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/3/2000 18:04'!isResolveStarter: aValue	isResolveStarter := aValue.	! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 10/31/1999 19:43'!isResolved	^isResolved! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 11/14/1999 20:52'!isResolved: aValue	isResolved := aValue.	! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/30/2000 20:34'!isStorable	^isStorable! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/30/2000 20:34'!isStorable: aValue		isStorable := aValue.	! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 9/18/1999 16:21'!isValid	^isValid! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 9/18/1999 16:21'!isValid: aValue		isValid := aValue.	! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 9/24/1999 23:46'!minorKey	^minorKey! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 9/24/1999 23:46'!minorKey: aValue	minorKey := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 12/26/1998 16:13'!name	^name! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 1/10/2000 23:34'!name: aValue		name := aValue.	! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 8/31/1999 23:48'!resolveStrategy	"lazy initialization"	resolveStrategy isNil ifTrue:[ resolveStrategy := self defaultResolveStrategy].	^resolveStrategy! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U. 8/31/1999 23:48'!resolveStrategy: aValue	resolveStrategy := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 12/29/1998 00:02'!scopeSpecifier	^scopeSpecifier! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 12/29/1998 00:02'!scopeSpecifier: aValue	scopeSpecifier := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 1/11/1999 00:22'!taggedValues	taggedValues isNil ifTrue: [ taggedValues := self defaultTaggedValueStorageClass new.].	^taggedValues! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'MU 1/3/1999 18:31'!taggedValues: aValue	taggedValues := aValue! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 5/1/1999 23:07'!target	^target! !!DlAbstractAnalyzable methodsFor: 'accessing' stamp: 'M.U 5/1/1999 23:07'!target: aValue	target := aValue! !!DlAbstractAnalyzable methodsFor: 'converting' stamp: 'MU 6/17/2000 22:08'!asString	^self name isNil		ifTrue: [super asString]		ifFalse: 			[self name asString]! !!DlAbstractAnalyzable methodsFor: 'printing' stamp: 'M.U. 11/22/1999 23:47'!printOn: aStream 	self name isNil		ifTrue: [super printOn: aStream]		ifFalse: 			[aStream nextPutAll: self name.			aStream space.			self scopeSpecifier isNil				ifFalse: 					[aStream nextPutAll: #%.					scopeSpecifier printOn: aStream.					aStream space].			aStream nextPut: $<.			self key printOn: aStream.			aStream nextPut: $>.			self isResolved				ifFalse: 					[aStream space.					aStream nextPutAll: #notResolved].			self isAnalyzed				ifFalse: 					[aStream space.					aStream nextPutAll: #notAnalyzed]].! !!DlAbstractAnalyzable methodsFor: 'event' stamp: 'MU 3/11/2000 19:39'!fireAnalyzedEvent	(self eventServer at: #analyzedEvent) fire: self.! !!DlAbstractAnalyzable methodsFor: 'event' stamp: 'M.U 1/16/2000 01:35'!fireResolvedEvent	(self eventServer at: #resolvedEvent) fire: self! !!DlAbstractAnalyzable methodsFor: 'factory-defaults' stamp: 'M.U 1/30/2000 21:33'!defaultAnalysisStorage	^DlAnalysisStorage new! !!DlAbstractAnalyzable methodsFor: 'factory-defaults' stamp: 'M.U 12/11/1999 16:10'!defaultAnalysisStrategy	^DlElaborateAnalysisStrategy new! !!DlAbstractAnalyzable methodsFor: 'factory-defaults' stamp: 'M.U 1/3/2000 00:06'!defaultAnalyzableCollection	^DlSortedSet new! !!DlAbstractAnalyzable methodsFor: 'factory-defaults' stamp: 'M.U 1/16/2000 02:21'!defaultEventServer	^DlDandelionEventServer default! !!DlAbstractAnalyzable methodsFor: 'factory-defaults' stamp: 'M.U 1/2/2000 22:32'!defaultIntrospector	^DlClassIntrospector on: self target! !!DlAbstractAnalyzable methodsFor: 'factory-defaults' stamp: 'M.U. 8/31/1999 23:41'!defaultResolveStrategy	^DlAnalyzableAllResolveStrategy new! !!DlAbstractAnalyzable methodsFor: 'factory-defaults' stamp: 'MU 1/11/1999 00:22'!defaultTaggedValueStorageClass	^IdentityDictionary! !!DlAbstractAnalyzable methodsFor: 'factory-relatives' stamp: 'M.U 1/30/2000 18:38'!createRelative: aElemBlock 	self resolveStrategy analysisStorage isNil ifTrue:[ self resolveStrategy analysisStorage: self analysisStorage].	^ self resolveStrategy createRelative: aElemBlock ! !!DlAbstractAnalyzable methodsFor: 'factory-relatives' stamp: 'M.U 1/30/2000 18:38'!createRelatives: aElemBlock into: analyzableCol using: elemNames 	self resolveStrategy analysisStorage isNil ifTrue:[ self resolveStrategy analysisStorage: self analysisStorage].	^self resolveStrategy createRelatives: aElemBlock into: analyzableCol using: elemNames ! !!DlAbstractAnalyzable methodsFor: 'factory-relatives' stamp: 'M.U 1/2/2000 22:44'!createRelatives: aElemBlock using: elemNames 	| analyzableCol |	analyzableCol := self defaultAnalyzableCollection.	^self createRelatives: aElemBlock into: analyzableCol using: elemNames.	! !!DlAbstractAnalyzable methodsFor: 'factory-relatives' stamp: 'M.U 1/2/2000 22:58'!newClass	| cls |	cls := self scopeSpecifier.	^ cls isNil ifFalse: [DlAnalyzableClass fromClass: cls].! !!DlAbstractAnalyzable methodsFor: 'factory-relatives' stamp: 'M.U 1/2/2000 22:58'!newGlobalRoot	"Many analyzable element's parent is simply Smalltalk.. sad.."	^DlAnalyzableGlobalRoot named: #Smalltalk! !!DlAbstractAnalyzable methodsFor: 'storage' stamp: 'M.U 12/12/1999 16:27'!remove	^self removeFrom: self analysisStorage! !!DlAbstractAnalyzable methodsFor: 'storage' stamp: 'M.U 12/12/1999 16:26'!removeFrom: aDlAnalysisStorage	^aDlAnalysisStorage remove: self! !!DlAbstractAnalyzable methodsFor: 'storage' stamp: 'M.U 10/17/1999 17:50'!retrieve	^self retrieveFrom: self analysisStorage! !!DlAbstractAnalyzable methodsFor: 'storage' stamp: 'M.U. 9/24/1999 19:58'!retrieveFrom: aDlAnalysisStorage	^aDlAnalysisStorage find: self! !!DlAbstractAnalyzable methodsFor: 'storage' stamp: 'M.U. 9/18/1999 17:50'!store	self storeTo: self analysisStorage! !!DlAbstractAnalyzable methodsFor: 'storage' stamp: 'M.U 1/11/2000 00:28'!storeTo: aDlAnalysisStorage 	aDlAnalysisStorage findIfAbsentAdd: self.! !!DlAbstractAnalyzable methodsFor: 'constants' stamp: 'MU 3/23/1999 23:49'!description	^self class description! !!DlAbstractAnalyzable methodsFor: 'constants' stamp: 'M.U. 9/24/1999 23:47'!typeKey	^self class typeKey! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'MU 1/4/1999 18:00'!<= aDlAbstractAnalyzable	^self name <= aDlAbstractAnalyzable name! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'M.U 12/5/1999 18:56'!= aDlAbstractAnalyzable 	^ (self name == aDlAbstractAnalyzable name and: [self key == aDlAbstractAnalyzable key])		and: [self scopeSpecifier == aDlAbstractAnalyzable scopeSpecifier].! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'M.U 1/4/2000 02:08'!hash	^self name hash bitXor: self key hash! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'M.U 12/4/1999 01:18'!key	^ key isNil		ifTrue: [key := self minorKey isNil						ifTrue: [self typeKey]						ifFalse: [self typeKey copyWithMinorKey: self minorKey]]		ifFalse: [key]! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'M.U 12/20/1999 00:12'!majorEquals: aDlAbstractAnalyzable 	^ (self name == aDlAbstractAnalyzable name and: [self key majorEquals: aDlAbstractAnalyzable key])		and: [self scopeSpecifier == aDlAbstractAnalyzable scopeSpecifier].! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'M.U 1/4/2000 22:25'!majorHash	^self name hash bitXor: self majorKey hash! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'M.U 1/4/2000 02:41'!majorKey	^ self key majorKey! !!DlAbstractAnalyzable methodsFor: 'comparing' stamp: 'M.U 12/4/1999 01:18'!resetKey	key := nil! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/28/1999 23:18'!isAggregate	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 10/17/1999 18:26'!isCategorizable	^false	! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 10/17/1999 18:23'!isCategory	^false	! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 12/18/1999 23:42'!isChangeSet	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/29/1999 00:10'!isClass	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/29/1999 00:10'!isClassCategory	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/28/1999 23:39'!isClassCategoryMember	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/29/1999 00:47'!isClassFeature	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/28/1999 23:39'!isClassMember	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 12/27/1999 00:21'!isGlobal	^ (self isGlobalRoot or: [self isPool])		or: [self isGlobalScopeVariable].! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 12/27/1999 00:21'!isGlobalRoot	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 4/29/1999 19:46'!isGlobalScopeVariable	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 5/3/1999 16:27'!isGlobalVariable	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 5/2/1999 19:39'!isLocalVariable	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/29/1999 00:10'!isMethod	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/29/1999 00:10'!isMethodCategory	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/28/1999 23:39'!isMethodCategoryMember	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 5/3/1999 16:25'!isPool	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'M.U 5/3/1999 16:27'!isPoolVariable	^false! !!DlAbstractAnalyzable methodsFor: 'testing' stamp: 'MU 3/29/1999 00:11'!isVariable	^false! !!DlAbstractAnalyzable methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:51'!privAnalyze	self analysisStrategy analyzeOn: self.		! !!DlAbstractAnalyzable methodsFor: 'private' stamp: 'M.U 1/10/2000 22:50'!privResolveNext	self resolveStrategy nextResolveOn: self.! !!DlAbstractAnalyzable methodsFor: 'private' stamp: 'M.U 1/3/2000 17:18'!privResolveRelatives	"default do nothing"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAbstractAnalyzable class	instanceVariableNames: 'typeKey'!!DlAbstractAnalyzable class methodsFor: 'class initialization' stamp: 'M.U 1/9/2000 23:08'!initialize	typeKey := nil.	! !!DlAbstractAnalyzable class methodsFor: 'instance creation' stamp: 'MU 12/26/1998 23:55'!named: aNameSymbol	^self named: aNameSymbol checking: false ! !!DlAbstractAnalyzable class methodsFor: 'instance creation' stamp: 'mu 1/2/2001 00:00'!named: aNameSymbol checking: aBoolean 	| nm |	nm :=  aNameSymbol isNil ifTrue: [ ^DlInstanceCreationFailed new signal] ifFalse:[aNameSymbol asSymbol.].	^ aBoolean		ifTrue: [(self isValidName: aNameSymbol)				ifTrue: [self validNew: nm]				ifFalse: [self invalidNew: nm]]		ifFalse: [self validNew: nm]! !!DlAbstractAnalyzable class methodsFor: 'instance creation' stamp: 'M.U. 9/24/1999 02:21'!named: aNameSymbol in: aScopeSpecifier	^self named: aNameSymbol in: aScopeSpecifier checking: false	! !!DlAbstractAnalyzable class methodsFor: 'instance creation' stamp: 'mu 1/2/2001 00:01'!named: aNameSymbol in: aScopeSpecifier checking: aBoolean	| nm inst |	aNameSymbol isNil ifTrue: [ ^DlInstanceCreationFailed new signal].	nm := aNameSymbol asSymbol.	inst := aBoolean		ifTrue: 			[(self isValidName: nm in: aScopeSpecifier)				ifTrue: [self validNew: nm in: aScopeSpecifier]				ifFalse: [self invalidNew: nm]]		ifFalse: [self validNew: nm in: aScopeSpecifier].	^inst	! !!DlAbstractAnalyzable class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:38'!description	"default string description of me"		^'abstract analyzable model element'  ! !!DlAbstractAnalyzable class methodsFor: 'constants' stamp: 'M.U 11/29/1999 01:09'!typeKey	typeKey isNil ifTrue:[ typeKey := DlKey named: self name ].	^typeKey! !!DlAbstractAnalyzable class methodsFor: 'accessing' stamp: 'M.U 11/29/1999 01:08'!typeKey: aDlKey	typeKey := aDlKey! !!DlAbstractAnalyzable class methodsFor: 'private' stamp: 'M.U. 9/18/1999 16:21'!invalidNew: aNameSymbol 	^ self new name: aNameSymbol;	 isValid: false.! !!DlAbstractAnalyzable class methodsFor: 'private' stamp: 'M.U. 7/12/1999 23:55'!isValidName: aNameSymbol	"override - this is subclass responsibility"	^true! !!DlAbstractAnalyzable class methodsFor: 'private' stamp: 'M.U 4/28/1999 22:44'!isValidName: aNameSymbol in: aScopeSpecifier	"override if your analyzable element may be in scope"	^self isValidName: aNameSymbol ! !!DlAbstractAnalyzable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:26'!validNew: aNameSymbol	^ self validNew: aNameSymbol in: nil ! !!DlAbstractAnalyzable class methodsFor: 'private' stamp: 'M.U 11/6/1999 01:52'!validNew: aNameSymbol in: aScopeSpecifier 	"override if aScopeSpecifier also specifies target"	^ self new name: aNameSymbol;	 scopeSpecifier: aScopeSpecifier.! !DlAbstractAnalyzable subclass: #DlAnalyzable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzable commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk code element having no children.#creator[:masashi | ^umezawa] #version 0.5!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzable class	instanceVariableNames: ''!!DlAnalyzable class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:39'!description	"default string description of me"		^'abstract analyzable model element having no children'  ! !DlAbstractAnalyzable subclass: #DlAnalyzableAggregation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableAggregation commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk element.I have child analyzables and propagate my AnalysisStragety to the children.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableAggregation methodsFor: 'testing' stamp: 'MU 3/28/1999 23:18'!isAggregate	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableAggregation class	instanceVariableNames: ''!!DlAnalyzableAggregation class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:39'!description	"default string description of me"		^'abstract analyzable model element that aggregates children'  ! !DlAnalyzableAggregation subclass: #DlAnalyzableCategory	instanceVariableNames: 'organizer categorizables'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableCategory commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk category element.(Class and method category)#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableCategory methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:19'!initRelatives	super initRelatives.	organizer := categorizables := nil.! !!DlAnalyzableCategory methodsFor: 'accessing' stamp: 'M.U 1/9/2000 23:45'!categorizables	categorizables isNil ifTrue:[ self privResolveCategorizables].	^categorizables! !!DlAnalyzableCategory methodsFor: 'accessing' stamp: 'M.U 1/2/2000 23:19'!categorizables: aValue	categorizables := aValue! !!DlAnalyzableCategory methodsFor: 'accessing' stamp: 'M.U 1/9/2000 23:45'!organizer	organizer isNil ifTrue:[ self privResolveOrganizer].	^organizer! !!DlAnalyzableCategory methodsFor: 'accessing' stamp: 'M.U 10/17/1999 18:53'!organizer: aValue	organizer := aValue! !!DlAnalyzableCategory methodsFor: 'testing' stamp: 'M.U 10/17/1999 18:27'!isCategory	^true	! !!DlAnalyzableCategory methodsFor: 'private' stamp: 'M.U 1/10/2000 01:55'!privResolveRelatives	super privResolveRelatives.	self privResolveOrganizer.	self privResolveCategorizables! !!DlAnalyzableCategory methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:37'!privResolveCategorizables	^self subclassResponsibility! !!DlAnalyzableCategory methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:37'!privResolveOrganizer	^self subclassResponsibility! !DlAnalyzableAggregation subclass: #DlAnalyzableChangeSet	instanceVariableNames: 'preamble postscript addedClasses changedClasses removedClasses addedThenRemovedClasses addedInstMethods addedClassMethods changedInstMethods changedClassMethods addedThenRemovedInstMethods addedThenRemovedClassMethods removedInstMethods removedClassMethods'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableChangeSet commentStamp: '<historical>' prior: 0!I represent a "analyzable" Smalltalk change set.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableChangeSet methodsFor: 'initialize-release' stamp: 'mu 1/1/2001 00:11'!initRelatives	super initRelatives.	addedClasses := changedClasses := removedClasses := addedThenRemovedClasses := addedInstMethods := addedClassMethods := changedInstMethods := changedClassMethods := addedThenRemovedInstMethods := addedThenRemovedClassMethods := removedInstMethods := removedClassMethods := nil.! !!DlAnalyzableChangeSet methodsFor: 'initialize-release' stamp: 'M.U 1/10/2000 17:04'!initValues	super initValues.	preamble := postscript := nil.! !!DlAnalyzableChangeSet methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:52'!privResolveNext	self resolveStrategy nextResolveChangeSetOn: self.			! !!DlAnalyzableChangeSet methodsFor: 'private' stamp: 'MU 2/14/2000 00:32'!privAnalyze	self analysisStrategy analyzeChangeSetOn: self.! !!DlAnalyzableChangeSet methodsFor: 'private' stamp: 'mu 1/1/2001 00:12'!privResolveChangeSetClasses	self privResolveAddedClasses.	self privResolveChangedClasses.	self privResolveRemovedClasses.	self privResolveAddedThenRemovedClasses! !!DlAnalyzableChangeSet methodsFor: 'private' stamp: 'M.U 1/10/2000 17:08'!privResolveChangeSetMethods	self privResolveAddedClassMethods.	self privResolveAddedInstMethods.	self privResolveAddedThenRemovedClassMethods.	self privResolveAddedThenRemovedInstMethods.	self privResolveChangedClassMethods.	self privResolveChangedInstMethods.	self privResolveRemovedClassMethods.	self privResolveRemovedInstMethods.! !!DlAnalyzableChangeSet methodsFor: 'private' stamp: 'M.U 1/10/2000 17:09'!privResolveRelatives	super privResolveRelatives.	self privResolveChangeSetClasses.	self privResolveChangeSetMethods.	! !!DlAnalyzableChangeSet methodsFor: 'factory-defaults' stamp: 'M.U 1/3/2000 00:03'!defaultIntrospector	^DlChangeSetIntrospector on: self target.! !!DlAnalyzableChangeSet methodsFor: 'factory-defaults' stamp: 'M.U 1/31/2000 00:08'!defaultResolveStrategy	^DlChangeSetResolveStrategy new! !!DlAnalyzableChangeSet methodsFor: 'testing' stamp: 'M.U 12/18/1999 23:42'!isChangeSet	^true! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'MU 12/4/2000 00:51'!privCreateClassMethodsTagged: tag	| col chgSetIs |	col := self defaultAnalyzableCollection.	chgSetIs := self introspector.	chgSetIs getTrimmedClassMethodChangesDict		keysAndValuesDo: 			[:clsName :mcDict | | cls |			cls := Smalltalk at: clsName ifAbsent: [DlObsoleteClass new name: clsName].			(mcDict keys select: [:eachMcKey | eachMcKey == tag])				do: 					[:each | 					self						createRelatives: [:elemName | (DlAnalyzableClassMethod named: elemName in: cls)								minorKey: each]						into: col						using: (chgSetIs getClassMethodNamesOf: clsName tagged: tag)]].	^ col	! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'MU 12/4/2000 01:01'!privCreateInstMethodsTagged: tag 	| col chgSetIs |	col := self defaultAnalyzableCollection.	chgSetIs := self introspector.	chgSetIs getTrimmedInstMethodChangesDict		keysAndValuesDo: 			[:clsName :mcDict | | cls |			cls := Smalltalk at: clsName ifAbsent: [nil].			(mcDict keys select: [:eachMcKey | eachMcKey == tag])				do: 					[:each | 					self						createRelatives: [:elemName | (DlAnalyzableInstMethod named: elemName in: cls)								minorKey: each]						into: col						using: (chgSetIs getInstMethodNamesOf: clsName tagged: tag)]].	^ col! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 17:01'!privResolveAddedClassMethods	self addedClassMethods: (self privCreateClassMethodsTagged: #add).		! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'MU 1/6/2001 18:30'!privResolveAddedClasses	self addedClasses: (self createRelatives: [:elemName | (DlAnalyzableClass named: elemName)				minorKey: #add]			using: self introspector getAddedClassNames).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 17:03'!privResolveAddedInstMethods	self addedInstMethods: (self privCreateInstMethodsTagged: #add).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/14/2000 23:50'!privResolveAddedThenRemovedClassMethods	self addedThenRemovedClassMethods: (self privCreateClassMethodsTagged: #addedThenRemoved).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'mu 1/1/2001 00:07'!privResolveAddedThenRemovedClasses	self addedThenRemovedClasses: (self createRelatives: [:elemName | (DlAnalyzableClass named: elemName)				minorKey: #addedThenRemoved]			using: self introspector getAddedThenRemovedClassNames).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/14/2000 23:47'!privResolveAddedThenRemovedInstMethods	self addedThenRemovedInstMethods: (self privCreateInstMethodsTagged: #addedThenRemoved).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/14/2000 23:50'!privResolveChangedClassMethods	self changedClassMethods: (self privCreateClassMethodsTagged: #change).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'MU 7/2/2000 21:53'!privResolveChangedClasses	self changedClasses: (self createRelatives: [:elemName | (DlAnalyzableClass named: elemName)				minorKey: #change]			using: self introspector getChangedClassNames).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/14/2000 23:48'!privResolveChangedInstMethods	self changedInstMethods: (self privCreateInstMethodsTagged: #change).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/14/2000 23:50'!privResolveRemovedClassMethods	self removedClassMethods: (self privCreateClassMethodsTagged: #remove).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:59'!privResolveRemovedClasses	self removedClasses: (self createRelatives: [:elemName | (DlAnalyzableClass named: elemName)				minorKey: #remove]			using: self introspector getRemovedClassNames).! !!DlAnalyzableChangeSet methodsFor: 'private-resolving' stamp: 'M.U 1/14/2000 23:48'!privResolveRemovedInstMethods	self removedInstMethods: (self privCreateInstMethodsTagged: #remove).! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedClassMethods	addedClassMethods isNil ifTrue:[ self privResolveAddedClassMethods].	^addedClassMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedClassMethods: aValue	addedClassMethods := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedClasses	addedClasses isNil ifTrue:[ self privResolveAddedClasses].	^addedClasses! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedClasses: aValue	addedClasses := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedInstMethods	addedInstMethods isNil ifTrue:[ self privResolveAddedInstMethods].	^addedInstMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedInstMethods: aValue	addedInstMethods := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedThenRemovedClassMethods	addedThenRemovedClassMethods isNil ifTrue:[ self privResolveAddedThenRemovedClassMethods].	^addedThenRemovedClassMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedThenRemovedClassMethods: aValue	addedThenRemovedClassMethods := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'mu 1/1/2001 00:05'!addedThenRemovedClasses	addedThenRemovedClasses isNil ifTrue:[ self privResolveAddedThenRemovedClasses].	^addedThenRemovedClasses! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'mu 1/1/2001 00:05'!addedThenRemovedClasses: aValue	addedThenRemovedClasses := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedThenRemovedInstMethods	addedThenRemovedInstMethods isNil ifTrue:[ self privResolveAddedThenRemovedInstMethods].	^addedThenRemovedInstMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!addedThenRemovedInstMethods: aValue	addedThenRemovedInstMethods := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!changedClassMethods	changedClassMethods isNil ifTrue:[ self privResolveChangedClassMethods].	^changedClassMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!changedClassMethods: aValue	changedClassMethods := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'MU 7/2/2000 21:52'!changedClasses	changedClasses isNil ifTrue:[ self privResolveChangedClasses].	^changedClasses! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'MU 7/2/2000 21:53'!changedClasses: aValue	changedClasses := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!changedInstMethods	changedInstMethods isNil ifTrue:[ self privResolveChangedInstMethods].	^changedInstMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!changedInstMethods: aValue	changedInstMethods := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 17:02'!postscript	^postscript! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!postscript: aValue	postscript := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 17:02'!preamble	^preamble! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!preamble: aValue	preamble := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!removedClassMethods	removedClassMethods isNil ifTrue:[ self privResolveRemovedClassMethods].	^removedClassMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!removedClassMethods: aValue	removedClassMethods := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!removedClasses	removedClasses isNil ifTrue:[ self privResolveRemovedClasses].	^removedClasses! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!removedClasses: aValue	removedClasses := aValue! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!removedInstMethods	removedInstMethods isNil ifTrue:[ self privResolveRemovedInstMethods].	^removedInstMethods! !!DlAnalyzableChangeSet methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:57'!removedInstMethods: aValue	removedInstMethods := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableChangeSet class	instanceVariableNames: ''!!DlAnalyzableChangeSet class methodsFor: 'constants' stamp: 'M.U. 7/12/1999 23:53'!description	"default string description of me"		^'change set'  ! !!DlAnalyzableChangeSet class methodsFor: 'private' stamp: 'M.U 12/6/1999 00:11'!changeSetNamed: aNameSymbol	^self changeSets detect: [:each | each name asSymbol = aNameSymbol ] ifNone:[]! !!DlAnalyzableChangeSet class methodsFor: 'private' stamp: 'M.U 12/6/1999 00:06'!changeSetNames	^self changeSets collect: [:each | each name asSymbol]. 	! !!DlAnalyzableChangeSet class methodsFor: 'private' stamp: 'M.U 12/5/1999 23:40'!changeSets	"Smalltalk implememtation specific"	^ChangeSorter gatherChangeSets 	! !!DlAnalyzableChangeSet class methodsFor: 'private' stamp: 'M.U 12/6/1999 00:09'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol. 	^self changeSetNames includes: nm! !!DlAnalyzableChangeSet class methodsFor: 'private' stamp: 'M.U 12/5/1999 23:51'!validNew: aNameSymbol	| inst |	inst := super validNew: aNameSymbol.	inst target: (self changeSetNamed: aNameSymbol ).	^ inst.! !!DlAnalyzableChangeSet class methodsFor: 'private' stamp: 'M.U 12/5/1999 23:57'!validNew: aNameSymbol in: aScopeSpecifier 	| inst |	inst := super validNew: aNameSymbol in: aScopeSpecifier.	aScopeSpecifier isNil		ifFalse: 			[inst target: (self changeSetNamed: aNameSymbol ).].	^ inst.! !!DlAnalyzableChangeSet class methodsFor: 'instance creation' stamp: 'M.U 12/6/1999 00:00'!fromChangeSet: aChangeSet	^ (self named: aChangeSet name)		target: aChangeSet.! !DlAnalyzableAggregation subclass: #DlAnalyzableClass	instanceVariableNames: 'category superclass subclasses instVariables classVariables classInstVariables instMethods classMethods instMethodCategories classMethodCategories pools declarativePools indexableInstVarType isRootClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableClass commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk class.# implements: DlCategorizable#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableClass methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:23'!initRelatives	super initRelatives.	category := superclass := subclasses := instVariables := classVariables := classInstVariables := instMethods := classMethods := instMethodCategories := classMethodCategories := pools := nil	! !!DlAnalyzableClass methodsFor: 'initialize-release' stamp: 'MU 10/7/2000 00:43'!initValues	super initValues.	indexableInstVarType := #none.	isRootClass := false.! !!DlAnalyzableClass methodsFor: 'actions' stamp: 'M.U 1/3/2000 20:55'!allSubclasses	| subs |	subs := OrderedCollection new.	(self createRelatives: [:elemName | DlAnalyzableClass named: elemName]			into: subs			using: self introspector getAllSubclassNames).	^ subs.! !!DlAnalyzableClass methodsFor: 'actions' stamp: 'M.U 1/3/2000 20:55'!allSuperclasses	| supers |	supers := OrderedCollection new.	(self createRelatives: [:elemName | DlAnalyzableClass named: elemName]			into: supers			using: self introspector getAllSuperclassNames).	^ supers.! !!DlAnalyzableClass methodsFor: 'actions' stamp: 'M.U 1/3/2000 00:57'!methodCategories	| col |	col := self defaultAnalyzableCollection.	col addAll: self instMethodCategories.	col addAll: self classMethodCategories.	^col! !!DlAnalyzableClass methodsFor: 'actions' stamp: 'M.U 1/3/2000 00:57'!variables	| col |	col := self defaultAnalyzableCollection.	col addAll: self instVariables.	col addAll: self classVariables.	col addAll: self classInstVariables.	^col! !!DlAnalyzableClass methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:54'!privResolveNext	self resolveStrategy nextResolveClassOn: self.			! !!DlAnalyzableClass methodsFor: 'testing' stamp: 'M.U 10/17/1999 18:25'!isCategorizable	^true! !!DlAnalyzableClass methodsFor: 'testing' stamp: 'MU 3/29/1999 00:13'!isClass	^true! !!DlAnalyzableClass methodsFor: 'testing' stamp: 'MU 3/28/1999 23:40'!isClassCategoryMember	^true! !!DlAnalyzableClass methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:52'!privAnalyze	self analysisStrategy analyzeClassOn: self.! !!DlAnalyzableClass methodsFor: 'private' stamp: 'M.U 1/10/2000 17:10'!privResolveRelatives	super privResolveRelatives.	self privResolveCategory.	self privResolveClassInstVariables.	self privResolveClassMethodCategories.	self privResolveClassMethods.	self privResolveClassVariables.	self privResolveInstMethodCategories.	self privResolveInstMethods.	self privResolveInstVariables.	self privResolvePools.	self privResolveSubclasses.	self privResolveSuperclass! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:30'!privResolveCategory	self category: (self createRelative: [DlAnalyzableClassCategory named: self introspector getClassCategoryName]).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:33'!privResolveClassInstVariables	self classInstVariables: (self createRelatives: [:elemName | DlAnalyzableClassInstVariable named: elemName in: self target]			using: self introspector getClassInstVarNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:31'!privResolveClassMethodCategories	self classMethodCategories: (self createRelatives: [:elemName | DlAnalyzableClassMethodCategory named: elemName in: self target]			using: self introspector getClassMethodCategoryNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:35'!privResolveClassMethods	self classMethods: (self createRelatives: [:elemName | DlAnalyzableClassMethod named: elemName in: self target]			using: self introspector getClassMethodNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:33'!privResolveClassVariables	self classVariables: (self createRelatives: [:elemName | DlAnalyzableClassVariable named: elemName in: self target]			using: self introspector getClassVarNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'mu 11/26/2003 02:39'!privResolveDeclarativePools	"declarative pools"	self declarativePools: (self createRelatives: [:elemName | DlAnalyzableDeclarativePool named: elemName in: self newGlobalRoot target]			using: self introspector getDeclarativePoolNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:53'!privResolveInstMethodCategories	self instMethodCategories: (self createRelatives: [:elemName | DlAnalyzableInstMethodCategory named: elemName in: self target.]			using: self introspector getInstMethodCategoryNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:52'!privResolveInstMethods	self instMethods: (self createRelatives: [:elemName | DlAnalyzableInstMethod named: elemName in: self target]			using: self introspector getInstMethodNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/12/2000 23:13'!privResolveInstVariables	self instVariables: (self createRelatives: [:elemName | DlAnalyzableInstVariable named: elemName in: self target]			using: self introspector getInstVarNames).	! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:34'!privResolvePools	"pools"	self pools: (self createRelatives: [:elemName | DlAnalyzablePool named: elemName in: self newGlobalRoot target]			using: self introspector getPoolNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:29'!privResolveSubclasses	"subclasses"	self subclasses: (self createRelatives: [:elemName | DlAnalyzableClass named: elemName]			using: self introspector getSubclassNames).! !!DlAnalyzableClass methodsFor: 'private-resolving' stamp: 'MU 10/7/2000 00:44'!privResolveSuperclass	| cIntro superClsName |	cIntro := self introspector.	"superclass"	superClsName := cIntro getSuperclassName.	superClsName = 'nil' ifTrue: [self isRootClass: true. "Object superclass is nil"] ifFalse: [		self superclass: (self createRelative: [DlAnalyzableClass named: superClsName])].! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!category	category isNil ifTrue:[ self privResolveCategory].	^category! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!category: aValue	category := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!classInstVariables	classInstVariables isNil ifTrue:[ self privResolveClassInstVariables].	^classInstVariables! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!classInstVariables: aValue	classInstVariables := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!classMethodCategories	classMethodCategories isNil ifTrue:[ self privResolveClassMethodCategories].	^classMethodCategories! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!classMethodCategories: aValue	classMethodCategories := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'MU 6/17/2000 23:58'!classMethods	classMethodCategories notNil ifTrue:[classMethods := classMethodCategories inject: self defaultAnalyzableCollection into:[:n :e | n addAll: e methods; yourself]].	classMethods isNil ifTrue:[ self privResolveClassMethods].	^classMethods! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!classMethods: aValue	classMethods := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!classVariables	classVariables isNil ifTrue:[ self privResolveClassVariables].	^classVariables! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!classVariables: aValue	classVariables := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'mu 11/26/2003 02:38'!declarativePools	^declarativePools! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'mu 11/26/2003 02:37'!declarativePools: aValue	declarativePools := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'MU 4/8/2000 18:29'!indexableInstVarType	^indexableInstVarType! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'MU 4/8/2000 18:29'!indexableInstVarType: aValue	indexableInstVarType := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!instMethodCategories	instMethodCategories isNil ifTrue:[ self privResolveInstMethodCategories].	^instMethodCategories! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!instMethodCategories: aValue	instMethodCategories := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'MU 6/17/2000 23:56'!instMethods	instMethodCategories notNil ifTrue:[instMethods := instMethodCategories inject: self defaultAnalyzableCollection into:[:n :e | n addAll: e methods; yourself]].	instMethods isNil ifTrue:[ self privResolveInstMethods].	^instMethods! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!instMethods: aValue	instMethods := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!instVariables	instVariables isNil ifTrue:[ self privResolveInstVariables].	^instVariables! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!instVariables: aValue	instVariables := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'MU 10/7/2000 00:43'!isRootClass	^isRootClass! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'MU 10/7/2000 00:43'!isRootClass: aValue	isRootClass := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!pools	pools isNil ifTrue:[ self privResolvePools].	^pools! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!pools: aValue	pools := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!subclasses	subclasses isNil ifTrue:[ self privResolveSubclasses].	^subclasses! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!subclasses: aValue	subclasses := aValue! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!superclass	superclass isNil ifTrue:[ self privResolveSuperclass].	^superclass! !!DlAnalyzableClass methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:27'!superclass: aValue	superclass := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableClass class	instanceVariableNames: ''!!DlAnalyzableClass class methodsFor: 'instance creation' stamp: 'M.U. 9/24/1999 02:19'!fromClass: aClass 	^ (self named: aClass name)		target: aClass.! !!DlAnalyzableClass class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:40'!description	"default string description of me"		^'class'  ! !!DlAnalyzableClass class methodsFor: 'private' stamp: 'M.U 4/28/1999 22:51'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	^ Smalltalk classNames includes: nm! !!DlAnalyzableClass class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:32'!validNew: aClassNameSymbol in: aScopeSpecifier 	^ (super validNew: aClassNameSymbol in: aScopeSpecifier)		target: (Smalltalk at: aClassNameSymbol ifAbsent:[])! !DlAnalyzableCategory subclass: #DlAnalyzableClassCategory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableClassCategory commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk class category.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableClassCategory methodsFor: 'actions' stamp: 'M.U 10/17/1999 18:21'!classes	^self categorizables! !!DlAnalyzableClassCategory methodsFor: 'actions' stamp: 'M.U 10/20/1999 01:02'!classes: aValue	self categorizables: aValue! !!DlAnalyzableClassCategory methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:54'!privResolveNext	self resolveStrategy nextResolveClassCategoryOn: self.			! !!DlAnalyzableClassCategory methodsFor: 'testing' stamp: 'MU 3/29/1999 00:13'!isClassCategory	^true! !!DlAnalyzableClassCategory methodsFor: 'factory-defaults' stamp: 'M.U 1/3/2000 00:10'!defaultIntrospector	^DlClassCategoryIntrospector named: self name! !!DlAnalyzableClassCategory methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:40'!privResolveCategorizables	self categorizables: (self createRelatives: [:elemName | DlAnalyzableClass named: elemName]			using: self introspector getClassNames).! !!DlAnalyzableClassCategory methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:40'!privResolveOrganizer	self organizer: (self createRelative: [self newGlobalRoot]).	! !!DlAnalyzableClassCategory methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:52'!privAnalyze	self analysisStrategy analyzeClassCategoryOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableClassCategory class	instanceVariableNames: ''!!DlAnalyzableClassCategory class methodsFor: 'factory' stamp: 'MU 12/26/1998 16:41'!systemOrganization	^SystemOrganization! !!DlAnalyzableClassCategory class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:41'!description	"default string description of me"		^'class category'  ! !!DlAnalyzableClassCategory class methodsFor: 'private' stamp: 'MU 12/27/1998 00:10'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	^ (self systemOrganization categories includes: nm)! !DlAnalyzable subclass: #DlAnalyzableClassFeature	instanceVariableNames: 'klass'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableClassFeature commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk class feature (i.e. variables and methods).#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableClassFeature methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:23'!initRelatives	super initRelatives.	klass := nil		! !!DlAnalyzableClassFeature methodsFor: 'testing' stamp: 'MU 3/28/1999 23:50'!isClassCategoryMember	^true! !!DlAnalyzableClassFeature methodsFor: 'testing' stamp: 'MU 3/29/1999 00:47'!isClassFeature	^true! !!DlAnalyzableClassFeature methodsFor: 'testing' stamp: 'MU 3/28/1999 23:47'!isClassMember	^true! !!DlAnalyzableClassFeature methodsFor: 'factory-defaults' stamp: 'M.U 1/3/2000 02:42'!defaultIntrospector	^DlClassIntrospector on: self scopeSpecifier! !!DlAnalyzableClassFeature methodsFor: 'private' stamp: 'M.U 1/10/2000 17:10'!privResolveRelatives	super privResolveRelatives.	self privResolveKlass.	! !!DlAnalyzableClassFeature methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:26'!privResolveKlass	self klass: (self createRelative:[self newClass]).! !!DlAnalyzableClassFeature methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:25'!klass	klass isNil ifTrue:[ self privResolveKlass].	^klass! !!DlAnalyzableClassFeature methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:25'!klass: aValue	klass := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableClassFeature class	instanceVariableNames: ''!!DlAnalyzableClassFeature class methodsFor: 'constants' stamp: 'M.U 5/3/1999 16:31'!description	"default string description of me"		^'class feature'  ! !DlAnalyzableAggregation subclass: #DlAnalyzableGlobalRoot	instanceVariableNames: 'pools globalVariables'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableGlobalRoot commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk global root (i.e. "Smalltalk" SystemDictionary)#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableGlobalRoot methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:24'!initRelatives	super initRelatives.	pools := globalVariables := nil.			! !!DlAnalyzableGlobalRoot methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:55'!privResolveNext	self resolveStrategy nextResolveGlobalRootOn: self.			! !!DlAnalyzableGlobalRoot methodsFor: 'testing' stamp: 'M.U 12/27/1999 00:21'!isGlobalRoot	^true! !!DlAnalyzableGlobalRoot methodsFor: 'factory-defaults' stamp: 'M.U 1/2/2000 23:05'!defaultIntrospector	^DlGlobalRootIntrospector on: self target! !!DlAnalyzableGlobalRoot methodsFor: 'private' stamp: 'M.U 12/27/1999 00:25'!privAnalyze	self analysisStrategy analyzeGlobalRootOn: self.! !!DlAnalyzableGlobalRoot methodsFor: 'private' stamp: 'M.U 1/10/2000 01:42'!privResolveRelatives	super privResolveRelatives.	self privResolveGlobalVariables.	self privResolvePools! !!DlAnalyzableGlobalRoot methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:23'!privResolveGlobalVariables	| gIntro glvs |	gIntro := self introspector.	"global variables"	glvs := self createRelatives: [:elemName | DlAnalyzableGlobalVariable named: elemName in: self target]				using: gIntro getGlobalVariableNames.	self globalVariables: glvs.! !!DlAnalyzableGlobalRoot methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:24'!privResolvePools	| gIntro pls |	gIntro := self introspector.	"pools"	pls := self createRelatives: [:elemName | DlAnalyzablePool named: elemName in: self target]				using: gIntro getPoolNames.	self pools: pls.! !!DlAnalyzableGlobalRoot methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:23'!globalVariables	globalVariables isNil ifTrue:[ self privResolveGlobalVariables].	^globalVariables! !!DlAnalyzableGlobalRoot methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:23'!globalVariables: aValue	globalVariables := aValue! !!DlAnalyzableGlobalRoot methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:23'!pools	pools isNil ifTrue:[ self privResolvePools].	^pools! !!DlAnalyzableGlobalRoot methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:23'!pools: aValue	pools := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableGlobalRoot class	instanceVariableNames: ''!!DlAnalyzableGlobalRoot class methodsFor: 'constants' stamp: 'M.U 1/1/2000 01:49'!description	"default string description of me"		^'global root'  ! !!DlAnalyzableGlobalRoot class methodsFor: 'private' stamp: 'M.U 4/29/1999 00:44'!isValidName: aNameSymbol 	"#Smalltalk is a single global name space ( I hope more modularity in Squeak!!!!)"	| nm |	nm := aNameSymbol asSymbol.	^nm == #Smalltalk	! !!DlAnalyzableGlobalRoot class methodsFor: 'private' stamp: 'M.U 1/1/2000 01:49'!validNew: aGlobalRootNameSymbol in: aScopeSpecifier 	| inst |	inst := super validNew: aGlobalRootNameSymbol in: aScopeSpecifier.	aGlobalRootNameSymbol == #Smalltalk ifTrue: [inst target: Smalltalk].	^ inst.! !DlAnalyzableClassFeature subclass: #DlAnalyzableLocalScopeVariable	instanceVariableNames: 'type initialValue value'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableLocalScopeVariable commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk local scope variable(i.e. instance variables + class variables + class instance variables).#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableLocalScopeVariable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:30'!initValues	super initValues.	type := initialValue := value := nil.! !!DlAnalyzableLocalScopeVariable methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:55'!privResolveNext	self resolveStrategy nextResolveLocalScopeVariableOn: self.			! !!DlAnalyzableLocalScopeVariable methodsFor: 'accessing' stamp: 'MU 3/15/1999 00:48'!initialValue	^initialValue	! !!DlAnalyzableLocalScopeVariable methodsFor: 'accessing' stamp: 'MU 3/15/1999 00:51'!initialValue: aValue	initialValue := aValue! !!DlAnalyzableLocalScopeVariable methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!type	^type! !!DlAnalyzableLocalScopeVariable methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!type: aValue	type := aValue! !!DlAnalyzableLocalScopeVariable methodsFor: 'accessing' stamp: 'M.U 4/29/1999 00:08'!value	^value	! !!DlAnalyzableLocalScopeVariable methodsFor: 'accessing' stamp: 'M.U 4/29/1999 00:08'!value: aValue	value := aValue! !!DlAnalyzableLocalScopeVariable methodsFor: 'testing' stamp: 'MU 10/9/2000 00:55'!hasType	^self type notNil! !!DlAnalyzableLocalScopeVariable methodsFor: 'testing' stamp: 'M.U 5/2/1999 19:39'!isLocalVariable	^true! !!DlAnalyzableLocalScopeVariable methodsFor: 'testing' stamp: 'MU 3/29/1999 00:11'!isVariable	^true! !!DlAnalyzableLocalScopeVariable methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:56'!privAnalyze	self analysisStrategy analyzeVariableOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableLocalScopeVariable class	instanceVariableNames: ''!!DlAnalyzableLocalScopeVariable class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:47'!description	"default string description of me"		^'variable'  ! !!DlAnalyzableLocalScopeVariable class methodsFor: 'private' stamp: 'M.U 4/29/1999 19:43'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	Smalltalk		allClassesDo: [:each | ((each instVarNames includes: nm)				or: [(each classVarNames includes: nm)						or: [each class instVarNames includes: nm]])				ifTrue: [^ true]].	^ false! !!DlAnalyzableLocalScopeVariable class methodsFor: 'private' stamp: 'M.U 4/29/1999 19:43'!isValidName: aNameSymbol in: aScopeClass 	| nm |	nm := aNameSymbol asSymbol.	^ (aScopeClass instVarNames includes: nm)		or: [(aScopeClass classVarNames includes: nm)				or: [aScopeClass class instVarNames includes: nm]]! !DlAnalyzableLocalScopeVariable subclass: #DlAnalyzableClassInstVariable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableClassInstVariable commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk class instance variable.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableClassInstVariable methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:52'!privAnalyze	self analysisStrategy analyzeClassInstVariableOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableClassInstVariable class	instanceVariableNames: ''!!DlAnalyzableClassInstVariable class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:41'!description	"default string description of me"		^'class instance variable'  ! !!DlAnalyzableClassInstVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:35'!isValidName: aNameSymbol 	| nm |	nm _ aNameSymbol asSymbol.	Smalltalk		allClassesDo: [:each | (each class instVarNames detect: [:instVar | instVar = nm]				ifNone: [])				~~ nil ifTrue: [^ true]].	^ false! !!DlAnalyzableClassInstVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:35'!isValidName: aNameSymbol in: aScopeClass 	| nm |	nm := aNameSymbol asSymbol.	^ (aScopeClass class instVarNames detect: [:instVar | instVar = nm]		ifNone: [])		~~ nil		! !DlAnalyzableLocalScopeVariable subclass: #DlAnalyzableClassVariable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableClassVariable commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk class variable.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableClassVariable methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:52'!privAnalyze	self analysisStrategy analyzeClassVariableOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableClassVariable class	instanceVariableNames: ''!!DlAnalyzableClassVariable class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:45'!description	"default string description of me"		^'class variable'  ! !!DlAnalyzableClassVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:36'!isValidName: aNameSymbol 	| nm |	nm _ aNameSymbol asSymbol.	Smalltalk		allClassesDo: [:each | (each classVarNames detect: [:clsVar | clsVar = nm]				ifNone: [])				~~ nil ifTrue: [^ true]].	^ false! !!DlAnalyzableClassVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:36'!isValidName: aNameSymbol in: aScopeClass 	| nm |	nm := aNameSymbol asSymbol.	^ (aScopeClass classVarNames detect: [:clsVar | clsVar = nm]		ifNone: [])		~~ nil		! !DlAnalyzableLocalScopeVariable subclass: #DlAnalyzableInstVariable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableInstVariable commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk instance variable.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableInstVariable methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:53'!privAnalyze	self analysisStrategy analyzeInstVariableOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableInstVariable class	instanceVariableNames: ''!!DlAnalyzableInstVariable class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:46'!description	"default string description of me"		^'instance variable'  ! !!DlAnalyzableInstVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:37'!isValidName: aNameSymbol 	| nm |	nm _ aNameSymbol asSymbol.	Smalltalk		allClassesDo: [:each | (each instVarNames detect: [:instVar | instVar = nm]				ifNone: [])				~~ nil ifTrue: [^ true]].	^ false! !!DlAnalyzableInstVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:37'!isValidName: aNameSymbol in: aScopeClass 	| nm |	nm := aNameSymbol asSymbol.	^ (aScopeClass instVarNames detect: [:instVar | instVar = nm]		ifNone: [])		~~ nil		! !DlAnalyzableClassFeature subclass: #DlAnalyzableMethod	instanceVariableNames: 'category signature arguments returns source sourceBody compiledCode isPrivate isPrimitive'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableMethod commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk method.# implements: DlCategorizable#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableMethod methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:33'!initRelatives	super initRelatives.	category := nil! !!DlAnalyzableMethod methodsFor: 'initialize-release' stamp: 'MU 12/4/2000 01:31'!initValues	super initValues.	signature := arguments := returns := source := sourceBody := compiledCode :=  nil.	isPrivate := isPrimitive := false.! !!DlAnalyzableMethod methodsFor: 'actions' stamp: 'M.U 10/18/1999 00:08'!klass	^ (klass isNil and: [self category isNil not])		ifTrue: [self category klass]		ifFalse: [klass].! !!DlAnalyzableMethod methodsFor: 'actions' stamp: 'M.U 10/18/1999 00:08'!klass: aValue 	self category isNil ifFalse: [self category klass: aValue].	klass := aValue.! !!DlAnalyzableMethod methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:55'!privResolveNext	self resolveStrategy nextResolveMethodOn: self.			! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 9/30/2000 23:52'!arguments	arguments isNil ifTrue:[arguments := OrderedCollection new].	^arguments! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!arguments: aValue	arguments := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'M.U 1/26/2000 23:42'!category	category isNil ifTrue:[ self privResolveCategory].	^category! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'M.U 10/18/1999 00:07'!category: aValue	category := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 6/18/2000 00:12'!compiledCode	^compiledCode! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 6/18/2000 00:12'!compiledCode: aValue	compiledCode := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!isPrimitive	^isPrimitive! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!isPrimitive: aValue	isPrimitive := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!isPrivate	^isPrivate! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!isPrivate: aValue	isPrivate := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 9/30/2000 23:53'!returns	returns isNil ifTrue:[returns := OrderedCollection new].	^returns! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!returns: aValue	returns := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!signature	^signature! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!signature: aValue	signature := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 6/18/2000 02:34'!source	^source! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 6/18/2000 02:34'!source: aValue	source := aValue! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!sourceBody	^sourceBody! !!DlAnalyzableMethod methodsFor: 'accessing' stamp: 'MU 1/5/1999 23:13'!sourceBody: aValue	sourceBody := aValue! !!DlAnalyzableMethod methodsFor: 'testing' stamp: 'M.U 10/17/1999 18:25'!isCategorizable	^true	! !!DlAnalyzableMethod methodsFor: 'testing' stamp: 'MU 3/29/1999 00:11'!isMethod	^true! !!DlAnalyzableMethod methodsFor: 'testing' stamp: 'MU 3/28/1999 23:52'!isMethodCategoryMember	^true! !!DlAnalyzableMethod methodsFor: 'factory-defaults' stamp: 'MU 6/18/2000 02:25'!defaultIntrospector	^DlMethodIntrospector named: self name in: self scopeSpecifier! !!DlAnalyzableMethod methodsFor: 'private-resolving' stamp: 'M.U 1/26/2000 23:46'!privResolveCategory	^self subclassResponsibility! !!DlAnalyzableMethod methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:53'!privAnalyze	self analysisStrategy analyzeMethodOn: self.! !!DlAnalyzableMethod methodsFor: 'private' stamp: 'M.U 1/10/2000 01:49'!privResolveRelatives	super privResolveRelatives.	self privResolveCategory! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableMethod class	instanceVariableNames: ''!!DlAnalyzableMethod class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:46'!description	"default string description of me"		^'method'  ! !!DlAnalyzableMethod class methodsFor: 'private' stamp: 'MU 12/28/1998 23:36'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	Smalltalk		allBehaviorsDo: [:each | (each includesSelector: nm)				ifTrue: [^ true]].	^ false! !!DlAnalyzableMethod class methodsFor: 'private' stamp: 'MU 12/28/1998 22:55'!isValidName: aNameSymbol in: aScopeClass	^ ((aScopeClass includesSelector: aNameSymbol) or: [aScopeClass class includesSelector: aNameSymbol])! !DlAnalyzableMethod subclass: #DlAnalyzableClassMethod	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableClassMethod commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk class method.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableClassMethod methodsFor: 'private-resolving' stamp: 'MU 6/18/2000 02:30'!privResolveCategory	| mCatName |	mCatName := self introspector getCategoryName.	mCatName isNil ifFalse: [self category: (self createRelative: [DlAnalyzableClassMethodCategory named: mCatName in: self scopeSpecifier])].! !!DlAnalyzableClassMethod methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:52'!privAnalyze	self analysisStrategy analyzeClassMethodOn: self.! !!DlAnalyzableClassMethod methodsFor: 'factory-defaults' stamp: 'MU 6/18/2000 02:24'!defaultIntrospector	^DlMethodIntrospector named: self name in: self scopeSpecifier class! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableClassMethod class	instanceVariableNames: ''!!DlAnalyzableClassMethod class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:42'!description	"default string description of me"		^'class method'  ! !!DlAnalyzableClassMethod class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:36'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	^ (Smalltalk allClasses detect: [:eachCls | eachCls class includesSelector: nm]		ifNone: [])		~~ nil! !!DlAnalyzableClassMethod class methodsFor: 'private' stamp: 'MU 12/28/1998 22:58'!isValidName: aNameSymbol in: aScopeClass	^ (aScopeClass class includesSelector: aNameSymbol) ! !DlAnalyzableMethod subclass: #DlAnalyzableInstMethod	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableInstMethod commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk instance method.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableInstMethod methodsFor: 'private-resolving' stamp: 'MU 6/18/2000 02:30'!privResolveCategory	| mCatName |	mCatName := self introspector getCategoryName.	mCatName isNil ifFalse: [self category: (self createRelative: [DlAnalyzableInstMethodCategory named: mCatName in: self scopeSpecifier])].! !!DlAnalyzableInstMethod methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:53'!privAnalyze	self analysisStrategy analyzeInstMethodOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableInstMethod class	instanceVariableNames: ''!!DlAnalyzableInstMethod class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:45'!description	"default string description of me"		^'instance method'  ! !!DlAnalyzableInstMethod class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:37'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	^ (Smalltalk allClasses detect: [:eachCls | eachCls includesSelector: nm]		ifNone: [])		~~ nil! !!DlAnalyzableInstMethod class methodsFor: 'private' stamp: 'MU 12/28/1998 22:57'!isValidName: aNameSymbol in: aScopeClass	^ (aScopeClass includesSelector: aNameSymbol)! !DlAnalyzableCategory subclass: #DlAnalyzableMethodCategory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableMethodCategory commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk method category.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableMethodCategory methodsFor: 'initialize-release' stamp: 'mu 11/25/2004 01:43'!initValues	super initValues.	! !!DlAnalyzableMethodCategory methodsFor: 'actions' stamp: 'M.U 1/10/2000 00:04'!klass	^self organizer! !!DlAnalyzableMethodCategory methodsFor: 'actions' stamp: 'M.U 1/10/2000 00:06'!klass: aValue	^self organizer: aValue! !!DlAnalyzableMethodCategory methodsFor: 'actions' stamp: 'M.U 10/17/1999 18:22'!methods	^self categorizables! !!DlAnalyzableMethodCategory methodsFor: 'actions' stamp: 'M.U 10/30/1999 18:28'!methods: aCollectionOfDlAnalyzableMethods	^self categorizables: aCollectionOfDlAnalyzableMethods! !!DlAnalyzableMethodCategory methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:56'!privResolveNext	self resolveStrategy nextResolveMethodCategoryOn: self.			! !!DlAnalyzableMethodCategory methodsFor: 'testing' stamp: 'MU 3/28/1999 23:51'!isClassCategoryMember	^true! !!DlAnalyzableMethodCategory methodsFor: 'testing' stamp: 'MU 3/28/1999 23:42'!isClassMember	^true! !!DlAnalyzableMethodCategory methodsFor: 'testing' stamp: 'MU 3/29/1999 00:12'!isMethodCategory	^true! !!DlAnalyzableMethodCategory methodsFor: 'factory-defaults' stamp: 'M.U 1/3/2000 02:39'!defaultIntrospector	^DlClassIntrospector on: self scopeSpecifier! !!DlAnalyzableMethodCategory methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:41'!privResolveOrganizer	self organizer: (self createRelative:[self newClass]).	! !!DlAnalyzableMethodCategory methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:53'!privAnalyze	self analysisStrategy analyzeMethodCategoryOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableMethodCategory class	instanceVariableNames: ''!!DlAnalyzableMethodCategory class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:47'!description	"default string description of me"		^'method category'  ! !!DlAnalyzableMethodCategory class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:38'!isValidName: aNameSymbol 	| nm ord |	nm := aNameSymbol asSymbol.	ord := OrderedCollection new.	Smalltalk allBehaviorsDo: [:each | ord add: each].	^ (ord resolve: [:eachCls | eachCls organization categories includes: nm]		ifNone: [])		~~ nil! !!DlAnalyzableMethodCategory class methodsFor: 'private' stamp: 'M.U. 10/3/1999 01:50'!isValidName: aCategoryNameSymbol in: aScopeSpecifier 	| nm |	nm _ aCategoryNameSymbol asSymbol.	^ (aScopeSpecifier organization categories includes: nm)		or: [aScopeSpecifier class organization categories includes: nm].! !DlAnalyzableMethodCategory subclass: #DlAnalyzableClassMethodCategory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableClassMethodCategory commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk class method category.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableClassMethodCategory methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 17:57'!privResolveCategorizables	| cls mthods |	cls := self scopeSpecifier.	mthods := self introspector getClassMethodNamesOf: self name.	self categorizables: ( self createRelatives: [:elemName | DlAnalyzableClassMethod named: elemName in: cls]				using: mthods).	! !!DlAnalyzableClassMethodCategory methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:52'!privAnalyze	self analysisStrategy analyzeClassMethodCategoryOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableClassMethodCategory class	instanceVariableNames: ''!!DlAnalyzableClassMethodCategory class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:44'!description	"default string description of me"		^'class method category'  ! !!DlAnalyzableClassMethodCategory class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:36'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	^ (Smalltalk allClasses detect: [:eachCls | eachCls class includesSelector: nm]		ifNone: [])		~~ nil! !!DlAnalyzableClassMethodCategory class methodsFor: 'private' stamp: 'M.U. 10/3/1999 01:47'!isValidName: aCategoryNameSymbol in: aScopeSpecifier	| nm |	nm := aCategoryNameSymbol asSymbol.	^(aScopeSpecifier class organization categories includes: nm)				! !DlAnalyzableMethodCategory subclass: #DlAnalyzableInstMethodCategory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableInstMethodCategory commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk instance method category.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableInstMethodCategory methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:41'!privResolveCategorizables	| cls mthods |	cls := self scopeSpecifier.	mthods := self introspector getInstMethodNamesOf: self name.	self categorizables: ( self createRelatives: [:elemName | DlAnalyzableInstMethod named: elemName in: cls]				using: mthods).! !!DlAnalyzableInstMethodCategory methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:53'!privAnalyze	self analysisStrategy analyzeInstMethodCategoryOn: self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableInstMethodCategory class	instanceVariableNames: ''!!DlAnalyzableInstMethodCategory class methodsFor: 'constants' stamp: 'MU 3/23/1999 23:46'!description	"default string description of me"		^'instance method category'  ! !!DlAnalyzableInstMethodCategory class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:37'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	^ (Smalltalk allClasses detect: [:eachCls | eachCls includesSelector: nm]		ifNone: [])		~~ nil! !!DlAnalyzableInstMethodCategory class methodsFor: 'private' stamp: 'M.U. 10/3/1999 01:48'!isValidName: aCategoryNameSymbol in: aScopeSpecifier	| nm |	nm := aCategoryNameSymbol asSymbol.	^(aScopeSpecifier organization categories includes: nm)				! !DlAnalyzable subclass: #DlAnalyzableNonClassFeature	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableNonClassFeature commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk non class feature (i.e. Global Scope Variables).#creator[:masashi | ^umezawa] #version 0.5!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableNonClassFeature class	instanceVariableNames: ''!!DlAnalyzableNonClassFeature class methodsFor: 'constants' stamp: 'M.U 5/3/1999 16:32'!description	"default string description of me"		^'non class feature'  ! !DlAnalyzableNonClassFeature subclass: #DlAnalyzableGlobalScopeVariable	instanceVariableNames: 'type value'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableGlobalScopeVariable commentStamp: '<historical>' prior: 0!I represent an abstract "analyzable" Smalltalk global scope variable(i.e. Global Variables and Pools)#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableGlobalScopeVariable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:29'!initValues	super initValues.	type := value := nil.! !!DlAnalyzableGlobalScopeVariable methodsFor: 'accessing' stamp: 'M.U 4/29/1999 19:40'!type	^type! !!DlAnalyzableGlobalScopeVariable methodsFor: 'accessing' stamp: 'M.U 4/29/1999 19:40'!type: aValue	type := aValue! !!DlAnalyzableGlobalScopeVariable methodsFor: 'accessing' stamp: 'M.U 4/29/1999 19:40'!value	^value! !!DlAnalyzableGlobalScopeVariable methodsFor: 'accessing' stamp: 'M.U 4/29/1999 19:40'!value: aValue	value := aValue! !!DlAnalyzableGlobalScopeVariable methodsFor: 'testing' stamp: 'M.U 4/29/1999 19:47'!isGlobalScopeVariable	^true! !!DlAnalyzableGlobalScopeVariable methodsFor: 'testing' stamp: 'M.U 5/2/1999 19:41'!isVariable	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableGlobalScopeVariable class	instanceVariableNames: ''!!DlAnalyzableGlobalScopeVariable class methodsFor: 'constants' stamp: 'M.U 5/3/1999 16:31'!description	"default string description of me"		^'global scope variable'  ! !DlAnalyzableGlobalScopeVariable subclass: #DlAnalyzableGlobalVariable	instanceVariableNames: 'globalRoot'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableGlobalVariable commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk global variable.#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzableGlobalVariable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:29'!initRelatives	super initRelatives.	globalRoot := nil			! !!DlAnalyzableGlobalVariable methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:55'!privResolveNext	self resolveStrategy nextResolveGlobalVariableOn: self.			! !!DlAnalyzableGlobalVariable methodsFor: 'testing' stamp: 'M.U 5/3/1999 16:27'!isGlobalVariable	^true! !!DlAnalyzableGlobalVariable methodsFor: 'testing' stamp: 'M.U 5/3/1999 16:23'!isVariable	^true! !!DlAnalyzableGlobalVariable methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:52'!privAnalyze	self analysisStrategy analyzeGlobalVariableOn: self.! !!DlAnalyzableGlobalVariable methodsFor: 'private' stamp: 'M.U 1/10/2000 01:50'!privResolveRelatives	super privResolveRelatives.	self privResolveGlobalRoot.				! !!DlAnalyzableGlobalVariable methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:21'!privResolveGlobalRoot	self globalRoot:( self createRelative: [self newGlobalRoot]).! !!DlAnalyzableGlobalVariable methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:20'!globalRoot	globalRoot isNil ifTrue:[ self privResolveGlobalRoot].	^globalRoot! !!DlAnalyzableGlobalVariable methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:20'!globalRoot: aValue	globalRoot := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableGlobalVariable class	instanceVariableNames: ''!!DlAnalyzableGlobalVariable class methodsFor: 'constants' stamp: 'M.U 4/28/1999 02:11'!description	"default string description of me"		^'global variable'  ! !!DlAnalyzableGlobalVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:37'!isValidName: aNameSymbol 	| nm candidate |	nm := aNameSymbol asSymbol.	(Smalltalk includesKey: nm)		ifTrue: 			[candidate := Smalltalk at: nm.			(candidate isKindOf: Class)				ifTrue: [^ false].			Smalltalk allClasses do: [:cls | (cls sharedPools detect: [:pool | (Smalltalk keyAtIdentityValue: pool)						== nm]					ifNone: [])					~~ nil ifTrue: [^ false]].			^ true].	^ false! !!DlAnalyzableGlobalVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:32'!validNew: aNameSymbol in: aScopeSpecifier 	| inst |	inst := super validNew: aNameSymbol in: aScopeSpecifier..	inst target: (Smalltalk at: aNameSymbol ifAbsent: []).	inst target isNil		ifFalse: 			[inst value: inst target.			inst type: inst value class].	^ inst.! !DlAnalyzableAggregation subclass: #DlAnalyzablePool	instanceVariableNames: 'globalRoot referringClasses poolVariables'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzablePool commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk Pool (PoolDictionary).#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzablePool methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:35'!initRelatives	super initRelatives.	globalRoot := referringClasses := poolVariables := nil ! !!DlAnalyzablePool methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:56'!privResolveNext	self resolveStrategy nextResolvePoolOn: self.			! !!DlAnalyzablePool methodsFor: 'testing' stamp: 'M.U 5/3/1999 16:24'!isPool	^true! !!DlAnalyzablePool methodsFor: 'factory-defaults' stamp: 'M.U 1/2/2000 23:28'!defaultIntrospector	^DlPoolIntrospector on: self target! !!DlAnalyzablePool methodsFor: 'private' stamp: 'M.U 11/28/1999 16:37'!privAnalyze	self analysisStrategy analyzePoolOn: self.! !!DlAnalyzablePool methodsFor: 'private' stamp: 'M.U 1/10/2000 01:46'!privResolveRelatives	super privResolveRelatives.	self privResolveGlobalRoot.	self privResolvePoolVariables.	self privResolveReferringClasses! !!DlAnalyzablePool methodsFor: 'printing' stamp: 'M.U. 11/22/1999 23:49'!printOn: aStream 	self name isNil		ifTrue: [super printOn: aStream]		ifFalse: 			[aStream nextPutAll: self name.			aStream space.			self scopeSpecifier isNil				ifFalse: 					[aStream nextPutAll: #%.					"scopeSpecifier printOn: aStream."					aStream space].			aStream nextPut: $<.			self key printOn: aStream.			aStream nextPut: $>.			self isResolved				ifFalse: 					[aStream space.					aStream nextPutAll: #notResolved].			self isAnalyzed				ifFalse: 					[aStream space.					aStream nextPutAll: #notAnalyzed]].! !!DlAnalyzablePool methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:45'!privResolveGlobalRoot	self globalRoot: (self createRelative: [self newGlobalRoot]).! !!DlAnalyzablePool methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:45'!privResolvePoolVariables	self poolVariables: (self createRelatives: [:elemName | DlAnalyzablePoolVariable named: elemName in: self target]			using: self introspector getPoolVariableNames).! !!DlAnalyzablePool methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:45'!privResolveReferringClasses	self referringClasses: (self createRelatives: [:elemName | DlAnalyzableClass named: elemName]			using: self introspector getReferringClassNames).! !!DlAnalyzablePool methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:19'!globalRoot	globalRoot isNil ifTrue:[ self privResolveGlobalRoot].	^globalRoot! !!DlAnalyzablePool methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:19'!globalRoot: aValue	globalRoot := aValue! !!DlAnalyzablePool methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:19'!poolVariables	poolVariables isNil ifTrue:[ self privResolvePoolVariables].	^poolVariables! !!DlAnalyzablePool methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:19'!poolVariables: aValue	poolVariables := aValue! !!DlAnalyzablePool methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:19'!referringClasses	referringClasses isNil ifTrue:[ self privResolveReferringClasses].	^referringClasses! !!DlAnalyzablePool methodsFor: 'accessing' stamp: 'M.U 1/10/2000 01:19'!referringClasses: aValue	referringClasses := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzablePool class	instanceVariableNames: ''!!DlAnalyzablePool class methodsFor: 'instance creation' stamp: 'mu 11/9/2004 01:43'!fromPool: aPool 	| actualClass |	actualClass := (aPool isKindOf: Dictionary)				ifTrue: [DlAnalyzablePoolDictionary]				ifFalse: [DlAnalyzableDeclarativePool].	^ actualClass fromPool: aPool! !!DlAnalyzablePool class methodsFor: 'constants' stamp: 'M.U 1/1/2000 19:16'!defaultScopeSpecifier	^Smalltalk! !!DlAnalyzablePool class methodsFor: 'constants' stamp: 'mu 11/26/2003 02:58'!description	"default string description of me"		^'shared pool'  ! !!DlAnalyzablePool class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:33'!validNew: aNameSymbol in: aScopeSpecifier 	| inst |	inst := super validNew: aNameSymbol in: aScopeSpecifier..	inst target: (Smalltalk at: aNameSymbol ifAbsent:[]).	^ inst.! !DlAnalyzablePool subclass: #DlAnalyzableDeclarativePool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzableDeclarativePool methodsFor: 'factory-defaults' stamp: 'mu 11/26/2003 03:03'!defaultIntrospector	^DlDeclarativePoolIntrospector on: self target! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzableDeclarativePool class	instanceVariableNames: ''!!DlAnalyzableDeclarativePool class methodsFor: 'instance creation' stamp: 'mu 11/26/2003 02:19'!fromPool: aPool	(aPool isKindOf: Dictionary) ifTrue: [^super fromPool: aPool].	^ (super new)		target: aPool;		scopeSpecifier: self defaultScopeSpecifier;		name: aPool name! !!DlAnalyzableDeclarativePool class methodsFor: 'constants' stamp: 'mu 11/26/2003 02:15'!description	"default string description of me"		^'declarative pool'  ! !!DlAnalyzableDeclarativePool class methodsFor: 'private' stamp: 'mu 11/26/2003 02:23'!isValidName: aNameSymbol 	| nm ord result |	nm := aNameSymbol asSymbol.	ord := OrderedCollection new: 40.	SharedPool allSubclasses do: [:each | ord addAll: each].	result := ord detect: [:pool | (pool name) == nm] ifNone:[].	^ result notNil! !DlAnalyzablePool subclass: #DlAnalyzablePoolDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzablePoolDictionary methodsFor: 'factory-defaults' stamp: 'mu 11/26/2003 03:02'!defaultIntrospector	^DlPoolDictionaryIntrospector on: self target! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzablePoolDictionary class	instanceVariableNames: ''!!DlAnalyzablePoolDictionary class methodsFor: 'instance creation' stamp: 'mu 11/26/2003 02:56'!fromPool: aPool	^ (super new)		target: aPool;		scopeSpecifier: self defaultScopeSpecifier;		name: (self defaultScopeSpecifier keyAtIdentityValue: aPool)! !!DlAnalyzablePoolDictionary class methodsFor: 'constants' stamp: 'mu 11/26/2003 02:57'!description	"default string description of me"		^'pool dictionary'  ! !!DlAnalyzablePoolDictionary class methodsFor: 'private' stamp: 'mu 11/26/2003 02:57'!isValidName: aNameSymbol 	| nm ord result |	nm := aNameSymbol asSymbol.	ord := OrderedCollection new: 40.	Smalltalk allClasses do: [:each | ord addAll: each sharedPools].	result := ord detect: [:pool | (Smalltalk keyAtIdentityValue: pool ) == nm] ifNone:[].	^ result notNil! !DlAnalyzableGlobalScopeVariable subclass: #DlAnalyzablePoolVariable	instanceVariableNames: 'pool'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlAnalyzablePoolVariable commentStamp: '<historical>' prior: 0!I represent an "analyzable" Smalltalk Pool Variable (a variable binding in a PoolDictionary).#creator[:masashi | ^umezawa] #version 0.5!!DlAnalyzablePoolVariable methodsFor: 'initialize-release' stamp: 'M.U 1/9/2000 23:36'!initRelatives	super initRelatives.	pool := nil	! !!DlAnalyzablePoolVariable methodsFor: 'resolving' stamp: 'M.U 1/10/2000 22:56'!privResolveNext	self resolveStrategy nextResolvePoolVariableOn: self.			! !!DlAnalyzablePoolVariable methodsFor: 'private' stamp: 'M.U. 11/21/1999 22:53'!privAnalyze	self analysisStrategy analyzePoolVariableOn: self.! !!DlAnalyzablePoolVariable methodsFor: 'private' stamp: 'M.U 1/10/2000 01:44'!privResolveRelatives	super privResolveRelatives.	self privResolvePool! !!DlAnalyzablePoolVariable methodsFor: 'testing' stamp: 'M.U 5/3/1999 16:28'!isPoolVariable	^true! !!DlAnalyzablePoolVariable methodsFor: 'private-resolving' stamp: 'M.U 1/10/2000 01:43'!privResolvePool	self pool: (self createRelative: [DlAnalyzablePool fromPool: self scopeSpecifier]).! !!DlAnalyzablePoolVariable methodsFor: 'accessing' stamp: 'M.U 1/10/2000 00:17'!pool	pool isNil ifTrue:[ self privResolvePool].	^pool! !!DlAnalyzablePoolVariable methodsFor: 'accessing' stamp: 'M.U 4/29/1999 00:12'!pool: aValue	pool := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DlAnalyzablePoolVariable class	instanceVariableNames: ''!!DlAnalyzablePoolVariable class methodsFor: 'constants' stamp: 'M.U 4/28/1999 02:10'!description	"default string description of me"		^'pool variable'  ! !!DlAnalyzablePoolVariable class methodsFor: 'private' stamp: 'M.U 10/30/1999 21:38'!isValidName: aNameSymbol 	| nm |	nm := aNameSymbol asSymbol.	Smalltalk allClasses do: [:each | (each sharedPools detect: [:pool | pool keys includes: nm]			ifNone: [])			~~ nil ifTrue: [^ true]].	^ false! !!DlAnalyzablePoolVariable class methodsFor: 'private' stamp: 'M.U 4/28/1999 23:27'!isValidName: aNameSymbol in: aScopePool	^ (aScopePool includesKey: aNameSymbol)! !!DlAnalyzablePoolVariable class methodsFor: 'private' stamp: 'mu 11/24/2004 01:34'!validNew: aNameSymbol in: aScopeSpecifier 	| inst |	inst := super validNew: aNameSymbol in: aScopeSpecifier.	aScopeSpecifier isNil		ifFalse: [| tgt | 			tgt := (aScopeSpecifier isKindOf: Dictionary)						ifTrue: [aScopeSpecifier								at: aNameSymbol								ifAbsent: [aScopeSpecifier										at: aNameSymbol asString										ifAbsent: []]]						ifFalse: [| binding | 							binding := aScopeSpecifier bindingOf: aNameSymbol.							binding isNil								ifFalse: [binding value]].			inst target: tgt.			inst target isNil				ifFalse: [inst value: inst target.					inst type: inst target class]].	^ inst! !Object subclass: #DlObsoleteClass	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Dandelion-analyzable'!!DlObsoleteClass commentStamp: '<historical>' prior: 0!I represent an obsolete class once existed in this image.#creator[:masashi | ^umezawa] #version 0.1!!DlObsoleteClass methodsFor: 'accessing' stamp: 'MU 12/4/2000 00:51'!name: aSymbol	name := aSymbol! !DlAbstractAnalyzable initialize!